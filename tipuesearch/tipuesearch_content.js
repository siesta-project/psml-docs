var tipuesearch = {"pages":[{"title":" libPSML ","text":"libPSML The library provides an API for parsing PSML files and extracting\ninformation from them. For more information, and to begin exploring the PSML ecosystem,\ncheck out the Overview . Developer Info Alberto Garcia","tags":"home","loc":"index.html"},{"title":"psml_die_for_tests.F90 – libPSML","text":"Contents Subroutines psml_die Source Code psml_die_for_tests.F90 Source Code subroutine psml_die ( str ) character ( len =* ), intent ( in ) :: str write ( 0 , \"(a)\" ) str stop end subroutine psml_die","tags":"","loc":"sourcefile/psml_die_for_tests.f90.html"},{"title":"m_psml_reader.F90 – libPSML","text":"Contents Modules m_psml_reader Source Code m_psml_reader.F90 Source Code #if defined HAVE_CONFIG_H #include \"config.h\" #endif module m_psml_reader public :: psml_reader CONTAINS subroutine psml_reader ( fname , ps , debug ) use m_psml_core , only : ps_t , ps_destroy use m_psml_tables , only : ps_GenerateTables use m_psml_parsing_helpers , only : begin_element , end_element , pcdata_chunk use m_psml_parsing_helpers , only : cdata_section_chunk use m_psml_parsing_helpers , only : pseudo , debug_parsing use external_interfaces , only : die => psml_die use m_psml_interp , only : set_default_interpolator use xmlf90_sax , only : xml_t , open_xmlfile , xml_parse , close_xmlfile implicit none character ( len =* ), intent ( in ) :: fname type ( ps_t ), intent ( inout ), target :: ps logical , intent ( in ), optional :: debug type ( xml_t ) :: fxml integer :: iostat ! Clean the object's internal data ! Note that the inout intent allow us ! to do this, and avoid having ps being ! reset by the compiler call ps_destroy ( ps ) ! Associate module pointer, so that the parsed data ! is written to ps pseudo => ps if ( present ( debug )) then debug_parsing = debug else debug_parsing = . false . endif ! Allocate internal structures here... call open_xmlfile ( fname , fxml , iostat ) if ( iostat /= 0 ) call die ( \"Cannot open PSML file: \" // trim ( fname )) call xml_parse ( fxml , begin_element , end_element , pcdata_chunk , & cdata_section_handler = cdata_section_chunk , verbose = . false .) call close_xmlfile ( fxml ) ! Clean up association of module pointer pseudo => null () call ps_GenerateTables ( ps ) ! ! Set default interpolator ! call set_default_interpolator () end subroutine psml_reader end module m_psml_reader","tags":"","loc":"sourcefile/m_psml_reader.f90.html"},{"title":"m_psml_api.F90 – libPSML","text":"libPSML API implementation Contents Modules m_psml_api Source Code m_psml_api.F90 Source Code !+ libPSML API implementation #if defined HAVE_CONFIG_H #include \"config.h\" #endif module m_psml_api !+ graph: false !+ Procedures to handle the PSML pseudopotential format. use m_psml_core use m_aux_aliases , only : ps_radfunc_t use assoc_list , only : ps_annotation_t => assoc_list_t use assoc_list , only : EMPTY_ANNOTATION => EMPTY_ASSOC_LIST use external_interfaces , only : die => psml_die use class_Grid implicit none integer , parameter :: dp = selected_real_kind ( 14 ) logical :: global_debug = . false . logical :: global_use_effective_range = . true . character ( len = 1 ), dimension ( 0 : 4 ) :: sym = ( / \"s\" , \"p\" , \"d\" , \"f\" , \"g\" / ) ! Library operation routines public :: ps_GetLibPSMLVersion public :: ps_SetEvaluatorOptions ! ! Accessor list ! public :: ps_RootAttributes_Get public :: ps_Provenance_Depth public :: ps_Provenance_Get public :: ps_PseudoAtomSpec_Get public :: ps_ExchangeCorrelation_Get public :: ps_LibxcFunctional_Get public :: ps_ValenceConfiguration_Get public :: ps_ValenceShell_Get ! public :: ps_ValenceCharge_Value public :: ps_ValenceCharge_Get ! public :: ps_CoreCharge_Value public :: ps_CoreCharge_Get ! ! Semilocal potentials ! public :: ps_HasSemilocalPotentials public :: ps_SemilocalPotentials_Filter public :: ps_Potential_Get public :: ps_Potential_Value ! Pseudo Operator ! public :: ps_HasPsOperator ! ! Vlocal ! public :: ps_HasLocalPotential public :: ps_LocalPotential_Get public :: ps_LocalPotential_Value ! ! Projectors ! public :: ps_HasProjectors public :: ps_NonlocalProjectors_Filter public :: ps_Projector_Get public :: ps_Projector_Value ! ! Pseudo-wave-functions ! public :: ps_PseudoWavefunctions_Filter public :: ps_PseudoWf_Get public :: ps_PseudoWf_Value ! Grid Annotations public :: ps_GridAnnotation ! ! Exported low-level routines ! public :: ps_GetValue public :: ps_GetRawData ! ! Aliases ! interface ps_Potential_Filter module procedure ps_SemiLocalPotentials_Filter end interface ps_Potential_Filter public :: ps_Potential_Filter interface ps_Projector_Filter module procedure ps_NonLocalProjectors_Filter end interface ps_Projector_Filter public :: ps_Projector_Filter interface ps_PseudoWf_Filter module procedure ps_PseudoWaveFunctions_Filter end interface ps_PseudoWf_Filter public :: ps_PseudoWf_Filter private CONTAINS ! ! ============================================================== ! !>  Returns the library version in integer format function ps_GetLibPSMLVersion () result ( v ) integer :: v v = PSML_LIBRARY_VERSION end function ps_GetLibPSMLVersion !> Sets various parameters for the operation of !> the evaluator subroutine ps_SetEvaluatorOptions ( quality_level , debug ,& use_effective_range ,& custom_interpolator ) use m_psml_interp , only : nq , interpolator ! Parameter for interpolator's quality ! It might mean different things for different ! interpolators integer , intent ( in ), optional :: quality_level logical , intent ( in ), optional :: debug logical , intent ( in ), optional :: use_effective_range interface subroutine interp ( nquality , x , y , npts , r , val , debug ) integer , parameter :: dp = selected_real_kind ( 10 , 100 ) integer , intent ( in ) :: nquality ! Quality parameter real ( dp ), intent ( in ) :: x ( * ), y ( * ) integer , intent ( in ) :: npts ! Size of x, y arrays real ( dp ), intent ( in ) :: r real ( dp ), intent ( out ) :: val logical , intent ( in ) :: debug end subroutine interp end interface procedure ( interp ), optional :: custom_interpolator if ( present ( quality_level )) then nq = quality_level endif if ( present ( debug )) then global_debug = debug endif if ( present ( use_effective_range )) then global_use_effective_range = use_effective_range endif if ( present ( custom_interpolator )) then interpolator => custom_interpolator endif end subroutine ps_SetEvaluatorOptions ! ! ============================================================== ! subroutine ps_RootAttributes_Get ( ps , uuid , version , namespace , annotation ) type ( ps_t ), intent ( in ) :: ps character ( len =* ), intent ( out ), optional :: uuid character ( len =* ), intent ( out ), optional :: version character ( len =* ), intent ( out ), optional :: namespace type ( ps_annotation_t ), intent ( out ), optional :: annotation if ( present ( uuid )) then uuid = trim ( ps % uuid ) endif if ( present ( version )) then version = trim ( ps % version ) endif if ( present ( annotation )) then annotation = ps % annotation endif if ( present ( namespace )) then namespace = ps % namespace endif end subroutine ps_RootAttributes_Get ! ! ============================================================== ! function ps_Provenance_Depth ( ps ) result ( n ) type ( ps_t ), intent ( in ) :: ps integer :: n type ( provenance_t ), pointer :: p n = 0 p => ps % provenance do while ( associated ( p )) n = n + 1 p => p % next enddo end function ps_Provenance_Depth subroutine ps_Provenance_Get ( ps , level , creator , date ,& annotation , number_of_input_files ) type ( ps_t ), intent ( in ) :: ps integer , intent ( in ) :: level character ( len =* ), intent ( out ), optional :: creator character ( len =* ), intent ( out ), optional :: date type ( ps_annotation_t ), intent ( out ), optional :: annotation integer , intent ( out ), optional :: number_of_input_files type ( provenance_t ), pointer :: p logical :: found_level ! Here \"level\" means \"record_number\", with ! the oldest having a value of 1. found_level = . false . p => ps % provenance do while ( associated ( p )) if ( p % record_number == level ) then found_level = . true . exit endif p => p % next enddo if (. not . found_level ) call die ( \"Cannot reach provenance level\" ) if ( present ( creator )) then creator = p % creator endif if ( present ( date )) then date = p % date endif if ( present ( number_of_input_files )) then number_of_input_files = p % n_input_files endif if ( present ( annotation )) then annotation = p % annotation endif end subroutine ps_Provenance_Get ! To be implemented !subroutine ps_Provenance_InputFile(ps,level,file_index,& !                             filename,file_content) ! ! =================================================================== ! subroutine ps_PseudoAtomSpec_Get ( ps , atomic_symbol , atomic_label , & atomic_number , z_pseudo , pseudo_flavor ,& relativity , spin_dft , core_corrections , annotation ) type ( ps_t ), intent ( in ) :: ps character ( len =* ), intent ( out ), optional :: atomic_symbol character ( len =* ), intent ( out ), optional :: atomic_label real ( dp ), intent ( out ), optional :: atomic_number real ( dp ), intent ( out ), optional :: z_pseudo character ( len =* ), intent ( out ), optional :: pseudo_flavor character ( len =* ), intent ( out ), optional :: relativity logical , intent ( out ), optional :: spin_dft logical , intent ( out ), optional :: core_corrections type ( ps_annotation_t ), intent ( out ), optional :: annotation if ( present ( atomic_symbol )) then atomic_symbol = ps % header % atomic_label ( 1 : 2 ) endif if ( present ( atomic_label )) then atomic_label = trim ( ps % header % atomic_label ) endif if ( present ( atomic_number )) then atomic_number = ps % header % z endif if ( present ( z_pseudo )) then z_pseudo = ps % header % zpseudo endif if ( present ( pseudo_flavor )) then pseudo_flavor = trim ( ps % header % flavor ) endif if ( present ( relativity )) then relativity = trim ( ps % header % relativity ) endif if ( present ( spin_dft )) then spin_dft = ps % header % polarized endif if ( present ( core_corrections )) then core_corrections = ( ps % header % core_corrections == \"yes\" ) endif if ( present ( annotation )) then annotation = ps % header % annotation endif end subroutine ps_PseudoAtomSpec_Get ! ! =================================================================== ! subroutine ps_ValenceConfiguration_Get ( ps , nshells , charge , annotation ) type ( ps_t ), intent ( in ) :: ps integer , intent ( out ), optional :: nshells real ( dp ), intent ( out ), optional :: charge type ( ps_annotation_t ), intent ( out ), optional :: annotation if ( present ( nshells )) then nshells = ps % config_val % nshells endif if ( present ( charge )) then charge = ps % config_val % total_charge endif if ( present ( annotation )) then annotation = ps % config_val % annotation endif end subroutine ps_ValenceConfiguration_Get subroutine ps_ValenceShell_Get ( ps , i , n , l , occupation , occ_up , occ_down ) type ( ps_t ), intent ( in ) :: ps integer , intent ( in ) :: i integer , intent ( out ), optional :: n integer , intent ( out ), optional :: l real ( dp ), intent ( out ), optional :: occupation real ( dp ), intent ( out ), optional :: occ_up real ( dp ), intent ( out ), optional :: occ_down call check_index ( i , ps % config_val % nshells , \"valence shell\" ) if ( present ( n )) then n = ps % config_val % n ( i ) endif if ( present ( l )) then l = l_of_sym ( ps % config_val % l ( i ), \"valence shell\" ) endif if ( present ( occupation )) then occupation = ps % config_val % occ ( i ) endif if ( present ( occ_up )) then if ( ps % header % polarized ) then occ_up = ps % config_val % occ_up ( i ) else call die ( \"Cannot get per spin occupation\" ) endif endif if ( present ( occ_down )) then if ( ps % header % polarized ) then occ_down = ps % config_val % occ_down ( i ) else call die ( \"Cannot get per spin occupation\" ) endif endif end subroutine ps_ValenceShell_Get ! ! =================================================================== ! subroutine ps_ValenceCharge_Get ( ps , total_charge ,& is_unscreening_charge , rescaled_to_z_pseudo ,& annotation , func ) type ( ps_t ), intent ( in ) :: ps real ( dp ), intent ( out ), optional :: total_charge character ( len =* ), intent ( out ), optional :: is_unscreening_charge character ( len =* ), intent ( out ), optional :: rescaled_to_z_pseudo type ( ps_annotation_t ), intent ( out ), optional :: annotation type ( ps_radfunc_t ), intent ( out ), optional :: func if ( present ( total_charge )) then total_charge = ps % valence_charge % total_charge endif if ( present ( is_unscreening_charge )) then is_unscreening_charge = ps % valence_charge % is_unscreening_charge endif if ( present ( rescaled_to_z_pseudo )) then rescaled_to_z_pseudo = ps % valence_charge % rescaled_to_z_pseudo endif if ( present ( annotation )) then annotation = ps % valence_charge % annotation endif if ( present ( func )) then func = ps % valence_charge % rho_val endif end subroutine ps_ValenceCharge_Get ! !------------------------------------------------------- !>  Computes the value of the valence charge at r !> @param ps is a handle to the psml information !> @param r is the radius !> It returns the valence charge density integrated over !> solid angle, so that Q_val = int{ val*r*r } !> function ps_ValenceCharge_Value ( ps , r ) result ( val ) type ( ps_t ), intent ( in ) :: ps real ( dp ), intent ( in ) :: r real ( dp ) :: val val = ps_GetValue ( ps % valence_charge % rho_val , r ) end function ps_ValenceCharge_Value ! ! =================================================================== ! subroutine ps_CoreCharge_Get ( ps , rc , nderivs , annotation , func ) type ( ps_t ), intent ( in ) :: ps real ( dp ), intent ( out ), optional :: rc integer , intent ( out ), optional :: nderivs type ( ps_annotation_t ), intent ( out ), optional :: annotation type ( ps_radfunc_t ), intent ( out ), optional :: func if ( present ( rc )) then rc = ps % core_charge % rcore endif if ( present ( nderivs )) then nderivs = ps % core_charge % n_cont_derivs endif if ( present ( annotation )) then annotation = ps % core_charge % annotation endif if ( present ( func )) then func = ps % core_charge % rho_core endif end subroutine ps_CoreCharge_Get !>  Computes the value of the pseudo-core charge at r !> @param ps is a handle to the psml information !> @param r is the radius !> It returns the pseudo-core charge density integrated over !> solid angle, so that Q_core = int{ val*r*r } !> function ps_CoreCharge_Value ( ps , r ) result ( val ) type ( ps_t ), intent ( in ) :: ps real ( dp ), intent ( in ) :: r real ( dp ) :: val val = ps_GetValue ( ps % core_charge % rho_core , r ) end function ps_CoreCharge_Value ! ! =================================================================== ! subroutine ps_ExchangeCorrelation_Get ( ps , annotation , n_libxc_functionals ) type ( ps_t ), intent ( in ) :: ps type ( ps_annotation_t ), intent ( out ), optional :: annotation integer , intent ( out ), optional :: n_libxc_functionals if ( present ( annotation )) then annotation = ps % xc_info % annotation endif if ( present ( n_libxc_functionals )) then n_libxc_functionals = ps % xc_info % n_functs_libxc endif end subroutine ps_ExchangeCorrelation_Get subroutine ps_LibxcFunctional_Get ( ps , i , name , code , type , weight ) type ( ps_t ), intent ( in ) :: ps integer , intent ( in ) :: i character ( len =* ), intent ( out ), optional :: name integer , intent ( out ), optional :: code character ( len =* ), intent ( out ), optional :: type real ( dp ), intent ( out ), optional :: weight call check_index ( i , ps % xc_info % n_functs_libxc , \"libxc functional\" ) if ( present ( name )) then name = ps % xc_info % libxc_name ( i ) endif if ( present ( code )) then code = ps % xc_info % libxc_id ( i ) endif if ( present ( type )) then type = ps % xc_info % libxc_type ( i ) endif if ( present ( weight )) then weight = ps % xc_info % libxc_weight ( i ) endif end subroutine ps_LibxcFunctional_Get ! !================================================= !> Returns the annotation associated to a grid. !> If a radial function !> handle is given, the annotation for that !> radial function's grid is returned. Otherwise, !> the return value is the annotation for the global grid. !> If there is no appropriate annotation, an empty !> structure is returned. !> @param ps is a handle to the psml information !> @param radfunc is a handle to a radial function structure !> function ps_GridAnnotation ( ps , radfunc ) result ( annotation ) type ( ps_t ), intent ( in ) :: ps type ( ps_radfunc_t ), intent ( in ), optional :: radfunc type ( ps_annotation_t ) :: annotation type ( ps_annotation_t ), pointer :: annotation_p if ( present ( radfunc )) then ! We are told to get the grid annotation ! for a specific radial function if (. not . initialized ( radfunc % grid )) then call die ( \"get_annotation: Invalid radial function\" ) endif annotation_p => annotationGrid ( radfunc % grid ) ! If npts_data /= npts_grid, add a record to reflect this annotation = annotation_p else ! This is the global grid annotation if (. not . initialized ( ps % global_grid )) then annotation = EMPTY_ANNOTATION else annotation_p => annotationGrid ( ps % global_grid ) annotation = annotation_p endif endif end function ps_GridAnnotation ! !==================================================== ! Semilocal potentials ! subroutine ps_Potential_Get ( ps , i ,& l , j , n , rc , set , flavor , eref , annotation , func ) type ( ps_t ), intent ( in ), target :: ps integer , intent ( in ) :: i integer , intent ( out ), optional :: set integer , intent ( out ), optional :: l real ( dp ), intent ( out ), optional :: j integer , intent ( out ), optional :: n real ( dp ), intent ( out ), optional :: rc real ( dp ), intent ( out ), optional :: eref character ( len =* ), intent ( out ), optional :: flavor type ( ps_annotation_t ), intent ( out ), optional :: annotation type ( ps_radfunc_t ), intent ( out ), optional :: func type ( sl_table_t ), pointer :: q (:) q => ps % sl_table call check_index ( i , size ( q ), \"SL pot\" ) if ( present ( set )) then set = q ( i )% p % set endif if ( present ( l )) then l = l_of_sym ( q ( i )% p % l , \"SL pot\" ) endif if ( present ( n )) then n = q ( i )% p % n endif if ( present ( j )) then if ( q ( i )% p % j < 0.0 ) then j = - 1.0_dp ! Maybe optional status flag raised? else j = q ( i )% p % j endif endif if ( present ( rc )) then rc = q ( i )% p % rc endif if ( present ( eref )) then ! Will return a very large positive value if the attribute eref is not ! present in the file eref = q ( i )% p % eref endif if ( present ( flavor )) then flavor = q ( i )% p % flavor endif if ( present ( annotation )) then annotation = q ( i )% p % parent_group % annotation endif if ( present ( func )) then func = q ( i )% p % V endif end subroutine ps_Potential_Get ! subroutine ps_SemilocalPotentials_Filter ( ps ,& indexes_in , & l , j , n , set , & indexes , number ) type ( ps_t ), intent ( in ), target :: ps integer , intent ( in ), optional :: indexes_in (:) integer , intent ( in ), optional :: set integer , intent ( in ), optional :: l real ( dp ), intent ( in ), optional :: j integer , intent ( in ), optional :: n integer , intent ( out ), allocatable , optional :: indexes (:) integer , intent ( out ), optional :: number integer :: i , ii , num integer , allocatable :: idx (:), range (:) type ( sl_table_t ), pointer :: q (:) q => ps % sl_table ! !  If we specify an initial domain, we !  only loop over it for the rest of !  the operations ! if ( present ( indexes_in )) then allocate ( range ( size ( indexes_in ))) range (:) = indexes_in (:) else allocate ( range ( size ( q ))) do ii = 1 , size ( q ) range ( ii ) = ii enddo endif num = 0 do ii = 1 , size ( range ) i = range ( ii ) if ( present ( set )) then if ( iand ( q ( i )% p % set , set ) == 0 ) cycle endif if ( present ( l )) then if ( l_of_sym ( q ( i )% p % l , \"pot\" ) /= l ) cycle endif if ( present ( j )) then ! A negative p%j signals the absence of j... if ( q ( i )% p % j < 0.0 ) cycle ! Perform integer comparison if ( nint ( 10 * q ( i )% p % j ) /= nint ( 10 * j )) cycle endif if ( present ( n )) then if ( q ( i )% p % n /= n ) cycle endif num = num + 1 enddo allocate ( idx ( num )) num = 0 do ii = 1 , size ( range ) i = range ( ii ) if ( present ( set )) then if ( iand ( q ( i )% p % set , set ) == 0 ) cycle endif if ( present ( j )) then ! A negative p%j signals the absence of j... if ( q ( i )% p % j < 0.0 ) cycle ! Perform integer comparison if ( nint ( 10 * q ( i )% p % j ) /= nint ( 10 * j )) cycle endif if ( present ( l )) then if ( l_of_sym ( q ( i )% p % l , \"pot\" ) /= l ) cycle endif if ( present ( n )) then if ( q ( i )% p % n /= n ) cycle endif num = num + 1 idx ( num ) = i enddo if ( present ( indexes )) then if ( allocated ( indexes )) deallocate ( indexes ) allocate ( indexes ( num )) indexes (:) = idx (:) endif if ( present ( number )) then number = num endif deallocate ( idx , range ) end subroutine ps_SemilocalPotentials_Filter ! function ps_GetValue ( f , r ) result ( val ) type ( ps_radfunc_t ), intent ( in ) :: f real ( dp ), intent ( in ) :: r real ( dp ) :: val if ( r > max_range ( f )) then if ( f % has_coulomb_tail ) then val = f % tail_factor / r else val = 0.0_dp endif else val = eval_radfunc ( f , r , debug = global_debug ) endif end function ps_GetValue !> Evaluator by storage index function ps_Potential_Value ( ps , i , r ) result ( val ) type ( ps_t ), intent ( in ) :: ps integer , intent ( in ) :: i real ( dp ), intent ( in ) :: r real ( dp ) :: val call check_index ( i , size ( ps % sl_table ), \"SL pot\" ) val = ps_GetValue ( ps % sl_table ( i )% p % V , r ) end function ps_Potential_Value subroutine ps_GetRawData ( f , raw_r , raw_data ) type ( ps_radfunc_t ), intent ( in ) :: f real ( dp ), allocatable , intent ( out ) :: raw_r (:), raw_data (:) integer npts_data real ( dp ), pointer :: a (:) ! Cover the case in which the data set uses only ! a first section of the grid npts_data = size ( f % data ) allocate ( raw_r ( npts_data ), raw_data ( npts_data )) a => valGrid ( f % grid ) raw_r ( 1 : npts_data ) = a ( 1 : npts_data ) raw_data (:) = f % data (:) end subroutine ps_GetRawData ! !==================================================== ! PseudoWavefunctions ! ! Basic accessors ! subroutine ps_PseudoWaveFunctions_Filter ( ps ,& indexes_in ,& l , j , n , set , & indexes , number ) type ( ps_t ), intent ( in ), target :: ps integer , intent ( in ), optional :: indexes_in (:) integer , intent ( in ), optional :: set integer , intent ( in ), optional :: l real ( dp ), intent ( in ), optional :: j integer , intent ( in ), optional :: n integer , intent ( out ), allocatable , optional :: indexes (:) integer , intent ( out ), optional :: number integer :: i , ii , num integer , allocatable :: idx (:), range (:) type ( wf_table_t ), pointer :: q (:) q => ps % wf_table ! !  If we specify an initial domain, we !  only loop over it for the rest of !  the operations ! if ( present ( indexes_in )) then allocate ( range ( size ( indexes_in ))) range (:) = indexes_in (:) else allocate ( range ( size ( q ))) do ii = 1 , size ( q ) range ( ii ) = ii enddo endif num = 0 do ii = 1 , size ( range ) i = range ( ii ) if ( present ( set )) then if ( iand ( q ( i )% p % set , set ) == 0 ) cycle endif if ( present ( l )) then if ( l_of_sym ( q ( i )% p % l , \"wf\" ) /= l ) cycle endif if ( present ( j )) then ! A negative p%j signals the absence of j... if ( q ( i )% p % j < 0.0 ) cycle ! Perform integer comparison if ( nint ( 10 * q ( i )% p % j ) /= nint ( 10 * j )) cycle endif if ( present ( n )) then if ( q ( i )% p % n /= n ) cycle endif num = num + 1 enddo allocate ( idx ( num )) num = 0 do ii = 1 , size ( range ) i = range ( ii ) if ( present ( set )) then if ( iand ( q ( i )% p % set , set ) == 0 ) cycle endif if ( present ( j )) then ! A negative p%j signals the absence of j... if ( q ( i )% p % j < 0.0 ) cycle ! Perform integer comparison if ( nint ( 10 * q ( i )% p % j ) /= nint ( 10 * j )) cycle endif if ( present ( l )) then if ( l_of_sym ( q ( i )% p % l , \"wf\" ) /= l ) cycle endif if ( present ( n )) then if ( q ( i )% p % n /= n ) cycle endif num = num + 1 idx ( num ) = i enddo if ( present ( indexes )) then if ( allocated ( indexes )) deallocate ( indexes ) allocate ( indexes ( num )) indexes (:) = idx (:) endif if ( present ( number )) then number = num endif deallocate ( idx , range ) end subroutine ps_PseudoWaveFunctions_Filter subroutine ps_PseudoWf_Get ( ps , i ,& l , j , n , set , energy_level , annotation , func ) type ( ps_t ), intent ( in ), target :: ps integer , intent ( in ) :: i integer , intent ( out ), optional :: set integer , intent ( out ), optional :: l real ( dp ), intent ( out ), optional :: j integer , intent ( out ), optional :: n real ( dp ), intent ( out ), optional :: energy_level type ( ps_annotation_t ), intent ( out ), optional :: annotation type ( ps_radfunc_t ), intent ( out ), optional :: func type ( wf_table_t ), pointer :: q (:) q => ps % wf_table call check_index ( i , size ( q ), \"wf\" ) if ( present ( set )) then set = q ( i )% p % set endif if ( present ( l )) then l = l_of_sym ( q ( i )% p % l , \"wf\" ) endif if ( present ( n )) then n = q ( i )% p % n endif if ( present ( j )) then if ( q ( i )% p % j < 0.0 ) then j = - 1.0_dp ! Maybe optional status flag raised? else j = q ( i )% p % j endif endif if ( present ( energy_level )) then ! Will return a very large positive value if the attribute energy_level is not ! present in the file energy_level = q ( i )% p % energy_level endif if ( present ( annotation )) then annotation = q ( i )% p % parent_group % annotation endif if ( present ( func )) then func = q ( i )% p % Phi endif end subroutine ps_PseudoWf_Get ! function ps_PseudoWf_Value ( ps , i , r ) result ( val ) type ( ps_t ), intent ( in ) :: ps integer , intent ( in ) :: i real ( dp ), intent ( in ) :: r real ( dp ) :: val call check_index ( i , size ( ps % wf_table ), \"Wf\" ) val = ps_GetValue ( ps % wf_table ( i )% p % Phi , r ) end function ps_PseudoWf_Value ! !==================================================== ! Pseudopotential operator (Vlocal, LocalCharge, projectors) ! ! Basic accessors ! function ps_HasProjectors ( ps ) result ( p ) type ( ps_t ), intent ( in ) :: ps logical :: p ! p = ( size ( ps % nl_table ) > 0 ) end function ps_HasProjectors function ps_HasLocalPotential ( ps ) result ( p ) type ( ps_t ), intent ( in ) :: ps logical :: p ! p = ( initialized ( ps % local % Vlocal % grid )) end function ps_HasLocalPotential subroutine ps_LocalPotential_Get ( ps , type , annotation , func ,& has_local_charge , func_local_charge ) type ( ps_t ), intent ( in ) :: ps character ( len =* ), intent ( out ), optional :: type type ( ps_annotation_t ), intent ( out ), optional :: annotation type ( ps_radfunc_t ), intent ( out ), optional :: func logical , intent ( out ), optional :: has_local_charge type ( ps_radfunc_t ), intent ( out ), optional :: func_local_charge if ( present ( type )) then type = ps % local % vlocal_type endif if ( present ( annotation )) then annotation = ps % local % annotation endif if ( present ( func )) then func = ps % local % vlocal endif if ( present ( has_local_charge )) then has_local_charge = ( initialized ( ps % local % chlocal % grid )) endif if ( present ( func_local_charge )) then ! No checks func_local_charge = ps % local % chlocal endif end subroutine ps_LocalPotential_Get ! function ps_LocalPotential_Value ( ps , r ) result ( val ) type ( ps_t ), intent ( in ) :: ps real ( dp ), intent ( in ) :: r real ( dp ) :: val val = ps_GetValue ( ps % local % vlocal , r ) end function ps_LocalPotential_Value ! ! ========================================================== ! function ps_HasPSOperator ( ps ) result ( psop ) type ( ps_t ), intent ( in ) :: ps logical :: psop ! psop = ( ps_HasProjectors ( ps ) . and . ps_HasLocalPotential ( ps )) end function ps_HasPSOperator ! function ps_HasSemilocalPotentials ( ps ) result ( p ) type ( ps_t ), intent ( in ) :: ps logical :: p ! p = ( associated ( ps % semilocal )) end function ps_HasSemilocalPotentials !================================ Projectors subroutine ps_NonlocalProjectors_Filter ( ps ,& indexes_in ,& l , j , seq , set , & indexes , number ) type ( ps_t ), intent ( in ), target :: ps integer , intent ( in ), optional :: indexes_in (:) integer , intent ( in ), optional :: set integer , intent ( in ), optional :: l real ( dp ), intent ( in ), optional :: j integer , intent ( in ), optional :: seq integer , intent ( out ), allocatable , optional :: indexes (:) integer , intent ( out ), optional :: number integer :: i , ii , num integer , allocatable :: idx (:), range (:) type ( nl_table_t ), pointer :: q (:) q => ps % nl_table ! !  If we specify an initial domain, we !  only loop over it for the rest of !  the operations ! if ( present ( indexes_in )) then allocate ( range ( size ( indexes_in ))) range (:) = indexes_in (:) else allocate ( range ( size ( q ))) do ii = 1 , size ( q ) range ( ii ) = ii enddo endif num = 0 do ii = 1 , size ( range ) i = range ( ii ) if ( present ( set )) then if ( iand ( q ( i )% p % set , set ) == 0 ) cycle endif if ( present ( l )) then if ( l_of_sym ( q ( i )% p % l , \"pot\" ) /= l ) cycle endif if ( present ( j )) then ! A negative p%j signals the absence of j... if ( q ( i )% p % j < 0.0 ) cycle ! Perform integer comparison if ( nint ( 10 * q ( i )% p % j ) /= nint ( 10 * j )) cycle endif if ( present ( seq )) then if ( q ( i )% p % seq /= seq ) cycle endif num = num + 1 enddo allocate ( idx ( num )) num = 0 do ii = 1 , size ( range ) i = range ( ii ) if ( present ( set )) then if ( iand ( q ( i )% p % set , set ) == 0 ) cycle endif if ( present ( j )) then ! A negative p%j signals the absence of j... if ( q ( i )% p % j < 0.0 ) cycle ! Perform integer comparison if ( nint ( 10 * q ( i )% p % j ) /= nint ( 10 * j )) cycle endif if ( present ( l )) then if ( l_of_sym ( q ( i )% p % l , \"pot\" ) /= l ) cycle endif if ( present ( seq )) then if ( q ( i )% p % seq /= seq ) cycle endif num = num + 1 idx ( num ) = i enddo if ( present ( indexes )) then if ( allocated ( indexes )) deallocate ( indexes ) allocate ( indexes ( num )) indexes (:) = idx (:) endif if ( present ( number )) then number = num endif deallocate ( idx , range ) end subroutine ps_NonlocalProjectors_Filter subroutine ps_Projector_Get ( ps , i ,& l , j , seq , set , ekb , eref , type , annotation , func ) type ( ps_t ), intent ( in ), target :: ps integer , intent ( in ) :: i integer , intent ( out ), optional :: set integer , intent ( out ), optional :: l real ( dp ), intent ( out ), optional :: j integer , intent ( out ), optional :: seq real ( dp ), intent ( out ), optional :: ekb real ( dp ), intent ( out ), optional :: eref character ( len =* ), intent ( out ), optional :: type type ( ps_annotation_t ), intent ( out ), optional :: annotation type ( ps_radfunc_t ), intent ( out ), optional :: func type ( nl_table_t ), pointer :: q (:) q => ps % nl_table call check_index ( i , size ( q ), \"NL pot\" ) if ( present ( set )) then set = q ( i )% p % set endif if ( present ( l )) then l = l_of_sym ( q ( i )% p % l , \"NL pot\" ) endif if ( present ( seq )) then seq = q ( i )% p % seq endif if ( present ( j )) then if ( q ( i )% p % j < 0.0 ) then j = - 1.0_dp ! Maybe optional status flag raised? else j = q ( i )% p % j endif endif if ( present ( ekb )) then ekb = q ( i )% p % ekb endif if ( present ( eref )) then ! Will return a very large positive value if the attribute eref is not ! present in the file eref = q ( i )% p % eref endif if ( present ( type )) then type = q ( i )% p % type endif if ( present ( annotation )) then annotation = q ( i )% p % parent_group % annotation endif if ( present ( func )) then func = q ( i )% p % proj endif end subroutine ps_Projector_Get function ps_Projector_Value ( ps , i , r ) result ( val ) !+ display: private type ( ps_t ), intent ( in ) :: ps integer , intent ( in ) :: i real ( dp ), intent ( in ) :: r real ( dp ) :: val call check_index ( i , size ( ps % nl_table ), \"proj\" ) val = ps_GetValue ( ps % nl_table ( i )% p % proj , r ) end function ps_Projector_Value !==================================================== ! Low-level routines ! ! subroutine check_index ( i , n , str ) integer , intent ( in ) :: i , n character ( len =* ), intent ( in ) :: str call assert ( ( i <= n ), \"Index overflow in \" // trim ( str )) call assert ( ( i > 0 ), \"Non-positive index in \" // trim ( str )) end subroutine check_index ! function l_of_sym ( str , name ) result ( l ) character ( len =* ), intent ( in ) :: str , name integer :: l ! ! This routine will disappear once we store ! l as integer in the data structure ! do l = 0 , 4 if ( str == sym ( l )) RETURN enddo call die ( \"Wrong l symbol in \" // trim ( name )) end function l_of_sym !>  Returns the maximum radius in a radfunc's data function max_range ( f ) result ( range ) type ( radfunc_t ), intent ( in ) :: f real ( dp ) :: range real ( dp ), pointer :: a (:) integer :: npts_data a => valGrid ( f % grid ) ! if ( global_use_effective_range ) then ! We use the effective end_of_range range = f % rcut_eff else ! Use the nominal range ! This covers the case in which the data set uses only ! a first section of the grid npts_data = size ( f % data ) range = a ( npts_data ) endif end function max_range !---------- function eval_radfunc ( f , r , debug ) result ( val ) use m_psml_interp , only : interpolator , nq type ( radfunc_t ), intent ( in ) :: f real ( dp ), intent ( in ) :: r logical , intent ( in ) :: debug real ( dp ) :: val real ( dp ), pointer :: x (:) => null (), y (:) => null () integer :: npts x => valGrid ( f % grid ) y => f % data (:) !Note size(y) to cover the case in which the data set uses only ! a first section of the grid npts = size ( y ) call interpolator ( nq , x , y , npts , r , val , debug ) end function eval_radfunc ! !------ ! subroutine assert ( cond , message ) logical , intent ( in ) :: cond character ( len =* ) message if (. not . cond ) call die ( message ) end subroutine assert end module m_psml_api","tags":"","loc":"sourcefile/m_psml_api.f90.html"},{"title":"m_psml_dump.F90 – libPSML","text":"Contents Modules m_psml_dump Source Code m_psml_dump.F90 Source Code !> Functions to handle PSML pseudopotential format structures !! !! (Dumpers) !> @author Alberto Garcia ! #if defined HAVE_CONFIG_H #include \"config.h\" #endif module m_psml_dump use m_psml_core ! For basic structures use assoc_list , only : ps_annotation_t => assoc_list_t !use assoc_list, only: EMPTY_ANNOTATION => EMPTY_ASSOC_LIST use class_grid , Grid_t => Grid use external_interfaces , only : die => psml_die implicit none integer , parameter :: dp = selected_real_kind ( 14 ) logical :: global_debug = . false . character ( len = 1 ), dimension ( 0 : 4 ) :: sym = ( / \"s\" , \"p\" , \"d\" , \"f\" , \"g\" / ) public :: ps_DumpToPSMLFile private CONTAINS !=============================================== subroutine ps_DumpToPSMLFile ( ps , fname , indent ) use xmlf90_wxml type ( ps_t ), intent ( in ) :: ps character ( len =* ), intent ( in ) :: fname logical , intent ( in ), optional :: indent type ( xmlf_t ) :: xf call xml_OpenFile ( trim ( fname ), xf , indent ) call xml_AddXMLDeclaration ( xf , \"UTF-8\" ) call xml_NewElement ( xf , \"psml\" ) call my_add_attribute ( xf , \"version\" , trim ( ps % version )) call my_add_attribute ( xf , \"energy_unit\" , trim ( ps % energy_unit )) call my_add_attribute ( xf , \"length_unit\" , trim ( ps % length_unit )) call my_add_attribute ( xf , \"uuid\" , ps % uuid ) call my_add_attribute ( xf , \"xmlns\" , ps % namespace ) ! No top-level annotations in V1.1 !      call dump_annotation(xf,ps%annotation) call dump_provenance ( xf , ps % provenance ) call dump_pseudo_atom_spec ( xf , ps ) if ( initialized ( ps % global_grid )) then call dump_grid ( xf , ps % global_grid ) endif call dump_valence_charge ( xf , ps % valence_charge , ps % global_grid ) if ( trim ( ps % header % core_corrections ) == \"yes\" ) then call dump_core_charge ( xf , ps % core_charge , ps % global_grid ) endif call dump_semilocal_potentials ( xf , ps ) call dump_local_potential ( xf , ps ) call dump_nonlocal_projectors ( xf , ps ) call dump_pseudo_wavefunctions ( xf , ps ) call xml_EndElement ( xf , \"psml\" ) call xml_Close ( xf ) end subroutine ps_DumpToPSMLFile subroutine dump_provenance ( xf , p ) use xmlf90_wxml type ( xmlf_t ), intent ( inout ) :: xf type ( provenance_t ), pointer :: p integer :: depth type ( provenance_t ), pointer :: q depth = 0 q => p do while ( associated ( q )) depth = depth + 1 q => q % next enddo do while ( associated ( p )) call xml_NewElement ( xf , \"provenance\" ) call my_add_attribute ( xf , \"record-number\" , str ( p % record_number )) call my_add_attribute ( xf , \"creator\" , trim ( p % creator )) call my_add_attribute ( xf , \"date\" , trim ( p % date )) call dump_annotation ( xf , p % annotation ) if ( len ( p % input_file % buffer ) > 0 ) then call xml_NewElement ( xf , \"input-file\" ) call my_add_attribute ( xf , \"name\" , trim ( p % input_file % name )) call xml_AddCDataSection ( xf , p % input_file % buffer , & line_feed = . true .) call xml_EndElement ( xf , \"input-file\" ) endif call xml_EndElement ( xf , \"provenance\" ) p => p % next end do end subroutine dump_provenance subroutine dump_xc_info ( xf , p ) use xmlf90_wxml type ( xmlf_t ), intent ( inout ) :: xf type ( xc_t ), intent ( in ) :: p integer :: i call xml_NewElement ( xf , \"exchange-correlation\" ) call dump_annotation ( xf , p % annotation ) call xml_NewElement ( xf , \"libxc-info\" ) call my_add_attribute ( xf , \"number-of-functionals\" , str ( p % n_functs_libxc )) do i = 1 , p % n_functs_libxc call xml_NewElement ( xf , \"functional\" ) call my_add_attribute ( xf , \"name\" , trim ( p % libxc_name ( i ))) if ( trim ( p % libxc_type ( i )) /= \"UNKNOWN\" ) then call my_add_attribute ( xf , \"type\" , trim ( p % libxc_type ( i ))) endif call my_add_attribute ( xf , \"id\" , str ( p % libxc_id ( i ))) if ( p % libxc_weight ( i ) /= 1.0_dp ) then call my_add_attribute ( xf , \"weight\" , str ( p % libxc_weight ( i ))) endif call xml_EndElement ( xf , \"functional\" ) enddo call xml_EndElement ( xf , \"libxc-info\" ) call xml_EndElement ( xf , \"exchange-correlation\" ) end subroutine dump_xc_info subroutine dump_config_val ( xf , p ) use xmlf90_wxml type ( xmlf_t ), intent ( inout ) :: xf type ( config_val_t ), intent ( in ) :: p integer :: i call xml_NewElement ( xf , \"valence-configuration\" ) call my_add_attribute ( xf , \"total-valence-charge\" , str ( p % total_charge )) call dump_annotation ( xf , p % annotation ) do i = 1 , p % nshells call xml_NewElement ( xf , \"shell\" ) call my_add_attribute ( xf , \"n\" , str ( p % n ( i ))) call my_add_attribute ( xf , \"l\" , p % l ( i )) call my_add_attribute ( xf , \"occupation\" , str ( p % occ ( i ))) if (( p % occ_up ( i ) + p % occ_down ( i )) /= 0.0_dp ) then call my_add_attribute ( xf , \"occupation-down\" , str ( p % occ_down ( i ))) call my_add_attribute ( xf , \"occupation-up\" , str ( p % occ_up ( i ))) endif call xml_EndElement ( xf , \"shell\" ) enddo call xml_EndElement ( xf , \"valence-configuration\" ) end subroutine dump_config_val subroutine dump_pseudo_atom_spec ( xf , ps ) use xmlf90_wxml type ( xmlf_t ), intent ( inout ) :: xf type ( ps_t ), intent ( in ), target :: ps type ( header_t ), pointer :: h h => ps % header call xml_NewElement ( xf , \"pseudo-atom-spec\" ) call my_add_attribute ( xf , \"atomic-label\" , trim ( h % atomic_label )) call my_add_attribute ( xf , \"atomic-number\" , str ( h % z )) call my_add_attribute ( xf , \"z-pseudo\" , str ( h % zpseudo )) call my_add_attribute ( xf , \"flavor\" , trim ( h % flavor )) call my_add_attribute ( xf , \"relativity\" , trim ( h % relativity )) if ( h % polarized ) then call my_add_attribute ( xf , \"spin-dft\" , \"yes\" ) else call my_add_attribute ( xf , \"spin-dft\" , \"no\" ) endif call my_add_attribute ( xf , \"core-corrections\" , trim ( h % core_corrections )) call dump_annotation ( xf , h % annotation ) call dump_xc_info ( xf , ps % xc_info ) call dump_config_val ( xf , ps % config_val ) call xml_EndElement ( xf , \"pseudo-atom-spec\" ) end subroutine dump_pseudo_atom_spec subroutine dump_radfunc ( xf , rf , parent_grid ) use xmlf90_wxml type ( xmlf_t ), intent ( inout ) :: xf type ( radfunc_t ), intent ( in ) :: rf type ( Grid_t ) :: parent_grid ! Only one level for now if (. not . initialized ( rf % grid )) return call xml_NewElement ( xf , \"radfunc\" ) if ( same ( rf % grid , parent_grid )) then ! do nothing else call dump_grid ( xf , rf % grid ) endif call xml_NewElement ( xf , \"data\" ) ! Cover the case in which the data uses only an ! initial section of the grid if ( size ( rf % data ) < sizeGrid ( rf % grid )) then call my_add_attribute ( xf , \"npts\" , str ( size ( rf % data ))) endif call xml_AddArray ( xf , rf % data (:)) call xml_EndElement ( xf , \"data\" ) call xml_EndElement ( xf , \"radfunc\" ) end subroutine dump_radfunc subroutine dump_valence_charge ( xf , val , parent_grid ) use xmlf90_wxml type ( xmlf_t ), intent ( inout ) :: xf type ( valence_charge_t ), intent ( in ) :: val type ( Grid_t ) :: parent_grid call xml_NewElement ( xf , \"valence-charge\" ) call my_add_attribute ( xf , \"total-charge\" , str ( val % total_charge )) call dump_annotation ( xf , val % annotation ) call dump_radfunc ( xf , val % rho_val , parent_grid ) call xml_EndElement ( xf , \"valence-charge\" ) end subroutine dump_valence_charge subroutine dump_core_charge ( xf , core , parent_grid ) use xmlf90_wxml type ( xmlf_t ), intent ( inout ) :: xf type ( core_charge_t ), intent ( in ) :: core type ( Grid_t ) :: parent_grid call xml_NewElement ( xf , \"pseudocore-charge\" ) if ( core % rcore >= 0.0_dp ) then call my_add_attribute ( xf , \"matching-radius\" , str ( core % rcore )) endif if ( core % n_cont_derivs >= 0 ) then call my_add_attribute ( xf , \"number-of-continuous-derivatives\" , str ( core % n_cont_derivs )) endif call dump_annotation ( xf , core % annotation ) call dump_radfunc ( xf , core % rho_core , parent_grid ) call xml_EndElement ( xf , \"pseudocore-charge\" ) end subroutine dump_core_charge ! subroutine dump_semilocal_potentials ( xf , ps ) use xmlf90_wxml type ( xmlf_t ), intent ( inout ) :: xf type ( ps_t ), intent ( in ), target :: ps type ( semilocal_t ), pointer :: slp type ( slps_t ), pointer :: slvp type ( Grid_t ) :: parent_grid integer :: i , j , set slp => ps % semilocal do while ( associated ( slp )) set = slp % set call xml_NewElement ( xf , \"semilocal-potentials\" ) if ( set /= SET_NULL ) then ! Group set was specified call my_add_attribute ( xf , \"set\" , str_of_set ( set )) else call die ( \"Set not specified in SemiLocalPotentials block\" ) endif call dump_annotation ( xf , slp % annotation ) if ( initialized ( slp % grid )) then parent_grid = slp % grid call dump_grid ( xf , slp % grid ) else parent_grid = ps % global_grid endif slvp => slp % pot do while ( associated ( slvp )) call xml_NewElement ( xf , \"slps\" ) call my_add_attribute ( xf , \"n\" , str ( slvp % n )) call my_add_attribute ( xf , \"l\" , slvp % l ) call my_add_attribute ( xf , \"rc\" , str ( slvp % rc )) ! If eref has a physical value, output it if ( slvp % eref < 0.1 * huge ( 1.0_dp )) then call my_add_attribute ( xf , \"eref\" , str ( slvp % eref )) endif call my_add_attribute ( xf , \"flavor\" , slvp % flavor ) if ( set == SET_LJ ) then call my_add_attribute ( xf , \"j\" , str ( slvp % j , format = \"(f3.1)\" )) endif call dump_radfunc ( xf , slvp % V , parent_grid ) call xml_EndElement ( xf , \"slps\" ) slvp => slvp % next enddo call xml_EndElement ( xf , \"semilocal-potentials\" ) slp => slp % next enddo call delete ( parent_grid ) end subroutine dump_semilocal_potentials subroutine dump_local_potential ( xf , ps ) use xmlf90_wxml type ( xmlf_t ), intent ( inout ) :: xf type ( ps_t ), intent ( in ), target :: ps type ( local_t ), pointer :: lop type ( Grid_t ) :: parent_grid logical :: has_vlocal , has_local_charge lop => ps % local has_vlocal = associated ( lop % Vlocal % data ) has_local_charge = associated ( lop % Chlocal % data ) if ( has_vlocal ) then call xml_NewElement ( xf , \"local-potential\" ) call my_add_attribute ( xf , \"type\" , lop % vlocal_type ) call dump_annotation ( xf , lop % annotation ) ! No processing of grids here if ( initialized ( lop % grid )) then parent_grid = lop % grid call dump_grid ( xf , lop % grid ) else parent_grid = ps % global_grid endif call dump_radfunc ( xf , lop % Vlocal , parent_grid ) if ( has_local_charge ) then call xml_NewElement ( xf , \"local-charge\" ) call dump_radfunc ( xf , lop % chlocal , parent_grid ) call xml_EndElement ( xf , \"local-charge\" ) endif call xml_EndElement ( xf , \"local-potential\" ) call delete ( parent_grid ) endif end subroutine dump_local_potential !---------------------------------------------------------- subroutine dump_nonlocal_projectors ( xf , ps ) use xmlf90_wxml type ( xmlf_t ), intent ( inout ) :: xf type ( ps_t ), intent ( in ), target :: ps type ( nonlocal_t ), pointer :: nlp type ( nlpj_t ), pointer :: nlpp type ( Grid_t ) :: parent_grid integer :: set nlp => ps % nonlocal do while ( associated ( nlp )) set = nlp % set call xml_NewElement ( xf , \"nonlocal-projectors\" ) if ( set /= SET_NULL ) then ! Group set was specified call my_add_attribute ( xf , \"set\" , str_of_set ( set )) else call die ( \"Set not specified in NonLocalProjectors block\" ) endif call dump_annotation ( xf , nlp % annotation ) if ( initialized ( nlp % grid )) then parent_grid = nlp % grid call dump_grid ( xf , nlp % grid ) else parent_grid = ps % global_grid endif nlpp => nlp % proj do while ( associated ( nlpp )) call xml_NewElement ( xf , \"proj\" ) call my_add_attribute ( xf , \"l\" , nlpp % l ) if ( set == SET_LJ ) then call my_add_attribute ( xf , \"j\" , str ( nlpp % j , format = \"(f3.1)\" )) endif call my_add_attribute ( xf , \"seq\" , str ( nlpp % seq )) call my_add_attribute ( xf , \"ekb\" , str ( nlpp % ekb )) ! If eref has a physical value, output it if ( nlpp % eref < 0.1 * huge ( 1.0_dp )) then call my_add_attribute ( xf , \"eref\" , str ( nlpp % eref )) endif call my_add_attribute ( xf , \"type\" , nlpp % type ) call dump_radfunc ( xf , nlpp % proj , parent_grid ) call xml_EndElement ( xf , \"proj\" ) nlpp => nlpp % next enddo call xml_EndElement ( xf , \"nonlocal-projectors\" ) nlp => nlp % next enddo call delete ( parent_grid ) end subroutine dump_nonlocal_projectors !---------------------------------------------------------- subroutine dump_pseudo_wavefunctions ( xf , ps ) use xmlf90_wxml type ( xmlf_t ), intent ( inout ) :: xf type ( ps_t ), intent ( in ), target :: ps type ( wfns_t ), pointer :: wfp type ( wf_t ), pointer :: wfpp type ( Grid_t ) :: parent_grid integer :: set wfp => ps % wavefunctions do while ( associated ( wfp )) set = wfp % set call xml_NewElement ( xf , \"pseudo-wave-functions\" ) if ( set /= SET_NULL ) then ! Group set was specified call my_add_attribute ( xf , \"set\" , str_of_set ( set )) else call die ( \"Set not specified in Wavefunctions block\" ) endif !     if (wfp%type /= \"\") then !        call my_add_attribute(xf,\"type\",wfp%type) !     endif call dump_annotation ( xf , wfp % annotation ) if ( initialized ( wfp % grid )) then parent_grid = wfp % grid call dump_grid ( xf , wfp % grid ) else parent_grid = ps % global_grid endif wfpp => wfp % wf do while ( associated ( wfpp )) call xml_NewElement ( xf , \"pswf\" ) call my_add_attribute ( xf , \"n\" , str ( wfpp % n )) call my_add_attribute ( xf , \"l\" , wfpp % l ) if ( set == SET_LJ ) then call my_add_attribute ( xf , \"j\" , str ( wfpp % j , format = \"(f3.1)\" )) endif ! If energy_level has a physical value, output it if ( wfpp % energy_level < 0.1 * huge ( 1.0_dp )) then call my_add_attribute ( xf , \"energy_level\" , str ( wfpp % energy_level )) endif call dump_radfunc ( xf , wfpp % Phi , parent_grid ) call xml_EndElement ( xf , \"pswf\" ) wfpp => wfpp % next enddo call xml_EndElement ( xf , \"pseudo-wave-functions\" ) wfp => wfp % next enddo call delete ( parent_grid ) end subroutine dump_pseudo_wavefunctions subroutine dump_grid ( xf , agrid ) use xmlf90_wxml type ( xmlf_t ), intent ( inout ) :: xf type ( Grid_t ), intent ( in ) :: agrid if (. not . initialized ( agrid )) return call xml_NewElement ( xf , \"grid\" ) call my_add_attribute ( xf , \"npts\" , str ( sizeGrid ( agrid ))) call dump_annotation ( xf , annotationGrid ( agrid )) call xml_NewElement ( xf , \"grid-data\" ) call xml_AddArray ( xf , valGrid ( agrid )) call xml_EndElement ( xf , \"grid-data\" ) call xml_EndElement ( xf , \"grid\" ) end subroutine dump_grid subroutine dump_annotation ( xf , annotation ) use xmlf90_wxml use assoc_list , only : ps_annotation_t => assoc_list_t use assoc_list , only : nitems_annotation => assoc_list_nitems use assoc_list , only : get_annotation_key => assoc_list_get_key use assoc_list , only : get_annotation_value => assoc_list_get_value type ( xmlf_t ), intent ( inout ) :: xf type ( ps_annotation_t ), intent ( in ) :: annotation integer :: n_items , i , stat character ( len = 256 ) :: key , val n_items = nitems_annotation ( annotation ) if ( n_items > 0 ) then call xml_NewElement ( xf , \"annotation\" ) do i = 1 , n_items call get_annotation_key ( annotation , i , key , stat ) call get_annotation_value ( annotation , i , val , stat ) call my_add_attribute ( xf , trim ( key ), trim ( val )) enddo call xml_EndElement ( xf , \"annotation\" ) endif end subroutine dump_annotation subroutine my_add_attribute ( xf , name , value ) use xmlf90_wxml type ( xmlf_t ), intent ( inout ) :: xf character ( len =* ), intent ( in ) :: name character ( len =* ), intent ( in ) :: value call xml_AddAttribute ( xf , name , trim ( value )) end subroutine my_add_attribute end module m_psml_dump","tags":"","loc":"sourcefile/m_psml_dump.f90.html"},{"title":"class_grid.F90 – libPSML","text":"Contents Modules class_Grid Source Code class_grid.F90 Source Code #if defined HAVE_CONFIG_H #include \"config.h\" #endif module class_Grid use assoc_list , only : ps_annotation_t => assoc_list_t use assoc_list , only : ps_clean_annotation => assoc_list_reset implicit none character ( len =* ), parameter :: mod_name = \"Grid\" integer , parameter :: dp = selected_real_kind ( 10 , 100 ) ! type Grid_ integer :: refCount = 0 character ( len = 36 ) :: id = \"null_id\" !---------------------- character ( len = 256 ) :: name = \"null Grid\" integer :: npts = 0 real ( dp ), pointer :: grid_data (:) => null () type ( ps_annotation_t ) :: annotation end type Grid_ type Grid type ( Grid_ ), pointer :: data => null () end type Grid public :: newGrid , print_type , valGrid , annotationGrid , sizeGrid interface print_type module procedure printGrid end interface !======================== #define TYPE_NAME Grid #include \"basic_type.inc\" !======================== subroutine delete_Data ( gd ) type ( Grid_ ) :: gd if ( associated ( gd % grid_data )) then deallocate ( gd % grid_data ) gd % grid_data => null () endif call ps_clean_annotation ( gd % annotation ) end subroutine delete_Data subroutine newGrid ( this , n , name ) type ( Grid ), intent ( inout ) :: this integer , intent ( in ) :: n character ( len =* ), intent ( in ), optional :: name integer :: stat ! We release the previous incarnation ! This means that we relinquish access to the previous ! memory location. It will be deallocated when nobody ! else is using it. call init ( this ) if ( present ( name )) then this % data % name = trim ( name ) else this % data % name = \"(Grid from n)\" endif allocate ( this % data % grid_data ( n )) call tag_new_object ( this ) end subroutine newGrid function valGrid ( this ) result ( p ) type ( Grid ), intent ( in ) :: this real ( dp ), pointer :: p (:) nullify ( p ) p => this % data % grid_data end function valGrid function annotationGrid ( this ) result ( p ) type ( Grid ), intent ( in ) :: this type ( ps_annotation_t ) , pointer :: p nullify ( p ) p => this % data % annotation end function annotationGrid function sizeGrid ( this ) result ( n ) type ( Grid ), intent ( in ) :: this integer :: n if (. not . initialized ( this )) then n = 0 else n = size ( this % data % grid_data ) endif end function sizeGrid subroutine printGrid ( this ) type ( Grid ), intent ( in ) :: this integer :: n , m if (. not . associated ( this % data )) then print \"(a)\" , \"Grid Not Associated\" RETURN endif n = size ( this % data % grid_data ) print \"(a,i0,a,i0,a,i0,a)\" , \"  <grid:\" // trim ( this % data % name ) // & \" n=\" , n , & \", refcount: \" , refcount ( this ), \">\" end subroutine printGrid end module class_Grid","tags":"","loc":"sourcefile/class_grid.f90.html"},{"title":"assoc_list.F90 – libPSML","text":"Contents Modules assoc_list Source Code assoc_list.F90 Source Code #if defined HAVE_CONFIG_H #include \"config.h\" #endif module assoc_list ! First version, with fixed (initial) length, ! and fixed-length fields. ! Alberto Garcia, Sept 2014 ! !----------------------------------------------------------- type , public :: assoc_list_t private integer :: nslots = 0 integer :: nitems = 0 character ( len = 200 ), allocatable :: key (:) character ( len = 1000 ), allocatable :: value (:) end type assoc_list_t public :: assoc_list_init public :: assoc_list_reset public :: assoc_list_insert public :: assoc_list_nitems public :: assoc_list_get_key public :: assoc_list_get_value public :: assoc_list_print ! Now, define and export an EMPTY_ASSOC_LIST ! This feature might be deprecated in future versions. Client programs can ! use 'assoc_list_reset' to generate an empty association list. ! NOTE: A module variable of a type with default initialization must ! have the SAVE attribute by the Fortran 2003 or earlier standards ! The 'protected' attribute forbids changing the value of the variable ! from outside the module. ! NOTE: A 'parameter' could be used instead of a variable, with explicit initialization ! of the form: ! type(assoc_list_t), parameter :: PAR = assoc_list_type_t(0,0,null(),null()) ! ... but compiler support for this might be spotty. type ( assoc_list_t ), protected , save :: EMPTY_ASSOC_LIST interface assoc_list_get_value module procedure assoc_list_get_value_by_index module procedure assoc_list_get_value_of_key end interface CONTAINS subroutine assoc_list_init ( a , n , stat ) type ( assoc_list_t ), intent ( inout ) :: a integer , intent ( in ) :: n integer , intent ( out ) :: stat if ( allocated ( a % key )) then deallocate ( a % key ) endif if ( allocated ( a % value )) then deallocate ( a % value ) endif a % nslots = n a % nitems = 0 allocate ( a % key ( n ), a % value ( n ), stat = stat ) end subroutine assoc_list_init subroutine assoc_list_reset ( a ) type ( assoc_list_t ), intent ( inout ) :: a if ( allocated ( a % key )) then deallocate ( a % key ) endif if ( allocated ( a % value )) then deallocate ( a % value ) endif a % nslots = 0 a % nitems = 0 end subroutine assoc_list_reset subroutine assoc_list_insert ( a , key , value , stat ) type ( assoc_list_t ), intent ( inout ) :: a character ( len =* ), intent ( in ) :: key , value integer , intent ( out ) :: stat integer :: i character ( len = 1000 ), allocatable :: b (:) if (. not . allocated ( a % key )) then call assoc_list_init ( a , 4 , stat ) if ( stat /= 0 ) return endif ! Replace if key exists already do i = 1 , a % nitems if ( a % key ( i ) == key ) then a % value ( i ) = value stat = 0 return endif enddo ! ! Add at the end a % nitems = a % nitems + 1 if ( a % nitems > a % nslots ) then ! Enlarge a%data by 4 slots ! allocate ( b ( a % nslots )) ! b = a % key deallocate ( a % key ) allocate ( a % key ( a % nslots + 4 )) a % key ( 1 : a % nslots ) = b ! b = a % value deallocate ( a % value ) allocate ( a % value ( a % nslots + 4 )) a % value ( 1 : a % nslots ) = b deallocate ( b ) ! a % nslots = size ( a % key ) endif i = a % nitems a % key ( i ) = key a % value ( i ) = value stat = 0 end subroutine assoc_list_insert function assoc_list_nitems ( a ) result ( n ) type ( assoc_list_t ), intent ( in ) :: a integer :: n n = a % nitems end function assoc_list_nitems subroutine assoc_list_get_key ( a , i , key , stat ) type ( assoc_list_t ), intent ( in ) :: a integer , intent ( in ) :: i character ( len =* ), intent ( out ) :: key integer , intent ( out ) :: stat if ( i > a % nitems ) then stat = - 1 return endif key = a % key ( i ) stat = 0 end subroutine assoc_list_get_key subroutine assoc_list_get_value_of_key ( a , key , value , stat ) type ( assoc_list_t ), intent ( in ) :: a character ( len =* ), intent ( in ) :: key character ( len =* ), intent ( out ) :: value integer , intent ( out ) :: stat integer :: i do i = 1 , a % nitems if ( a % key ( i ) == key ) then value = a % value ( i ) stat = 0 return endif enddo stat = - 1 end subroutine assoc_list_get_value_of_key subroutine assoc_list_get_value_by_index ( a , i , value , stat ) type ( assoc_list_t ), intent ( in ) :: a integer , intent ( in ) :: i character ( len =* ), intent ( out ) :: value integer , intent ( out ) :: stat if ( i <= a % nitems ) then value = a % value ( i ) stat = 0 else stat = - 1 value = \"\" endif end subroutine assoc_list_get_value_by_index subroutine assoc_list_print ( a ) type ( assoc_list_t ), intent ( in ) :: a integer :: i if ( a % nitems > 0 ) then print \"(a)\" , \"---------------------\" do i = 1 , a % nitems print \"(3x,a,a,a)\" , trim ( a % key ( i )), \" : \" , trim ( a % value ( i )) enddo print \"(a)\" , \"---------------------\" endif end subroutine assoc_list_print end module assoc_list","tags":"","loc":"sourcefile/assoc_list.f90.html"},{"title":"m_psml_core.F90 – libPSML","text":"Data structures to handle the PSML pseudopotential format. Contents Modules m_psml_core Source Code m_psml_core.F90 Source Code !+ graph: false !+ author: Alberto Garcia !+ Data structures to handle the PSML pseudopotential format. #if defined HAVE_CONFIG_H #include \"config.h\" #endif module m_psml_core use assoc_list , only : ps_annotation_t => assoc_list_t use assoc_list , only : ps_clean_annotation => assoc_list_reset use class_Grid use external_interfaces , only : die => psml_die implicit none private ! ! Update this. Up to 99... integer , parameter :: PATCH_LEVEL = 7 ! ! Only update 1000 when changing major/minor version integer , parameter , public :: PSML_LIBRARY_VERSION = 1100 + PATCH_LEVEL ! !  Simple sanity checks while the format evolves !  This version is able to read v1.0 and v1.1 PSML files ! !  Note that the version is really given by the generators. ! ! The \"hi\" value is intended to auto-revoke the library, but ! it is neither completely foolproof nor flexible enough. ! real , parameter , public :: PSML_TARGET_VERSION_LO = 1.00 real , parameter , public :: PSML_TARGET_VERSION_HI = 1.10 !---------------------------------------------------------------- ! Hardwired parameters (to be made dynamical in a later version) ! Maximum number of valence shells (including semicore) or core shells: integer , parameter , private :: MAXN_SHELLS = 20 !---------------------------------------------------------------- integer , parameter , private :: dp = selected_real_kind ( 14 ) ! !----------------------------------------------------------- type , public :: input_file_t character ( len = 100 ) :: name = \"-----\" character ( len = :), allocatable :: buffer end type input_file_t !------ type , public :: provenance_t type ( provenance_t ), pointer :: prev => null () integer :: record_number character ( len = 100 ) :: creator = \"-----\" character ( len = 60 ) :: date = \"-----\" integer :: n_input_files = 0 ! Max 1 for now !! type ( input_file_t ) :: input_file type ( ps_annotation_t ) :: annotation type ( provenance_t ), pointer :: next => null () end type provenance_t !------ type , public :: header_t ! This is the 'pseudo-atom-spec' section character ( len = 100 ) :: atomic_label !! generalized symbol real ( kind = dp ) :: z !! atomic number (might be non-integer) real ( kind = dp ) :: zpseudo !! Z - ncore-electrons character ( len = 100 ) :: flavor !! pseudization method character ( len = 6 ) :: relativity !! \"no|scalar|dirac\" logical :: polarized !! is spin-DFT? ! character ( len = 3 ) :: core_corrections !! are there NLCC's? ! type ( ps_annotation_t ) :: annotation end type header_t !------ type , public :: config_val_t integer :: nshells real ( kind = dp ) :: total_charge integer , dimension ( MAXN_SHELLS ) :: n character ( len = 1 ), dimension ( MAXN_SHELLS ) :: l real ( dp ), dimension ( MAXN_SHELLS ) :: occ real ( dp ), dimension ( MAXN_SHELLS ) :: occ_up real ( dp ), dimension ( MAXN_SHELLS ) :: occ_down ! type ( ps_annotation_t ) :: annotation end type config_val_t !------ type , public :: xc_t integer :: n_functs_libxc = 0 character ( len = 200 ), allocatable :: libxc_name (:) character ( len = 100 ), allocatable :: libxc_type (:) integer , allocatable :: libxc_id (:) real ( dp ), allocatable :: libxc_weight (:) type ( ps_annotation_t ) :: annotation end type xc_t !------ type , public :: radfunc_t type ( Grid ) :: grid real ( kind = dp ), dimension (:), pointer :: data => null () logical :: has_coulomb_tail real ( dp ) :: tail_factor = 0.0_dp integer :: nnz ! # of 'non-zero' values real ( dp ) :: rcut_eff ! effective end of range end type radfunc_t ! !=============================================== type , public :: slps_t integer :: n character ( len = 1 ) :: l real ( dp ) :: j = - 1.0_dp integer :: set character ( len = 100 ) :: flavor real ( dp ) :: rc real ( dp ) :: eref ! Reference energy type ( radfunc_t ) :: V type ( semilocal_t ), pointer :: parent_group => null () type ( slps_t ), pointer :: next => null () end type slps_t type , public :: sl_table_t type ( slps_t ), pointer :: p => null () end type sl_table_t type , public :: semilocal_t type ( slps_t ), pointer :: pot => null () integer :: set ! ! Optional private grid ! type ( Grid ) :: grid type ( ps_annotation_t ) :: annotation ! type ( semilocal_t ), pointer :: next => null () end type semilocal_t !=============================================== type , public :: local_t ! type ( ps_annotation_t ) :: annotation ! Optional private grid ! type ( Grid ) :: grid type ( radfunc_t ) :: Vlocal character ( len = 100 ) :: vlocal_type type ( radfunc_t ) :: Chlocal end type local_t !=============================================== type , public :: nlpj_t integer :: seq character ( len = 1 ) :: l real ( dp ) :: j = - 1.0_dp integer :: set character ( len = 100 ) :: type real ( dp ) :: ekb real ( dp ) :: eref ! Reference energy type ( radfunc_t ) :: proj type ( nonlocal_t ), pointer :: parent_group => null () type ( nlpj_t ), pointer :: next => null () end type nlpj_t type , public :: nl_table_t type ( nlpj_t ), pointer :: p => null () end type nl_table_t type , public :: nonlocal_t type ( nlpj_t ), pointer :: proj => null () integer :: set ! ! Optional private grid ! type ( Grid ) :: grid type ( ps_annotation_t ) :: annotation ! type ( nonlocal_t ), pointer :: next => null () end type nonlocal_t !=============================================== ! Wavefunctions ! type , public :: wf_t integer :: n character ( len = 1 ) :: l integer :: set real ( dp ) :: j = - 1.0_dp real ( dp ) :: energy_level type ( radfunc_t ) :: Phi type ( wfns_t ), pointer :: parent_group => null () type ( wf_t ), pointer :: next => null () end type wf_t type , public :: wf_table_t type ( wf_t ), pointer :: p => null () end type wf_table_t type , public :: wfns_t type ( wf_t ), pointer :: wf => null () integer :: set character ( len = 100 ) :: type = \"\" ! ! Optional private grid ! type ( Grid ) :: grid type ( ps_annotation_t ) :: annotation ! type ( wfns_t ), pointer :: next => null () end type wfns_t type , public :: valence_charge_t real ( dp ) :: total_charge character ( len = 3 ) :: is_unscreening_charge = \"\" character ( len = 3 ) :: rescaled_to_z_pseudo = \"\" type ( radfunc_t ) :: rho_val type ( ps_annotation_t ) :: annotation end type valence_charge_t type , public :: core_charge_t integer :: n_cont_derivs real ( dp ) :: rcore type ( radfunc_t ) :: rho_core type ( ps_annotation_t ) :: annotation end type core_charge_t type , public :: ps_t !! Main derived type to hold the PSML information character ( len = 10 ) :: version = \"\" character ( len = 40 ) :: energy_unit = \"\" character ( len = 40 ) :: length_unit = \"\" character ( len = 36 ) :: uuid = \"\" character ( len = 200 ) :: namespace = \"\" type ( ps_annotation_t ) :: annotation ! V1.0 only type ( provenance_t ), pointer :: provenance => null () type ( header_t ) :: header ! pseudo-atom-spec type ( config_val_t ) :: config_val type ( config_val_t ) :: config_core ! extension type ( xc_t ) :: xc_info type ( Grid ) :: global_grid type ( local_t ) :: local type ( semilocal_t ), pointer :: semilocal => null () type ( nonlocal_t ), pointer :: nonlocal => null () type ( wfns_t ), pointer :: wavefunctions => null () ! type ( valence_charge_t ) :: valence_charge type ( core_charge_t ) :: core_charge ! ! index tables ! type ( sl_table_t ), allocatable :: sl_table (:) type ( nl_table_t ), allocatable :: nl_table (:) type ( wf_table_t ), allocatable :: wf_table (:) end type ps_t integer , parameter , public & :: SET_NULL = 0 , & SET_SREL = 1 , & SET_NONREL = 2 , & SET_SO = 4 , & SET_LJ = 8 , & SET_UP = 16 , & SET_DOWN = 32 , & SET_SPINAVE = 64 , & SET_SPINDIFF = 128 , & ! 2&#94;7 SET_USER1 = 256 , & ! 2&#94;8 SET_USER2 = 512 ! 2&#94;9 integer , parameter , public :: SET_ALL = 2 ** 10 - 1 public :: ps_destroy public :: str_of_set public :: setcode_of_string ! utility function, not for client normal use public :: destroy_local public :: destroy_nonlocal public :: destroy_wavefunctions CONTAINS subroutine ps_destroy ( ps ) !! Cleans the ps object type ( ps_t ), intent ( inout ) :: ps integer :: i call ps_clean_annotation ( ps % annotation ) call destroy_provenance ( ps % provenance ) call ps_clean_annotation ( ps % header % annotation ) call ps_clean_annotation ( ps % config_val % annotation ) call ps_clean_annotation ( ps % config_core % annotation ) call destroy_xc ( ps % xc_info ) ! ! Note that freshly declared objects must have ! npots = 0 and npswfs = 0 ! ! call destroy_semilocal ( ps % semilocal ) call destroy_nonlocal ( ps % nonlocal ) ! call destroy_local ( ps % local ) ! call destroy_wavefunctions ( ps % wavefunctions ) ! call destroy_radfunc ( ps % valence_charge % rho_val ) call ps_clean_annotation ( ps % valence_charge % annotation ) ! call destroy_radfunc ( ps % core_charge % rho_core ) call ps_clean_annotation ( ps % core_charge % annotation ) ! call delete ( ps % global_grid ) end subroutine ps_destroy subroutine destroy_provenance ( p ) type ( provenance_t ), pointer :: p type ( provenance_t ), pointer :: q do while ( associated ( p )) call ps_clean_annotation ( p % annotation ) ! clean buffers for input files? q => p % next deallocate ( p ) p => q enddo end subroutine destroy_provenance !================================================== subroutine destroy_semilocal ( p ) type ( semilocal_t ), pointer :: p type ( semilocal_t ), pointer :: q do while ( associated ( p )) call ps_clean_annotation ( p % annotation ) call destroy_slps ( p % pot ) call delete ( p % grid ) q => p % next deallocate ( p ) p => q enddo end subroutine destroy_semilocal ! subroutine destroy_slps ( p ) type ( slps_t ), pointer :: p type ( slps_t ), pointer :: q do while ( associated ( p )) call destroy_radfunc ( p % V ) q => p % next deallocate ( p ) p => q enddo end subroutine destroy_slps !================================================== subroutine destroy_local ( p ) type ( local_t ) :: p call ps_clean_annotation ( p % annotation ) call delete ( p % grid ) call destroy_radfunc ( p % vlocal ) call destroy_radfunc ( p % chlocal ) end subroutine destroy_local !================================================== subroutine destroy_nonlocal ( p ) type ( nonlocal_t ), pointer :: p type ( nonlocal_t ), pointer :: q do while ( associated ( p )) call ps_clean_annotation ( p % annotation ) call destroy_nlpj ( p % proj ) call delete ( p % grid ) q => p % next deallocate ( p ) p => q enddo end subroutine destroy_nonlocal ! subroutine destroy_nlpj ( p ) type ( nlpj_t ), pointer :: p type ( nlpj_t ), pointer :: q do while ( associated ( p )) call destroy_radfunc ( p % proj ) q => p % next deallocate ( p ) p => q enddo end subroutine destroy_nlpj ! !================================================== subroutine destroy_wavefunctions ( p ) type ( wfns_t ), pointer :: p type ( wfns_t ), pointer :: q do while ( associated ( p )) call ps_clean_annotation ( p % annotation ) call destroy_pswf ( p % wf ) call delete ( p % grid ) q => p % next deallocate ( p ) p => q enddo end subroutine destroy_wavefunctions subroutine destroy_pswf ( p ) type ( wf_t ), pointer :: p type ( wf_t ), pointer :: q do while ( associated ( p )) call destroy_radfunc ( p % Phi ) q => p % next deallocate ( p ) p => q enddo end subroutine destroy_pswf !================================================== subroutine destroy_radfunc ( rp ) type ( radfunc_t ) :: rp call delete ( rp % grid ) if ( associated ( rp % data )) then deallocate ( rp % data ) rp % data => null () endif end subroutine destroy_radfunc ! subroutine destroy_xc ( xp ) type ( xc_t ), intent ( inout ) :: xp if ( allocated ( xp % libxc_name )) deallocate ( xp % libxc_name ) if ( allocated ( xp % libxc_type )) deallocate ( xp % libxc_type ) if ( allocated ( xp % libxc_id )) deallocate ( xp % libxc_id ) if ( allocated ( xp % libxc_weight )) deallocate ( xp % libxc_weight ) call ps_clean_annotation ( xp % annotation ) end subroutine destroy_xc function setcode_of_string ( str ) result ( code ) character ( len =* ), intent ( in ) :: str integer :: code select case ( trim ( str )) case ( \"non_relativistic\" ) code = SET_NONREL case ( \"scalar_relativistic\" ) code = SET_SREL case ( \"spin_orbit\" ) code = SET_SO case ( \"lj\" ) code = SET_LJ case ( \"spin_up\" ) code = SET_UP case ( \"spin_down\" ) code = SET_DOWN case ( \"spin_average\" ) code = SET_SPINAVE case ( \"spin_difference\" ) code = SET_SPINDIFF case ( \"user_extension1\" ) code = SET_USER1 case ( \"user_extension2\" ) code = SET_USER2 case ( \"all\" , \"any\" ) code = SET_ALL case ( \"invalid\" , \"INVALID\" ) code = SET_NULL case default call die ( \"Wrong set string: \" // trim ( str )) end select end function setcode_of_string function str_of_set ( code ) result ( str ) integer , intent ( in ) :: code character ( len = 40 ) :: str character ( len = 100 ) :: msg select case ( code ) case ( SET_NONREL ) str = \"non_relativistic\" case ( SET_SREL ) str = \"scalar_relativistic\" case ( SET_SO ) str = \"spin_orbit\" case ( SET_LJ ) str = \"lj\" case ( SET_UP ) str = \"spin_up\" case ( SET_DOWN ) str = \"spin_down\" case ( SET_SPINAVE ) str = \"spin_average\" case ( SET_SPINDIFF ) str = \"spin_difference\" case ( SET_USER1 ) str = \"user_extension1\" case ( SET_USER2 ) str = \"user_extension2\" case ( SET_ALL ) str = \"all\" case ( SET_NULL ) str = \"invalid\" case default write ( msg , \"(a,i4)\" ) \"Wrong set code: \" , code call die ( msg ) end select end function str_of_set end module m_psml_core","tags":"","loc":"sourcefile/m_psml_core.f90.html"},{"title":"m_psml_interp.F90 – libPSML","text":"Contents Modules m_psml_interp Source Code m_psml_interp.F90 Source Code #if defined HAVE_CONFIG_H #include \"config.h\" #endif module m_psml_interp ! Default quality parameter for interpolator integer , public , save :: nq = 7 ! This is the interface that the interpolators ! must have interface subroutine interpolate ( nquality , x , y , npts , r , val , debug ) integer , parameter :: dp = selected_real_kind ( 10 , 100 ) integer , intent ( in ) :: nquality ! Quality parameter real ( dp ), intent ( in ) :: x ( * ), y ( * ) integer , intent ( in ) :: npts ! Size of x, y arrays real ( dp ), intent ( in ) :: r real ( dp ), intent ( out ) :: val logical , intent ( in ) :: debug end subroutine interpolate end interface ! procedure ( interpolate ), pointer , public :: & interpolator => null () ! ! Note that initialization of procedure pointers at declaration ! is a f2008 feature not yet supported by some compilers... !                       interpolator => dpnint1 public :: set_interpolator , set_default_interpolator private :: dpnint1 CONTAINS subroutine set_interpolator ( func , nquality ) ! Parameter for interpolator's quality ! It might mean different things for different ! interpolators integer , intent ( in ) :: nquality ! We should not need to repeat this... interface subroutine func ( nquality , x , y , npts , r , val , debug ) integer , parameter :: dp = selected_real_kind ( 10 , 100 ) integer , intent ( in ) :: nquality ! Quality parameter real ( dp ), intent ( in ) :: x ( * ), y ( * ) integer , intent ( in ) :: npts ! Size of x, y arrays real ( dp ), intent ( in ) :: r real ( dp ), intent ( out ) :: val logical , intent ( in ) :: debug end subroutine func end interface interpolator => func nq = nquality end subroutine set_interpolator ! ! This routine is needed to work around f2008 issue above ! subroutine set_default_interpolator () ! Default interpolator and quality parameter ! DRH's dpnint modified by AG, at 7th order ! (Included in this module with permission) ! call set_interpolator ( dpnint1 , 7 ) end subroutine set_default_interpolator ! ! Copyright (c) 1989-2014 by D. R. Hamann, Mat-Sim Research LLC and Rutgers ! University ! ! Modified by Alberto Garcia, March 2015 ! This routine is included in this module with permission from D.R. Hamann. ! subroutine dpnint1 ( npoly , xx , yy , nn , r , val , debug ) ! Modified by Alberto Garcia, March 2015 from routine ! dpnint by D.R. Hamann. ! Changes: !   -- A single value is returned !   -- It can extrapolate, instead of stopping, !      when called with an abscissa outside the !      data range. !   -- If the number of data points is less than !      npoly+1, npoly is implicitly reduced, without !      error, and without warning. !   -- Debug interface ! ! local polynomial interpolation of data yy on nn points xx ! giving value val on point r ! npoly sets order of polynomial ! xx must be ordered in ascending order ! output interpolated value val on point r implicit none integer , parameter :: dp = kind ( 1.0d0 ) !Input variables real ( dp ), intent ( in ) :: xx ( * ), yy ( * ) real ( dp ), intent ( in ) :: r real ( dp ), intent ( out ) :: val integer , intent ( in ) :: nn , npoly logical , intent ( in ) :: debug !Local variables real ( dp ) :: sum , term , zz integer ii , imin , imax , iprod , iy , istart , kk , iend ! interval halving search for xx(ii) points bracketing r imin = 1 imax = nn do kk = 1 , nn ii = ( imin + imax ) / 2 if ( r > xx ( ii )) then imin = ii else imax = ii end if if ( imax - imin . eq . 1 ) then exit end if end do zz = r !   if (debug) print *, \"imin, imax: \", imin, imax if ( mod ( npoly , 2 ) == 1 ) then istart = imin - npoly / 2 else if ( zz - xx ( imin ) < xx ( imax ) - zz ) then istart = imin - npoly / 2 else istart = imax - npoly / 2 end if istart = min ( istart , nn - npoly ) istart = max ( istart , 1 ) iend = min ( istart + npoly , nn ) !  if (debug) print *, \"istart, iend: \", istart, iend sum = 0.0d0 do iy = istart , iend if ( yy ( iy ) == 0.0d0 ) cycle term = yy ( iy ) do iprod = istart , iend if ( iprod == iy ) cycle term = term * ( zz - xx ( iprod )) / ( xx ( iy ) - xx ( iprod )) end do sum = sum + term end do val = sum end subroutine dpnint1 end module m_psml_interp","tags":"","loc":"sourcefile/m_psml_interp.f90.html"},{"title":"m_psml_parsing_helpers.F90 – libPSML","text":"Contents Modules m_psml_parsing_helpers Source Code m_psml_parsing_helpers.F90 Source Code #if defined HAVE_CONFIG_H #include \"config.h\" #endif module m_psml_parsing_helpers ! !  This module reads a pseudopotential file written in the PSML format !  A full example of the building up of a data structure using !  the SAX paradigm. ! use m_psml_core ! For data types and basic utilities use external_interfaces , only : die => psml_die use class_Grid use assoc_list , only : ps_annotation_t => assoc_list_t use strings_helpers , only : safe_str_assign implicit none private ! ! It defines the routines that are called from xml_parser in response ! to particular events. ! public :: begin_element , end_element , pcdata_chunk public :: cdata_section_chunk ! ! The data will be stored in this public variable ! There are some design issues to decide: ! -- Should this be a pointer, associated by the client !    program to its own variable? In that case, the !    client should make sure that the variable is \"clean\" !    before calling this routine, as some fields will be !    allocated here. ! -- Perhaps it should be a pointer allocated here (and !    then destroyed when done by the client). It should be !    allocated at the beginning of processing, maybe detected !    with a (default) \"begin_Document\" handler, or by !    \"begin_Element\" after checking for association. !    This is the cleanest option, as the caller might want !    to keep several instances alive at the same time... !    (... but this should be handled by the user) ! -- If \"pseudo\" here is a normal variable, it should also !    be \"cleaned\" before the next use. The current usage !    in Abinit falls in this category: psxml is a pointer !    associated to \"pseudo\", and cleaned after use. ! !    We implement the first option now type ( ps_t ), pointer , public , save :: pseudo => null () logical , public , save :: debug_parsing = . false . logical , private , save :: in_psml = . false . logical , private , save :: in_slps = . false . , in_radfunc = . false . logical , private , save :: in_semilocal = . false . , in_header = . false . logical , private , save :: in_coreCharge = . false . , in_data = . false . logical , private , save :: in_grid_data = . false . , in_grid = . false . logical , private , save :: in_valenceCharge = . false . logical , private , save :: in_provenance = . false ., in_input_file = . false . logical , private , save :: in_valence_config = . false . logical , private , save :: in_xc = . false ., in_libxc_info = . false . logical , private , save :: in_pseudowavefun = . false . , in_pswf = . false . logical , private , save :: in_chlocal = . false ., in_nonlocal = . false . logical , private , save :: in_proj = . false . , in_local_potential = . false . logical , private , save :: got_explicit_grid_data integer , private , save :: ndata , ndata_grid integer , private , save :: n_funct character ( len = 20 ), private , save :: current_wf_set character ( len = 20 ), private , save :: current_sl_set character ( len = 20 ), private , save :: current_proj_set character ( len = 40 ), private , save :: top_flavor integer , parameter , private :: dp = selected_real_kind ( 14 ) real ( dp ), private , save :: zval_generation type ( Grid ), private , save :: tmp_grid real ( dp ), private , save , pointer :: gdata (:) => null () type ( ps_annotation_t ), private , save , pointer :: gannot => null () ! ! Pointers to make it easier to manage the data ! type ( provenance_t ), private , pointer :: pp => null () type ( provenance_t ), private , pointer :: qp => null () type ( input_file_t ), private , pointer :: ifp => null () type ( header_t ), private , pointer :: hp => null () type ( config_val_t ), private , pointer :: cp => null () type ( xc_t ), private , pointer :: xp => null () type ( wfns_t ), private , pointer :: wfp => null () type ( wfns_t ), private , pointer :: qwfp => null () type ( wf_t ), private , pointer :: wfpp => null () type ( wf_t ), private , pointer :: qwfpp => null () type ( semilocal_t ), private , pointer :: slp => null () type ( semilocal_t ), private , pointer :: qslp => null () type ( slps_t ), private , pointer :: slvp => null () type ( slps_t ), private , pointer :: qslvp => null () type ( local_t ), private , pointer :: lop => null () type ( nonlocal_t ), private , pointer :: nlp => null () type ( nonlocal_t ), private , pointer :: qnlp => null () type ( nlpj_t ), private , pointer :: nlpp => null () type ( nlpj_t ), private , pointer :: qnlpp => null () type ( valence_charge_t ), private , pointer :: valp => null () type ( core_charge_t ), private , pointer :: corep => null () type ( radfunc_t ), private , pointer :: rp => null () character ( len = 100 ), private , save :: parent_element = \"\" integer :: npts_data CONTAINS !=========================================================== !---------------------------------------------------------------------- subroutine begin_element ( name , attributes ) use xmlf90_sax , only : dictionary_t , get_value character ( len =* ), intent ( in ) :: name type ( dictionary_t ), intent ( in ) :: attributes character ( len = 100 ) :: value , msg real :: version_number integer :: status integer :: i , npts if ( debug_parsing ) print * , \"Element: \" , trim ( name ) select case ( name ) case ( \"psml\" ) in_psml = . true . ! Make sure that pseudo is pointing to something if (. not . associated ( pseudo )) then call die ( \"ps_t object not initialized by client\" ) endif call get_value ( attributes , \"version\" , value , status ) if ( status /= 0 ) call die ( \"No psml version\" ) read ( value , fmt =* ) version_number if ( ( version_number < PSML_TARGET_VERSION_LO ) . or . & ( version_number > PSML_TARGET_VERSION_HI )) then write ( msg , \"('[',f4.2,',',f4.2,']')\" ) & PSML_TARGET_VERSION_LO , & PSML_TARGET_VERSION_HI call die ( \"This version of the library can \" // & \"process PSML files with version in \" // trim ( msg )) endif pseudo % version = value call get_value ( attributes , \"energy_unit\" , pseudo % energy_unit , status ) if ( status /= 0 ) call die ( \"No energy unit\" ) call get_value ( attributes , \"length_unit\" , pseudo % length_unit , status ) if ( status /= 0 ) call die ( \"No length unit\" ) call get_value ( attributes , \"uuid\" , pseudo % uuid , status ) if ( status /= 0 ) pseudo % uuid = \"no-uuid-specified\" call get_value ( attributes , \"xmlns\" , pseudo % namespace , status ) if ( status /= 0 ) pseudo % namespace = \"no-namespace-specified\" case ( \"provenance\" ) in_provenance = . true . ! This will gather all element provenances at the top level allocate ( pp ) if ( associated ( pseudo % provenance )) then qp => pseudo % provenance do while ( associated ( qp % next )) qp => qp % next enddo qp % next => pp else pseudo % provenance => pp endif pp % n_input_files = 0 call get_value ( attributes , \"creator\" , pp % creator , status ) if ( status /= 0 ) pp % creator = \"unknown\" call get_value ( attributes , \"date\" , pp % date , status ) if ( status /= 0 ) pp % date = \"unknown\" ! Support the optional attribute 'record-number'. ! SAX will keep the order. In this parser we require ! that the records be in the right order in the file. ! (Check performed at the end of parsing) ! Other parsers (e.g. DOM) might need to worry about ! internal ordering pp % record_number = 0 call get_value ( attributes , \"record-number\" , value , status ) if ( status == 0 ) then read ( unit = value , fmt =* ) pp % record_number endif case ( \"input-file\" ) if (. not . in_provenance ) call die ( \"<input-file> outside <provenance>\" ) in_input_file = . true . pp % n_input_files = pp % n_input_files + 1 ifp => pp % input_file call get_value ( attributes , \"name\" , ifp % name , status ) if ( status /= 0 ) ifp % name = \"unknown\" case ( \"header\" , \"pseudo-atom-spec\" ) in_header = . true . hp => pseudo % header call get_value ( attributes , \"atomic-label\" , hp % atomic_label , status ) if ( status /= 0 ) call die ( \"Cannot determine atomic-label\" ) call get_value ( attributes , \"z-pseudo\" , value , status ) if ( status /= 0 ) call die ( \"Cannot determine z-pseudo\" ) read ( unit = value , fmt =* ) hp % zpseudo call get_value ( attributes , \"atomic-number\" , value , status ) if ( status /= 0 ) call die ( \"Cannot determine atomic number\" ) read ( unit = value , fmt =* ) hp % z call get_value ( attributes , \"flavor\" , hp % flavor , status ) if ( status /= 0 ) hp % flavor = \"\" ! empty string signals absence call get_value ( attributes , \"relativity\" , hp % relativity , status ) if ( status /= 0 ) call die ( \"Cannot determine relativity scheme\" ) call get_value ( attributes , \"spin-dft\" , value , status ) if ( status /= 0 ) then ! Check v1.0 form call get_value ( attributes , \"polarized\" , value , status ) if ( status /= 0 ) value = \"no\" endif hp % polarized = ( value == \"yes\" ) if ( hp % polarized . and . trim ( hp % relativity ) == \"dirac\" ) then call die ( \"Cannot be polarized and fully relativistic at the same time\" ) endif call get_value ( attributes , \"core-corrections\" , & hp % core_corrections , status ) if ( status /= 0 ) hp % core_corrections = \"no\" ! Check yes/no value?? case ( \"exchange-correlation\" ) in_xc = . true . xp => pseudo % xc_info case ( \"libxc-info\" ) if (. not . in_xc ) call die ( \"Orphan <libxc-info>\" ) in_libxc_info = . true . call get_value ( attributes , \"number-of-functionals\" , & value , status ) if ( status /= 0 ) call die ( \"Error reading number of libxc functs\" ) read ( unit = value , fmt =* ) xp % n_functs_libxc n_funct = xp % n_functs_libxc allocate ( xp % libxc_name ( n_funct ), xp % libxc_id ( n_funct )) allocate ( xp % libxc_weight ( n_funct ), xp % libxc_type ( n_funct )) xp % libxc_weight ( 1 : n_funct ) = 1.0_dp xp % libxc_type ( 1 : n_funct ) = \"UNKNOWN\" n_funct = 0 ! for checking the counting on the fly case ( \"functional\" ) if (. not . in_libxc_info ) call die ( \"Orphan <functional>\" ) n_funct = n_funct + 1 if ( n_funct > xp % n_functs_libxc ) & call die ( \"Too many <functional> elements in <libxc-info>\" ) call get_value ( attributes , \"name\" , & xp % libxc_name ( n_funct ), status ) if ( status /= 0 ) call die ( \"Error reading libxc name\" ) call get_value ( attributes , \"id\" , value , status ) if ( status /= 0 ) call die ( \"Error reading libxc id\" ) read ( unit = value , fmt =* ) xp % libxc_id ( n_funct ) ! optional attribute(s) call get_value ( attributes , \"weight\" , value , status ) if ( status == 0 ) then read ( unit = value , fmt =* ) xp % libxc_weight ( n_funct ) endif call get_value ( attributes , \"type\" , value , status ) if ( status == 0 ) then xp % libxc_type ( n_funct ) = trim ( value ) endif case ( \"valence-configuration\" ) in_valence_config = . true . pseudo % config_val % nshells = 0 pseudo % config_val % occ_up (:) = 0.0_dp pseudo % config_val % occ_down (:) = 0.0_dp pseudo % config_val % occ (:) = 0.0_dp call get_value ( attributes , \"total-valence-charge\" , value , status ) if ( status /= 0 ) call die ( \"Cannot determine total-valence-charge\" ) read ( unit = value , fmt =* ) pseudo % config_val % total_charge case ( \"shell\" ) if ( in_valence_config ) then cp => pseudo % config_val !         else if (in_core_config) then !            cp => pseudo%config_core else call die ( \"Orphan <shell> element\" ) endif cp % nshells = cp % nshells + 1 call get_value ( attributes , \"l\" , cp % l ( cp % nshells ), status ) if ( status /= 0 ) call die ( \"Cannot determine l for shell\" ) call get_value ( attributes , \"n\" , value , status ) if ( status /= 0 ) call die ( \"Cannot determine n for shell\" ) read ( unit = value , fmt =* ) cp % n ( cp % nshells ) call get_value ( attributes , \"occupation\" , value , status ) if ( status /= 0 ) call die ( \"Cannot determine occupation for shell\" ) read ( unit = value , fmt =* ) cp % occ ( cp % nshells ) call get_value ( attributes , \"occupation-up\" , value , status ) if ( status == 0 ) then read ( unit = value , fmt =* ) cp % occ_up ( cp % nshells ) endif call get_value ( attributes , \"occupation-down\" , value , status ) if ( status == 0 ) then read ( unit = value , fmt =* ) cp % occ_down ( cp % nshells ) endif case ( \"slps\" ) in_slps = . true . if (. not . in_semilocal ) call die ( \"Orphan <slps> element\" ) allocate ( slvp ) ! Append to end of list  !! call append(slp%pot,slvp) if ( associated ( slp % pot )) then qslvp => slp % pot do while ( associated ( qslvp % next )) qslvp => qslvp % next enddo qslvp % next => slvp else !First link slp % pot => slvp endif rp => slvp % V slvp % parent_group => slp ! current semilocal-potentials element call get_value ( attributes , \"set\" , value , status ) if ( status /= 0 ) then value = current_sl_set endif slvp % set = setcode_of_string ( value ) call get_value ( attributes , \"l\" , slvp % l , status ) if ( status /= 0 ) call die ( \"Cannot determine l for SL potential\" ) call get_value ( attributes , \"n\" , value , status ) if ( status /= 0 ) call die ( \"Cannot determine n for SL potential\" ) read ( unit = value , fmt =* ) slvp % n call get_value ( attributes , \"rc\" , value , status ) if ( status /= 0 ) call die ( \"Cannot determine rc for SL potential\" ) read ( unit = value , fmt =* ) slvp % rc call get_value ( attributes , \"j\" , value , status ) if ( status /= 0 ) then if ( slvp % set == SET_LJ ) & call die ( \"Cannot determine j for SLPS in set \" // str_of_set ( SET_LJ )) else read ( unit = value , fmt =* ) slvp % j endif slvp % eref = huge ( 1.0_dp ) ! Signal absence of eref attribute call get_value ( attributes , \"eref\" , value , status ) if ( status == 0 ) then read ( unit = value , fmt =* ) slvp % eref endif call get_value ( attributes , \"flavor\" , slvp % flavor , status ) if ( status /= 0 ) then slvp % flavor = top_flavor endif ! Encode the behavior beyond the range ! The only current possibility is to have ! a Coulomb tail, or zero. select case ( slvp % set ) case ( SET_SO , SET_SPINDIFF ) rp % has_coulomb_tail = . false . case default rp % has_coulomb_tail = . true . rp % tail_factor = - pseudo % header % zpseudo end select case ( \"proj\" ) in_proj = . true . if (. not . in_nonlocal ) call die ( \"Orphan <proj> element\" ) allocate ( nlpp ) ! Append to end of list  !! call append(nlp%proj,nlpp) if ( associated ( nlp % proj )) then qnlpp => nlp % proj do while ( associated ( qnlpp % next )) qnlpp => qnlpp % next enddo qnlpp % next => nlpp else !First link nlp % proj => nlpp endif rp => nlpp % proj rp % has_coulomb_tail = . false . nlpp % parent_group => nlp ! current nonlocal-projectors element call get_value ( attributes , \"set\" , value , status ) if ( status /= 0 ) then value = current_proj_set endif nlpp % set = setcode_of_string ( value ) call get_value ( attributes , \"l\" , nlpp % l , status ) if ( status /= 0 ) call die ( \"Cannot determine l for proj\" ) call get_value ( attributes , \"seq\" , value , status ) if ( status /= 0 ) call die ( \"Cannot determine seq number for proj\" ) read ( unit = value , fmt =* ) nlpp % seq call get_value ( attributes , \"ekb\" , value , status ) if ( status /= 0 ) call die ( \"Cannot determine Ekb for proj\" ) read ( unit = value , fmt =* ) nlpp % ekb nlpp % eref = huge ( 1.0_dp ) ! Signal absence of eref attribute call get_value ( attributes , \"eref\" , value , status ) if ( status == 0 ) then read ( unit = value , fmt =* ) nlpp % eref endif call get_value ( attributes , \"j\" , value , status ) if ( status /= 0 ) then if ( nlpp % set == SET_LJ ) & call die ( \"Cannot determine j for Proj in set \" // str_of_set ( SET_LJ )) else read ( unit = value , fmt =* ) nlpp % j endif call get_value ( attributes , \"type\" , nlpp % type , status ) if ( status /= 0 ) call die ( \"Cannot determine type of proj\" ) case ( \"pswf\" ) if (. not . in_pseudowavefun ) call die ( \"Orphan <pswf> element\" ) in_pswf = . true . allocate ( wfpp ) ! Append to end of list  !! call append(wfp%proj,wfpp) if ( associated ( wfp % wf )) then qwfpp => wfp % wf do while ( associated ( qwfpp % next )) qwfpp => qwfpp % next enddo qwfpp % next => wfpp else !First link wfp % wf => wfpp endif rp => wfpp % Phi rp % has_coulomb_tail = . false . wfpp % parent_group => wfp ! current nowfocal-projectors element call get_value ( attributes , \"set\" , value , status ) if ( status /= 0 ) then value = current_wf_set endif wfpp % set = setcode_of_string ( value ) call get_value ( attributes , \"l\" , wfpp % l , status ) if ( status /= 0 ) call die ( \"Cannot determine l for wf\" ) call get_value ( attributes , \"n\" , value , status ) if ( status /= 0 ) call die ( \"Cannot determine n for wf\" ) read ( unit = value , fmt =* ) wfpp % n call get_value ( attributes , \"j\" , value , status ) if ( status /= 0 ) then if ( wfpp % set == SET_LJ ) & call die ( \"Cannot determine j for wf in set \" // str_of_set ( SET_LJ )) else read ( unit = value , fmt =* ) wfpp % j endif wfpp % energy_level = huge ( 1.0_dp ) call get_value ( attributes , \"energy_level\" , value , status ) if ( status == 0 ) then read ( unit = value , fmt =* ) wfpp % energy_level endif case ( \"grid\" ) in_grid = . true . got_explicit_grid_data = . false . ! This attribute is mandatory call get_value ( attributes , \"npts\" , value , status ) if ( status /= 0 ) call die ( \"Cannot determine grid npts\" ) read ( unit = value , fmt =* ) npts if ( npts == 0 ) call die ( \"Grid size not specified correctly\" ) ! Create working object and associate inner sections ! while the parsing is active call newGrid ( tmp_grid , npts ) gdata => valGrid ( tmp_grid ) gannot => annotationGrid ( tmp_grid ) ! ! In this way we allow for a private grid for each radfunc, ! or for a global grid specification ! if ( in_radfunc ) then if ( debug_parsing ) print * , \"Found grid in radfunc\" if ( initialized ( rp % grid )) then call die ( \"psml: Two grids specified for a radfunc\" ) endif rp % grid = tmp_grid ! We check whether we are at the top level, ! or at an intermediate grouping level that allows a grid else if ( in_nonlocal ) then if ( initialized ( nlp % grid )) then call die ( \"psml: Two grids in same nonlocal block\" ) endif if ( debug_parsing ) print * , \"Found nonlocal grid\" nlp % grid = tmp_grid else if ( in_local_potential ) then if ( initialized ( lop % grid )) then call die ( \"psml: Two grids in same local block\" ) endif if ( debug_parsing ) print * , \"Found local grid\" lop % grid = tmp_grid else if ( in_semilocal ) then if ( initialized ( slp % grid )) then call die ( \"psml: Two grids in same semilocal block\" ) endif if ( debug_parsing ) print * , \"Found semilocal grid\" slp % grid = tmp_grid else if ( in_pseudowavefun ) then if ( initialized ( wfp % grid )) then !call die(\"psml: Two pseudo-wavefunction grids specified\") endif if ( debug_parsing ) print * , \"Found pseudo-wavefunction grid\" wfp % grid = tmp_grid else ! We are at the top level if ( debug_parsing ) print * , \"Found grid at the top level\" if ( initialized ( pseudo % global_grid )) then ! Maybe allow this in the future call die ( \"psml: Two global grids specified\" ) endif pseudo % global_grid = tmp_grid endif case ( \"data\" ) if (. not . in_radfunc ) then call die ( \"<data> element outside <rad_func> element\" ) endif in_data = . true . ! The following blocks are a bit more verbose than needed since ! the Intel compiler seems to be trying to evaluate all the ! clauses joined by an .and. operator, instead of stopping if ! the first clause is .false. if (. not . initialized ( rp % grid )) then ! Try regional grids first if ( in_nonlocal ) then if ( initialized ( nlp % grid )) then rp % grid = nlp % grid if ( debug_parsing ) print * , \"Associated proj grid with nl parent grid\" endif else if ( in_local_potential ) then if ( initialized ( lop % grid )) then rp % grid = lop % grid if ( debug_parsing ) print * , \"Associated grid with vlocal parent grid\" endif else if ( in_semilocal ) then if ( initialized ( slp % grid )) then rp % grid = slp % grid if ( debug_parsing ) print * , \"Associated slps grid with sl parent grid\" endif else if ( in_pseudowavefun ) then if ( initialized ( wfp % grid )) then rp % grid = wfp % grid endif endif endif ! If the parent block does not include a grid, try the global grid if (. not . initialized ( rp % grid )) then if ( initialized ( pseudo % global_grid )) then rp % grid = pseudo % global_grid if ( debug_parsing ) print * , \"Associated grid with global grid\" endif endif ! Now give up if (. not . initialized ( rp % grid )) call die ( \"Cannot find grid data for radfunc\" ) ! This attribute is optional ! If present, it determines the actual number of points of the grid used ! (for example, for a function of shorter range) ! This is an experimental feature that can save space ! (if implemented correctly!!!) call get_value ( attributes , \"npts\" , value , status ) if ( status == 0 ) then read ( unit = value , fmt =* ) npts_data if ( npts_data > sizeGrid ( rp % grid )) call die ( \"data npts too big\" ) else npts_data = sizeGrid ( rp % grid ) endif allocate ( rp % data ( npts_data )) ndata = 0 ! To start the build up case ( \"grid-data\" ) if (. not . in_grid ) call die ( \"Grid_data element outside grid element\" ) in_grid_data = . true . got_explicit_grid_data = . true . if ( size ( gdata ) == 0 ) call die ( \"Grid npts attribute faulty\" ) ndata_grid = 0 ! To start the build up case ( \"radfunc\" ) ! We need to make sure that a radfunc is allowed at this level ! ! For example, if an old-style file with <vps> is used, the finding ! of a <vps> element will not increase npots, and there will be a ! segmentation fault when trying to store the data in the rp pointer, ! which would be non-associated if the vps section is the first ! case of radfuncs in the file ! ! Actually, it gets worse: if there is a <core-charge> element ! before the old-style <vps> section, the rp pointer used for ! core-charge will be reused and assigned the data for the first ! and subsequent vps elements. ! if ( in_slps . or . in_coreCharge . or . in_valenceCharge & . or . in_pswf . or . in_proj . or . in_local_potential & . or . in_chlocal ) then in_radfunc = . true . else call die ( \"<radfunc> element found under unallowed <\" // & trim ( parent_element ) // \">\" ) endif case ( \"pseudocore-charge\" ) in_coreCharge = . true . corep => pseudo % core_charge rp => corep % rho_core rp % has_coulomb_tail = . false . call get_value ( attributes , \"matching-radius\" , value , status ) if ( status == 0 ) then read ( unit = value , fmt =* ) corep % rcore else ! Signal absence of attribute with a negative number corep % rcore = - 1.0_dp endif call get_value ( attributes , \"number-of-continuous-derivatives\" , & value , status ) if ( status == 0 ) then read ( unit = value , fmt =* ) corep % n_cont_derivs else ! Signal absence of attribute with a negative number corep % n_cont_derivs = - 1 endif case ( \"valence-charge\" ) in_valenceCharge = . true . valp => pseudo % valence_charge rp => valp % rho_val rp % has_coulomb_tail = . false . call get_value ( attributes , \"total-charge\" , value , status ) if ( status /= 0 ) call die ( \"Cannot determine total valence charge\" ) read ( unit = value , fmt =* ) valp % total_charge call get_value ( attributes , \"is-unscreening-charge\" ,& valp % is_unscreening_charge , status ) if ( status /= 0 ) valp % is_unscreening_charge = \"\" call get_value ( attributes , \"rescaled-to-z-pseudo\" ,& valp % rescaled_to_z_pseudo , status ) if ( status /= 0 ) valp % rescaled_to_z_pseudo = \"\" case ( \"semilocal-potentials\" ) in_semilocal = . true . allocate ( slp ) if ( associated ( pseudo % semilocal )) then qslp => pseudo % semilocal do while ( associated ( qslp % next )) qslp => qslp % next enddo qslp % next => slp else pseudo % semilocal => slp endif current_sl_set = \"invalid\" slp % set = SET_NULL call get_value ( attributes , \"set\" , value , status ) if ( status == 0 ) then current_sl_set = value slp % set = setcode_of_string ( value ) endif if ( debug_parsing ) print * , \"Found semilocal-potentials set: \" , trim ( current_sl_set ) top_flavor = pseudo % header % flavor call get_value ( attributes , \"flavor\" , value , status ) if ( status == 0 ) then top_flavor = value endif case ( \"nonlocal-projectors\" ) in_nonlocal = . true . ! Allocate new node and add to the end of the linked list allocate ( nlp ) if ( associated ( pseudo % nonlocal )) then qnlp => pseudo % nonlocal do while ( associated ( qnlp % next )) qnlp => qnlp % next enddo qnlp % next => nlp else pseudo % nonlocal => nlp endif current_proj_set = \"invalid\" nlp % set = SET_NULL call get_value ( attributes , \"set\" , value , status ) if ( status == 0 ) then current_proj_set = value nlp % set = setcode_of_string ( value ) endif if ( debug_parsing ) print * , \"Found nonlocal-projectors set: \" , trim ( current_proj_set ) nlp % set = setcode_of_string ( value ) case ( \"local-potential\" ) in_local_potential = . true . lop => pseudo % local rp => lop % vlocal rp % has_coulomb_tail = . true . rp % tail_factor = - pseudo % header % zpseudo call get_value ( attributes , \"type\" , lop % vlocal_type , status ) if ( status /= 0 ) call die ( \"Cannot determine type of local potential\" ) case ( \"local-charge\" ) if (. not . in_local_potential ) call die ( \"<local-charge> outside <local-potential>\" ) in_chlocal = . true . lop => pseudo % local rp => lop % chlocal rp % has_coulomb_tail = . false . ! Future expansion: chlocal attributes case ( \"pseudo-wave-functions\" ) in_pseudowavefun = . true . ! Allocate new node and add to the end of the linked list allocate ( wfp ) if ( associated ( pseudo % wavefunctions )) then qwfp => pseudo % wavefunctions do while ( associated ( qwfp % next )) qwfp => qwfp % next enddo qwfp % next => wfp else pseudo % wavefunctions => wfp endif current_wf_set = \"invalid\" wfp % set = SET_NULL call get_value ( attributes , \"set\" , value , status ) if ( status == 0 ) then current_wf_set = value wfp % set = setcode_of_string ( value ) endif if ( debug_parsing ) print * , \"Found wavefunctions set: \" , trim ( current_wf_set ) wfp % set = setcode_of_string ( value ) !! Optional call get_value ( attributes , \"type\" , value , status ) if ( status == 0 ) wfp % type = trim ( value ) case ( \"annotation\" ) ! Deeper elements first... if ( in_xc ) then call save_annotation ( attributes , xp % annotation ) else if ( in_valence_config ) then call save_annotation ( attributes , cp % annotation ) else if ( in_header ) then call save_annotation ( attributes , hp % annotation ) else if ( in_provenance ) then call save_annotation ( attributes , pp % annotation ) else if ( in_grid ) then call save_annotation ( attributes , gannot ) else if ( in_semilocal ) then call save_annotation ( attributes , slp % annotation ) else if ( in_nonlocal ) then call save_annotation ( attributes , nlp % annotation ) else if ( in_local_potential ) then call save_annotation ( attributes , lop % annotation ) else if ( in_pseudowavefun ) then call save_annotation ( attributes , wfp % annotation ) else if ( in_valenceCharge ) then call save_annotation ( attributes , valp % annotation ) else if ( in_coreCharge ) then call save_annotation ( attributes , corep % annotation ) else if ( in_psml ) then ! It must be at the top level ! Version 1.0 only. Keep it in the structure call save_annotation ( attributes , pseudo % annotation ) else ! Do nothing instead of dying ! call die(\"Misplaced <annotation> element\") endif end select parent_element = name end subroutine begin_element !---------------------------------------------------------------------- subroutine end_element ( name ) character ( len =* ), intent ( in ) :: name integer :: i , nnz real ( dp ) :: Z real ( dp ), parameter :: tol = 1.0e-20_dp !! Scale or other data dependence? real ( dp ), pointer :: rg (:) type ( provenance_t ), pointer :: q => null () integer :: depth if ( debug_parsing ) print * , \"-- end Element: \" , trim ( name ) select case ( name ) case ( \"radfunc\" ) in_radfunc = . false . if (. not . associated ( rp % data )) then call die ( \"No data for radfunc!\" ) endif ! Determine the effective range ! by skipping over (nearly) zeros ! For functions with tail, use r*f rg => valGrid ( rp % grid ) if ( rp % has_coulomb_tail ) then Z = - rp % tail_factor nnz = size ( rp % data ) do while ( approx ( ( rg ( nnz ) * rp % data ( nnz ) + Z ), 0.0_dp , tol ) ) nnz = nnz - 1 enddo else nnz = size ( rp % data ) do while ( approx ( rp % data ( nnz ) , 0.0_dp , tol ) ) nnz = nnz - 1 enddo endif rp % nnz = nnz if ( nnz == size ( rp % data )) then rp % rcut_eff = rg ( nnz ) else rp % rcut_eff = rg ( nnz + 1 ) if ( debug_parsing ) print \"(a,i4,f10.4)\" ,& \"Effective npts and range:\" , nnz + 1 , rp % rcut_eff endif case ( \"grid\" ) in_grid = . false . ! if (. not . got_explicit_grid_data ) then call die ( \"Need explicit grid data!\" ) endif call delete ( tmp_grid ) case ( \"data\" ) ! ! We are done filling up the radfunc data ! Check that we got the advertised number of items ! in_data = . false . if ( ndata /= size ( rp % data )) then call die ( \"npts mismatch in radfunc data\" ) endif case ( \"grid-data\" ) ! ! We are done filling up the grid data ! Check that we got the advertised number of items ! in_grid_data = . false . if ( ndata_grid /= size ( gdata )) then call die ( \"npts mismatch in grid\" ) endif if ( debug_parsing ) print * , \"Got grid data: \" , got_explicit_grid_data case ( \"pseudocore-charge\" ) in_coreCharge = . false . case ( \"valence-charge\" ) in_valenceCharge = . false . case ( \"semilocal-potentials\" ) in_semilocal = . false . slp => null () case ( \"nonlocal-projectors\" ) in_nonlocal = . false . nlp => null () case ( \"slps\" ) in_slps = . false . case ( \"proj\" ) in_proj = . false . case ( \"local-potential\" ) in_local_potential = . false . lop => null () case ( \"local-charge\" ) in_chlocal = . false . case ( \"pseudo-wave-functions\" ) in_pseudowavefun = . false . case ( \"pswf\" ) in_pswf = . false . case ( \"valence-configuration\" ) in_valence_config = . false . case ( \"exchange-correlation\" ) in_xc = . false . case ( \"libxc-info\" ) in_libxc_info = . false . if ( n_funct /= xp % n_functs_libxc ) & call die ( \"Too few <functional> elements in <libxc-info>\" ) case ( \"provenance\" ) in_provenance = . false . case ( \"input-file\" ) in_input_file = . false . case ( \"header\" , \"pseudo-atom-spec\" ) ! v1.0, v1.1 in_header = . false . case ( \"psml\" ) in_psml = . false . ! ! Check provenance elements ! ! First, determine how many there are depth = 0 q => pseudo % provenance do while ( associated ( q )) depth = depth + 1 q => q % next enddo ! ! Assign record numbers. For now, we ! require that the records are ordered in the file ! q => pseudo % provenance do while ( associated ( q )) ! A value of zero means that there is no (optional) record number if ( ( q % record_number /= 0 ) . and . & ( q % record_number /= depth )) then call die ( \"Provenance records out of order\" ) endif q % record_number = depth q => q % next depth = depth - 1 enddo end select end subroutine end_element !---------------------------------------------------------------------- subroutine pcdata_chunk ( chunk ) use xmlf90_sax , only : build_data_array character ( len =* ), intent ( in ) :: chunk if ( len_trim ( chunk ) == 0 ) RETURN ! skip empty chunk if ( in_data ) then ! ! Note that we know where we need to put it through the pointer rp... ! call build_data_array ( chunk , rp % data , ndata ) else if ( in_grid_data ) then ! !     Fill the explicit grid data pointer call build_data_array ( chunk , gdata , ndata_grid ) else if ( in_input_file ) then call safe_str_assign ( ifp % buffer , ifp % buffer // chunk ) else if ( in_header ) then ! ! There should not be any pcdata in header in this version... !      print *, \"Header data:\" !      print *, trim(chunk) endif end subroutine pcdata_chunk ! subroutine cdata_section_chunk ( chunk ) character ( len =* ), intent ( in ) :: chunk if ( len_trim ( chunk ) == 0 ) RETURN ! skip empty chunk if ( in_input_file ) then call safe_str_assign ( ifp % buffer , ifp % buffer // chunk ) endif end subroutine cdata_section_chunk !---------------------------------------------------------------------- ! Annotations are encoded as an association list ! in a couple of arrays ! ( (key \"value\") (key \"value\") ...) ! subroutine save_annotation ( atts , annotation ) use assoc_list , ps_annotation_t => assoc_list_t use xmlf90_sax , only : dictionary_t , get_value , get_key , len type ( dictionary_t ), intent ( in ) :: atts type ( ps_annotation_t ), intent ( out ) :: annotation integer :: n , i , status character ( len = 300 ) :: key , value n = len ( atts ) call assoc_list_init ( annotation , n , status ) if ( status /= 0 ) call die ( \"Failed to init annotation object\" ) do i = 1 , n call get_key ( atts , i , key , status ) if ( status /= 0 ) call die ( \"cannot get key in atts dict\" ) call get_value ( atts , i , value , status ) if ( status /= 0 ) call die ( \"cannot get value in atts dict\" ) call assoc_list_insert ( annotation , key , value , status ) if ( status /= 0 ) call die ( \"Failed to insert annotation pair\" ) enddo end subroutine save_annotation function approx ( x , y , tol ) result ( is_close ) real ( dp ), intent ( in ) :: x , y real ( dp ), intent ( in ) :: tol logical :: is_close is_close = abs ( x - y ) < tol end function approx end module m_psml_parsing_helpers","tags":"","loc":"sourcefile/m_psml_parsing_helpers.f90.html"},{"title":"test_assoc.F90 – libPSML","text":"Contents Programs test_assoc Source Code test_assoc.F90 Source Code #if defined HAVE_CONFIG_H #include \"config.h\" #endif program test_assoc use assoc_list type ( assoc_list_t ) :: a , b character ( len = 100 ) :: k , v , val integer :: stat do i = 1 , 20 write ( k , \"(a,i0)\" ) \"key_\" , i write ( v , \"(a,i0)\" ) \"val_\" , i call assoc_list_insert ( a , k , v , stat ) end do call assoc_list_get_value ( a , 10 , val , stat ) b = a print * , trim ( val ) call assoc_list_get_value ( b , 20 , val , stat ) print * , trim ( val ) end program test_assoc","tags":"","loc":"sourcefile/test_assoc.f90.html"},{"title":"external_interfaces.F90 – libPSML","text":"Contents Modules external_interfaces Source Code external_interfaces.F90 Source Code #if defined HAVE_CONFIG_H #include \"config.h\" #endif module external_interfaces ! ! The user must provide external subroutines ! with these interfaces ! public :: psml_die interface ! Called to terminate the program, printing a message subroutine psml_die ( str ) character ( len =* ), intent ( in ) :: str end subroutine psml_die end interface end module external_interfaces","tags":"","loc":"sourcefile/external_interfaces.f90.html"},{"title":"m_aux_aliases.f90 – libPSML","text":"Contents Modules m_aux_aliases Source Code m_aux_aliases.f90 Source Code module m_aux_aliases use m_psml_core , only : ps_radfunc_t => radfunc_t public :: ps_radfunc_t end module m_aux_aliases","tags":"","loc":"sourcefile/m_aux_aliases.f90.html"},{"title":"m_psml.F90 – libPSML","text":"Contents Modules m_psml Source Code m_psml.F90 Source Code #if defined HAVE_CONFIG_H #include \"config.h\" #endif module m_psml ! use m_psml_reader , only : psml_reader use m_psml_core , only : ps_t , ps_destroy use m_psml_core , only : str_of_set use m_psml_core , only : SET_SREL , & SET_NONREL , & SET_SO , & SET_LJ , & SET_UP , & SET_DOWN , & SET_SPINAVE , & SET_SPINDIFF , & SET_USER1 , & SET_USER2 , & SET_ALL ! Temporarily needed for psop use m_psml_core , only : nonlocal_t , nlpj_t use m_psml_api use m_psml_dump use m_psml_ps_edit ! Exported utility types use m_psml_core , only : ps_radfunc_t => radfunc_t use assoc_list , only : ps_annotation_t => assoc_list_t use assoc_list , only : nitems_annotation => assoc_list_nitems use assoc_list , only : get_annotation_key => assoc_list_get_key use assoc_list , only : get_annotation_value => assoc_list_get_value use assoc_list , only : insert_annotation_pair => assoc_list_insert use assoc_list , only : init_annotation => assoc_list_init use assoc_list , only : reset_annotation => assoc_list_reset use assoc_list , only : print_annotation => assoc_list_print use assoc_list , only : EMPTY_ANNOTATION => EMPTY_ASSOC_LIST ! Remove common names from namespace use class_Grid , dummy_id => id , dummy_name => name ! Export precision of real numbers used integer , public , parameter :: ps_real_kind = selected_real_kind ( 10 , 100 ) end module m_psml","tags":"","loc":"sourcefile/m_psml.f90.html"},{"title":"m_psml_ps_edit.F90 – libPSML","text":"Contents Modules m_psml_ps_edit Source Code m_psml_ps_edit.F90 Source Code !> Functions to edit the PSML ps_t structure !! !> @author Alberto Garcia ! #if defined HAVE_CONFIG_H #include \"config.h\" #endif module m_psml_ps_edit use m_psml_core ! For basic structures use external_interfaces , only : die => psml_die use assoc_list , ps_annotation_t => assoc_list_t implicit none public :: ps_RootAttributes_Set public :: ps_SetUUID public :: ps_SetPSMLVersion public :: ps_AddProvenanceRecord public :: ps_Delete_LocalPotential public :: ps_Delete_NonLocalProjectors ! Aliases interface ps_Provenance_Add module procedure ps_AddProvenanceRecord end interface ps_Provenance_Add public :: ps_Provenance_Add interface ps_NonLocalProjectors_Delete module procedure ps_Delete_NonLocalProjectors end interface ps_NonLocalProjectors_Delete public :: ps_NonLocalProjectors_Delete interface ps_LocalPotential_Delete module procedure ps_Delete_LocalPotential end interface ps_LocalPotential_Delete public :: ps_LocalPotential_Delete !public :: ps_AddSLBlock private CONTAINS !=============================================== subroutine ps_RootAttributes_Set ( ps , version , uuid , namespace ) type ( ps_t ), intent ( inout ) :: ps character ( len =* ), intent ( in ), optional :: version character ( len =* ), intent ( in ), optional :: uuid character ( len =* ), intent ( in ), optional :: namespace if ( present ( version )) then ps % version = version endif if ( present ( uuid )) then ps % uuid = uuid endif if ( present ( namespace )) then ps % namespace = namespace endif end  subroutine ps_RootAttributes_Set subroutine ps_SetPSMLVersion ( ps , version ) type ( ps_t ), intent ( inout ) :: ps character ( len =* ), intent ( in ) :: version ps % version = version end subroutine ps_SetPSMLVersion subroutine ps_SetUUID ( ps , id ) type ( ps_t ), intent ( inout ) :: ps character ( len = 36 ), intent ( in ) :: id ps % uuid = id end subroutine ps_SetUUID subroutine ps_AddProvenanceRecord ( ps , creator , date , annotation ) type ( ps_t ), intent ( inout ) :: ps character ( len =* ), intent ( in ) :: creator character ( len =* ), intent ( in ) :: date type ( ps_annotation_t ), intent ( in ), target :: annotation type ( provenance_t ), pointer :: p type ( provenance_t ), pointer :: q integer :: depth allocate ( p ) ! ! Find the depth of the provenance stack ! depth = 0 q => ps % provenance do while ( associated ( q )) depth = depth + 1 q => q % next enddo q => ps % provenance if ( associated ( q )) then p % next => q q % prev => p endif ps % provenance => p p % record_number = depth + 1 p % creator = trim ( creator ) p % date = trim ( date ) p % annotation = annotation end subroutine ps_AddProvenanceRecord ! subroutine ps_Delete_NonlocalProjectors ( ps ) type ( ps_t ), intent ( inout ) :: ps call destroy_nonlocal ( ps % nonlocal ) end subroutine ps_Delete_NonlocalProjectors subroutine ps_Delete_LocalPotential ( ps ) type ( ps_t ), intent ( inout ) :: ps call destroy_local ( ps % local ) end subroutine ps_Delete_LocalPotential end module m_psml_ps_edit","tags":"","loc":"sourcefile/m_psml_ps_edit.f90.html"},{"title":"m_psml_tables.F90 – libPSML","text":"Contents Modules m_psml_tables Source Code m_psml_tables.F90 Source Code !> Functions to handle PSML pseudopotential format structures !! !! (Table generators) !> @author Alberto Garcia ! #if defined HAVE_CONFIG_H #include \"config.h\" #endif module m_psml_tables use m_psml_core ! For basic structures implicit none public :: ps_GenerateTables private CONTAINS !=============================================== !------------------------------------- subroutine generate_table_sl ( ps ) type ( ps_t ), intent ( inout ), target :: ps type ( semilocal_t ), pointer :: slp type ( slps_t ), pointer :: slvp integer :: npots if ( allocated ( ps % sl_table )) then deallocate ( ps % sl_table ) endif npots = 0 slp => ps % semilocal do while ( associated ( slp )) slvp => slp % pot do while ( associated ( slvp )) npots = npots + 1 slvp => slvp % next enddo slp => slp % next enddo allocate ( ps % sl_table ( npots )) npots = 0 slp => ps % semilocal do while ( associated ( slp )) slvp => slp % pot do while ( associated ( slvp )) npots = npots + 1 ps % sl_table ( npots )% p => slvp slvp => slvp % next enddo slp => slp % next enddo end subroutine generate_table_sl !------------------------------------- subroutine generate_table_nl ( ps ) type ( ps_t ), intent ( inout ), target :: ps type ( nonlocal_t ), pointer :: nlp type ( nlpj_t ), pointer :: nlpp integer :: nprojs if ( allocated ( ps % nl_table )) then deallocate ( ps % nl_table ) endif nprojs = 0 nlp => ps % nonlocal do while ( associated ( nlp )) nlpp => nlp % proj do while ( associated ( nlpp )) nprojs = nprojs + 1 nlpp => nlpp % next enddo nlp => nlp % next enddo allocate ( ps % nl_table ( nprojs )) nprojs = 0 nlp => ps % nonlocal do while ( associated ( nlp )) nlpp => nlp % proj do while ( associated ( nlpp )) nprojs = nprojs + 1 ps % nl_table ( nprojs )% p => nlpp nlpp => nlpp % next enddo nlp => nlp % next enddo end subroutine generate_table_nl !------------------------------------ subroutine generate_table_wf ( ps ) type ( ps_t ), intent ( inout ), target :: ps type ( wfns_t ), pointer :: wfp type ( wf_t ), pointer :: wfpp integer :: nwfns if ( allocated ( ps % wf_table )) then deallocate ( ps % wf_table ) endif nwfns = 0 wfp => ps % wavefunctions do while ( associated ( wfp )) wfpp => wfp % wf do while ( associated ( wfpp )) nwfns = nwfns + 1 wfpp => wfpp % next enddo wfp => wfp % next enddo allocate ( ps % wf_table ( nwfns )) nwfns = 0 wfp => ps % wavefunctions do while ( associated ( wfp )) wfpp => wfp % wf do while ( associated ( wfpp )) nwfns = nwfns + 1 ps % wf_table ( nwfns )% p => wfpp wfpp => wfpp % next enddo wfp => wfp % next enddo end subroutine generate_table_wf subroutine ps_GenerateTables ( ps ) type ( ps_t ), intent ( inout ), target :: ps call generate_table_sl ( ps ) call generate_table_nl ( ps ) call generate_table_wf ( ps ) end subroutine ps_GenerateTables end module m_psml_tables","tags":"","loc":"sourcefile/m_psml_tables.f90.html"},{"title":"basic_type.inc – libPSML","text":"Contents Source Code basic_type.inc Source Code ! -------------------------------------------------------------- ! ! Basic functionality for reference - counted data structures ! ! This file has to be included after the global declarations ! for extra functionality , just where a \"contains\" statement ! would go ! ! Parameter : \"TYPE_NAME\" has to be set to the name of the type ! -------------------------------------------------------------- ! Acknowledgements of inspiration from the community : ! ! Basic templating via include files as in the FLIBS project ! by Arjen Markus ! ! Implementation of the classic reference - counting paradigm ! in the PyF95 project . ! ! ================================================================= #define OBJ_ERR_HANDLER psml_die ! ================================================================= PRIVATE public :: TYPE_NAME public :: init , delete , assignment ( = ), refcount , id public :: name public :: same ! same % data address ( i . e . if : this1 = this2 ) public :: initialized ! is allocated interface assignment ( = ) module procedure assign_ end interface interface init module procedure init_ end interface interface delete module procedure delete_ end interface interface refcount module procedure refcount_ end interface interface id module procedure id_ end interface interface name module procedure name_ end interface interface initialized module procedure initialized_ end interface interface same module procedure same_ end interface #ifdef OBJ_ERR_HANDLER ! Stand - alone routine which must be provided interface subroutine OBJ_ERR_HANDLER ( str ) character ( len =* ), intent ( in ) :: str end subroutine OBJ_ERR_HANDLER end interface # endif CONTAINS ! -- Main structural features ! subroutine init_ ( this ) ! Initializes new storage type ( TYPE_NAME ), intent ( inout ) :: this integer :: error ! First , remove the current reference call delete ( this ) ! Allocate fresh storage allocate ( this % data , stat = error ) if ( error /= 0 ) then #ifdef OBJ_ERR_HANDLER call OBJ_ERR_HANDLER ( \"Error allocating data structure\" ) #else ! Our default behavior STOP \"Error allocating data structure\" # endif endif ! Set the initial reference count this % data % refCount = 1 end subroutine init_ subroutine delete_ ( this ) ! Removes the current reference , possibly ! deallocating storage type ( TYPE_NAME ), intent ( inout ) :: this integer :: error ! logical , external :: print_debug_object_info if ( . not . initialized ( this ) ) return this % data % refCount = this % data % refCount - 1 if ( this % data % refCount == 0 ) then ! Safe to delete the data now ! Use the routine provided for this specific ! type to clean up any internal structure call delete_Data ( this % data ) ! if ( print_debug_object_info ()) then ! print * , \"--> deallocated \" // id(this) // \" \" // trim(this%data%name) ! endif ! Deallocate the currently referenced storage deallocate ( this % data , stat = error ) if ( error /= 0 ) then #ifdef OBJ_ERR_HANDLER call OBJ_ERR_HANDLER ( \"Error in deallocation\" ) #else ! Our default behavior STOP \"Error in deallocation\" # endif endif endif ! This is important to use the correct initialized functions nullify ( this % data ) end subroutine delete_ subroutine assign_ ( this , other ) ! Make \"this\" reference the same data as \"other\" . ! No copying of data is involved , simply an increment of the ! reference counter . ! IMPORTANT NOTE : Assignment must take the form of a subroutine , and ! not of a function , since the \"inout\" intent is essential . One has ! to clean up \"this\" before making it point to the same place as ! \"other\" . In a function , the intrinsic \"out\" intent for \"this\" ! will destroy any prior information . type ( TYPE_NAME ), intent ( inout ) :: this type ( TYPE_NAME ), intent ( in ) :: other if ( . not . initialized ( other ) ) then #ifdef OBJ_ERR_HANDLER call OBJ_ERR_HANDLER ( \"Assignment of non-initialized object in \" // trim(mod_name)) #else ! Our default behavior STOP \"Assignment of non-initialized object in \" // trim(mod_name) # endif endif ! Delete to remove the current reference of \"this\" call delete ( this ) ! Establish the new reference and increment the reference counter . this % data = > other % data this % data % refcount = this % data % refcount + 1 end subroutine assign_ pure function initialized_ ( this ) result ( init ) type ( TYPE_NAME ), intent ( in ) :: this logical :: init ! If it is not associated , it can not contain any data init = associated ( this % data ) end function initialized_ pure function same_ ( this1 , this2 ) result ( same ) type ( TYPE_NAME ), intent ( in ) :: this1 , this2 logical :: same ! If they are not both initialized they can not be the same same = initialized ( this1 ) . and . initialized ( this2 ) if ( . not . same ) return same = associated ( this1 % data , target = this2 % data ) end function same_ function refcount_ ( this ) result ( count ) type ( TYPE_NAME ), intent ( in ) :: this integer :: count count = this % data % refCount end function refcount_ ! The remaining procedures are not essential function id_ ( this ) result ( str ) type ( TYPE_NAME ), intent ( in ) :: this character ( len = 36 ) :: str str = this % data % id end function id_ function name_ ( this ) result ( str ) type ( TYPE_NAME ), intent ( in ) :: this character ( len = len_trim ( this % data % name )) :: str str = trim ( this % data % name ) end function name_ subroutine tag_new_object ( this ) type ( TYPE_NAME ), intent ( inout ) :: this ! logical , external :: print_debug_object_info ! external :: get_uuid ! call get_uuid ( this % data % id ) ! if ( print_debug_object_info ()) then ! print * , ' -- > allocated ' // trim(this%data%name) // \" \" // id(this) ! endif end subroutine tag_new_object ! =============================================================","tags":"","loc":"sourcefile/basic_type.inc.html"},{"title":"Grid_ – libPSML ","text":"type, public :: Grid_ Contents Variables refCount id name npts grid_data annotation Source Code Grid_ Components Type Visibility Attributes Name Initial integer, public :: refCount = 0 character(len=36), public :: id = \"null_id\" character(len=256), public :: name = \"null Grid\" integer, public :: npts = 0 real(kind=dp), public, pointer :: grid_data (:) => null() type(ps_annotation_t), public :: annotation Source Code type Grid_ integer :: refCount = 0 character ( len = 36 ) :: id = \"null_id\" !---------------------- character ( len = 256 ) :: name = \"null Grid\" integer :: npts = 0 real ( dp ), pointer :: grid_data (:) => null () type ( ps_annotation_t ) :: annotation end type Grid_","tags":"","loc":"type/grid_.html"},{"title":"Grid – libPSML ","text":"type, public :: Grid Contents Variables data Source Code Grid Components Type Visibility Attributes Name Initial type( Grid_ ), public, pointer :: data => null() Source Code type Grid type ( Grid_ ), pointer :: data => null () end type Grid","tags":"","loc":"type/grid.html"},{"title":"assoc_list_t – libPSML ","text":"type, public :: assoc_list_t Contents Variables nslots nitems key value Source Code assoc_list_t Components Type Visibility Attributes Name Initial integer, private :: nslots = 0 integer, private :: nitems = 0 character(len=200), private, allocatable :: key (:) character(len=1000), private, allocatable :: value (:) Source Code type , public :: assoc_list_t private integer :: nslots = 0 integer :: nitems = 0 character ( len = 200 ), allocatable :: key (:) character ( len = 1000 ), allocatable :: value (:) end type assoc_list_t","tags":"","loc":"type/assoc_list_t.html"},{"title":"input_file_t – libPSML ","text":"type, public :: input_file_t Contents Variables name buffer Source Code input_file_t Components Type Visibility Attributes Name Initial character(len=100), public :: name = \"-----\" character(len=:), public, allocatable :: buffer Source Code type , public :: input_file_t character ( len = 100 ) :: name = \"-----\" character ( len = :), allocatable :: buffer end type input_file_t","tags":"","loc":"type/input_file_t.html"},{"title":"provenance_t – libPSML ","text":"type, public :: provenance_t Contents Variables prev record_number creator date n_input_files input_file annotation next Source Code provenance_t Components Type Visibility Attributes Name Initial type( provenance_t ), public, pointer :: prev => null() integer, public :: record_number character(len=100), public :: creator = \"-----\" character(len=60), public :: date = \"-----\" integer, public :: n_input_files = 0 type( input_file_t ), public :: input_file type(ps_annotation_t), public :: annotation type( provenance_t ), public, pointer :: next => null() Source Code type , public :: provenance_t type ( provenance_t ), pointer :: prev => null () integer :: record_number character ( len = 100 ) :: creator = \"-----\" character ( len = 60 ) :: date = \"-----\" integer :: n_input_files = 0 ! Max 1 for now !! type ( input_file_t ) :: input_file type ( ps_annotation_t ) :: annotation type ( provenance_t ), pointer :: next => null () end type provenance_t","tags":"","loc":"type/provenance_t.html"},{"title":"header_t – libPSML ","text":"type, public :: header_t Contents Variables atomic_label z zpseudo flavor relativity polarized core_corrections annotation Source Code header_t Components Type Visibility Attributes Name Initial character(len=100), public :: atomic_label real(kind=dp), public :: z real(kind=dp), public :: zpseudo character(len=100), public :: flavor character(len=6), public :: relativity logical, public :: polarized character(len=3), public :: core_corrections type(ps_annotation_t), public :: annotation Source Code type , public :: header_t ! This is the 'pseudo-atom-spec' section character ( len = 100 ) :: atomic_label !! generalized symbol real ( kind = dp ) :: z !! atomic number (might be non-integer) real ( kind = dp ) :: zpseudo !! Z - ncore-electrons character ( len = 100 ) :: flavor !! pseudization method character ( len = 6 ) :: relativity !! \"no|scalar|dirac\" logical :: polarized !! is spin-DFT? ! character ( len = 3 ) :: core_corrections !! are there NLCC's? ! type ( ps_annotation_t ) :: annotation end type header_t","tags":"","loc":"type/header_t.html"},{"title":"config_val_t – libPSML ","text":"type, public :: config_val_t Contents Variables nshells total_charge n l occ occ_up occ_down annotation Source Code config_val_t Components Type Visibility Attributes Name Initial integer, public :: nshells real(kind=dp), public :: total_charge integer, public, dimension(MAXN_SHELLS) :: n character(len=1), public, dimension(MAXN_SHELLS) :: l real(kind=dp), public, dimension(MAXN_SHELLS) :: occ real(kind=dp), public, dimension(MAXN_SHELLS) :: occ_up real(kind=dp), public, dimension(MAXN_SHELLS) :: occ_down type(ps_annotation_t), public :: annotation Source Code type , public :: config_val_t integer :: nshells real ( kind = dp ) :: total_charge integer , dimension ( MAXN_SHELLS ) :: n character ( len = 1 ), dimension ( MAXN_SHELLS ) :: l real ( dp ), dimension ( MAXN_SHELLS ) :: occ real ( dp ), dimension ( MAXN_SHELLS ) :: occ_up real ( dp ), dimension ( MAXN_SHELLS ) :: occ_down ! type ( ps_annotation_t ) :: annotation end type config_val_t","tags":"","loc":"type/config_val_t.html"},{"title":"xc_t – libPSML ","text":"type, public :: xc_t Contents Variables n_functs_libxc libxc_name libxc_type libxc_id libxc_weight annotation Source Code xc_t Components Type Visibility Attributes Name Initial integer, public :: n_functs_libxc = 0 character(len=200), public, allocatable :: libxc_name (:) character(len=100), public, allocatable :: libxc_type (:) integer, public, allocatable :: libxc_id (:) real(kind=dp), public, allocatable :: libxc_weight (:) type(ps_annotation_t), public :: annotation Source Code type , public :: xc_t integer :: n_functs_libxc = 0 character ( len = 200 ), allocatable :: libxc_name (:) character ( len = 100 ), allocatable :: libxc_type (:) integer , allocatable :: libxc_id (:) real ( dp ), allocatable :: libxc_weight (:) type ( ps_annotation_t ) :: annotation end type xc_t","tags":"","loc":"type/xc_t.html"},{"title":"radfunc_t – libPSML ","text":"type, public :: radfunc_t Contents Variables grid data has_coulomb_tail tail_factor nnz rcut_eff Source Code radfunc_t Components Type Visibility Attributes Name Initial type(Grid), public :: grid real(kind=dp), public, dimension(:), pointer :: data => null() logical, public :: has_coulomb_tail real(kind=dp), public :: tail_factor = 0.0_dp integer, public :: nnz real(kind=dp), public :: rcut_eff Source Code type , public :: radfunc_t type ( Grid ) :: grid real ( kind = dp ), dimension (:), pointer :: data => null () logical :: has_coulomb_tail real ( dp ) :: tail_factor = 0.0_dp integer :: nnz ! # of 'non-zero' values real ( dp ) :: rcut_eff ! effective end of range end type radfunc_t","tags":"","loc":"type/radfunc_t.html"},{"title":"slps_t – libPSML ","text":"type, public :: slps_t Contents Variables n l j set flavor rc eref V parent_group next Source Code slps_t Components Type Visibility Attributes Name Initial integer, public :: n character(len=1), public :: l real(kind=dp), public :: j = -1.0_dp integer, public :: set character(len=100), public :: flavor real(kind=dp), public :: rc real(kind=dp), public :: eref type( radfunc_t ), public :: V type( semilocal_t ), public, pointer :: parent_group => null() type( slps_t ), public, pointer :: next => null() Source Code type , public :: slps_t integer :: n character ( len = 1 ) :: l real ( dp ) :: j = - 1.0_dp integer :: set character ( len = 100 ) :: flavor real ( dp ) :: rc real ( dp ) :: eref ! Reference energy type ( radfunc_t ) :: V type ( semilocal_t ), pointer :: parent_group => null () type ( slps_t ), pointer :: next => null () end type slps_t","tags":"","loc":"type/slps_t.html"},{"title":"sl_table_t – libPSML ","text":"type, public :: sl_table_t Contents Variables p Source Code sl_table_t Components Type Visibility Attributes Name Initial type( slps_t ), public, pointer :: p => null() Source Code type , public :: sl_table_t type ( slps_t ), pointer :: p => null () end type sl_table_t","tags":"","loc":"type/sl_table_t.html"},{"title":"semilocal_t – libPSML ","text":"type, public :: semilocal_t Contents Variables pot set grid annotation next Source Code semilocal_t Components Type Visibility Attributes Name Initial type( slps_t ), public, pointer :: pot => null() integer, public :: set type(Grid), public :: grid type(ps_annotation_t), public :: annotation type( semilocal_t ), public, pointer :: next => null() Source Code type , public :: semilocal_t type ( slps_t ), pointer :: pot => null () integer :: set ! ! Optional private grid ! type ( Grid ) :: grid type ( ps_annotation_t ) :: annotation ! type ( semilocal_t ), pointer :: next => null () end type semilocal_t","tags":"","loc":"type/semilocal_t.html"},{"title":"local_t – libPSML ","text":"type, public :: local_t Contents Variables annotation grid Vlocal vlocal_type Chlocal Source Code local_t Components Type Visibility Attributes Name Initial type(ps_annotation_t), public :: annotation type(Grid), public :: grid type( radfunc_t ), public :: Vlocal character(len=100), public :: vlocal_type type( radfunc_t ), public :: Chlocal Source Code type , public :: local_t ! type ( ps_annotation_t ) :: annotation ! Optional private grid ! type ( Grid ) :: grid type ( radfunc_t ) :: Vlocal character ( len = 100 ) :: vlocal_type type ( radfunc_t ) :: Chlocal end type local_t","tags":"","loc":"type/local_t.html"},{"title":"nlpj_t – libPSML ","text":"type, public :: nlpj_t Contents Variables seq l j set type ekb eref proj parent_group next Source Code nlpj_t Components Type Visibility Attributes Name Initial integer, public :: seq character(len=1), public :: l real(kind=dp), public :: j = -1.0_dp integer, public :: set character(len=100), public :: type real(kind=dp), public :: ekb real(kind=dp), public :: eref type( radfunc_t ), public :: proj type( nonlocal_t ), public, pointer :: parent_group => null() type( nlpj_t ), public, pointer :: next => null() Source Code type , public :: nlpj_t integer :: seq character ( len = 1 ) :: l real ( dp ) :: j = - 1.0_dp integer :: set character ( len = 100 ) :: type real ( dp ) :: ekb real ( dp ) :: eref ! Reference energy type ( radfunc_t ) :: proj type ( nonlocal_t ), pointer :: parent_group => null () type ( nlpj_t ), pointer :: next => null () end type nlpj_t","tags":"","loc":"type/nlpj_t.html"},{"title":"nl_table_t – libPSML ","text":"type, public :: nl_table_t Contents Variables p Source Code nl_table_t Components Type Visibility Attributes Name Initial type( nlpj_t ), public, pointer :: p => null() Source Code type , public :: nl_table_t type ( nlpj_t ), pointer :: p => null () end type nl_table_t","tags":"","loc":"type/nl_table_t.html"},{"title":"nonlocal_t – libPSML ","text":"type, public :: nonlocal_t Contents Variables proj set grid annotation next Source Code nonlocal_t Components Type Visibility Attributes Name Initial type( nlpj_t ), public, pointer :: proj => null() integer, public :: set type(Grid), public :: grid type(ps_annotation_t), public :: annotation type( nonlocal_t ), public, pointer :: next => null() Source Code type , public :: nonlocal_t type ( nlpj_t ), pointer :: proj => null () integer :: set ! ! Optional private grid ! type ( Grid ) :: grid type ( ps_annotation_t ) :: annotation ! type ( nonlocal_t ), pointer :: next => null () end type nonlocal_t","tags":"","loc":"type/nonlocal_t.html"},{"title":"wf_t – libPSML ","text":"type, public :: wf_t Contents Variables n l set j energy_level Phi parent_group next Source Code wf_t Components Type Visibility Attributes Name Initial integer, public :: n character(len=1), public :: l integer, public :: set real(kind=dp), public :: j = -1.0_dp real(kind=dp), public :: energy_level type( radfunc_t ), public :: Phi type( wfns_t ), public, pointer :: parent_group => null() type( wf_t ), public, pointer :: next => null() Source Code type , public :: wf_t integer :: n character ( len = 1 ) :: l integer :: set real ( dp ) :: j = - 1.0_dp real ( dp ) :: energy_level type ( radfunc_t ) :: Phi type ( wfns_t ), pointer :: parent_group => null () type ( wf_t ), pointer :: next => null () end type wf_t","tags":"","loc":"type/wf_t.html"},{"title":"wf_table_t – libPSML ","text":"type, public :: wf_table_t Contents Variables p Source Code wf_table_t Components Type Visibility Attributes Name Initial type( wf_t ), public, pointer :: p => null() Source Code type , public :: wf_table_t type ( wf_t ), pointer :: p => null () end type wf_table_t","tags":"","loc":"type/wf_table_t.html"},{"title":"wfns_t – libPSML ","text":"type, public :: wfns_t Contents Variables wf set type grid annotation next Source Code wfns_t Components Type Visibility Attributes Name Initial type( wf_t ), public, pointer :: wf => null() integer, public :: set character(len=100), public :: type = \"\" type(Grid), public :: grid type(ps_annotation_t), public :: annotation type( wfns_t ), public, pointer :: next => null() Source Code type , public :: wfns_t type ( wf_t ), pointer :: wf => null () integer :: set character ( len = 100 ) :: type = \"\" ! ! Optional private grid ! type ( Grid ) :: grid type ( ps_annotation_t ) :: annotation ! type ( wfns_t ), pointer :: next => null () end type wfns_t","tags":"","loc":"type/wfns_t.html"},{"title":"valence_charge_t – libPSML ","text":"type, public :: valence_charge_t Contents Variables total_charge is_unscreening_charge rescaled_to_z_pseudo rho_val annotation Source Code valence_charge_t Components Type Visibility Attributes Name Initial real(kind=dp), public :: total_charge character(len=3), public :: is_unscreening_charge = \"\" character(len=3), public :: rescaled_to_z_pseudo = \"\" type( radfunc_t ), public :: rho_val type(ps_annotation_t), public :: annotation Source Code type , public :: valence_charge_t real ( dp ) :: total_charge character ( len = 3 ) :: is_unscreening_charge = \"\" character ( len = 3 ) :: rescaled_to_z_pseudo = \"\" type ( radfunc_t ) :: rho_val type ( ps_annotation_t ) :: annotation end type valence_charge_t","tags":"","loc":"type/valence_charge_t.html"},{"title":"core_charge_t – libPSML ","text":"type, public :: core_charge_t Contents Variables n_cont_derivs rcore rho_core annotation Source Code core_charge_t Components Type Visibility Attributes Name Initial integer, public :: n_cont_derivs real(kind=dp), public :: rcore type( radfunc_t ), public :: rho_core type(ps_annotation_t), public :: annotation Source Code type , public :: core_charge_t integer :: n_cont_derivs real ( dp ) :: rcore type ( radfunc_t ) :: rho_core type ( ps_annotation_t ) :: annotation end type core_charge_t","tags":"","loc":"type/core_charge_t.html"},{"title":"ps_t – libPSML ","text":"type, public :: ps_t Contents Variables version energy_unit length_unit uuid namespace annotation provenance header config_val config_core xc_info global_grid local semilocal nonlocal wavefunctions valence_charge core_charge sl_table nl_table wf_table Source Code ps_t Components Type Visibility Attributes Name Initial character(len=10), public :: version = \"\" character(len=40), public :: energy_unit = \"\" character(len=40), public :: length_unit = \"\" character(len=36), public :: uuid = \"\" character(len=200), public :: namespace = \"\" type(ps_annotation_t), public :: annotation type( provenance_t ), public, pointer :: provenance => null() type( header_t ), public :: header type( config_val_t ), public :: config_val type( config_val_t ), public :: config_core type( xc_t ), public :: xc_info type(Grid), public :: global_grid type( local_t ), public :: local type( semilocal_t ), public, pointer :: semilocal => null() type( nonlocal_t ), public, pointer :: nonlocal => null() type( wfns_t ), public, pointer :: wavefunctions => null() type( valence_charge_t ), public :: valence_charge type( core_charge_t ), public :: core_charge type( sl_table_t ), public, allocatable :: sl_table (:) type( nl_table_t ), public, allocatable :: nl_table (:) type( wf_table_t ), public, allocatable :: wf_table (:) Source Code type , public :: ps_t !! Main derived type to hold the PSML information character ( len = 10 ) :: version = \"\" character ( len = 40 ) :: energy_unit = \"\" character ( len = 40 ) :: length_unit = \"\" character ( len = 36 ) :: uuid = \"\" character ( len = 200 ) :: namespace = \"\" type ( ps_annotation_t ) :: annotation ! V1.0 only type ( provenance_t ), pointer :: provenance => null () type ( header_t ) :: header ! pseudo-atom-spec type ( config_val_t ) :: config_val type ( config_val_t ) :: config_core ! extension type ( xc_t ) :: xc_info type ( Grid ) :: global_grid type ( local_t ) :: local type ( semilocal_t ), pointer :: semilocal => null () type ( nonlocal_t ), pointer :: nonlocal => null () type ( wfns_t ), pointer :: wavefunctions => null () ! type ( valence_charge_t ) :: valence_charge type ( core_charge_t ) :: core_charge ! ! index tables ! type ( sl_table_t ), allocatable :: sl_table (:) type ( nl_table_t ), allocatable :: nl_table (:) type ( wf_table_t ), allocatable :: wf_table (:) end type ps_t","tags":"","loc":"type/ps_t.html"},{"title":"psml_die – libPSML","text":"subroutine psml_die(str) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: str Contents Source Code psml_die Source Code subroutine psml_die ( str ) character ( len =* ), intent ( in ) :: str write ( 0 , \"(a)\" ) str stop end subroutine psml_die","tags":"","loc":"proc/psml_die.html"},{"title":"psml_reader – libPSML","text":"public subroutine psml_reader(fname, ps, debug) Uses m_psml_core m_psml_tables m_psml_parsing_helpers m_psml_parsing_helpers m_psml_parsing_helpers external_interfaces m_psml_interp xmlf90_sax Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: fname type( ps_t ), intent(inout), target :: ps logical, intent(in), optional :: debug Contents Source Code psml_reader Source Code subroutine psml_reader ( fname , ps , debug ) use m_psml_core , only : ps_t , ps_destroy use m_psml_tables , only : ps_GenerateTables use m_psml_parsing_helpers , only : begin_element , end_element , pcdata_chunk use m_psml_parsing_helpers , only : cdata_section_chunk use m_psml_parsing_helpers , only : pseudo , debug_parsing use external_interfaces , only : die => psml_die use m_psml_interp , only : set_default_interpolator use xmlf90_sax , only : xml_t , open_xmlfile , xml_parse , close_xmlfile implicit none character ( len =* ), intent ( in ) :: fname type ( ps_t ), intent ( inout ), target :: ps logical , intent ( in ), optional :: debug type ( xml_t ) :: fxml integer :: iostat ! Clean the object's internal data ! Note that the inout intent allow us ! to do this, and avoid having ps being ! reset by the compiler call ps_destroy ( ps ) ! Associate module pointer, so that the parsed data ! is written to ps pseudo => ps if ( present ( debug )) then debug_parsing = debug else debug_parsing = . false . endif ! Allocate internal structures here... call open_xmlfile ( fname , fxml , iostat ) if ( iostat /= 0 ) call die ( \"Cannot open PSML file: \" // trim ( fname )) call xml_parse ( fxml , begin_element , end_element , pcdata_chunk , & cdata_section_handler = cdata_section_chunk , verbose = . false .) call close_xmlfile ( fxml ) ! Clean up association of module pointer pseudo => null () call ps_GenerateTables ( ps ) ! ! Set default interpolator ! call set_default_interpolator () end subroutine psml_reader","tags":"","loc":"proc/psml_reader.html"},{"title":"ps_GetLibPSMLVersion – libPSML","text":"public function ps_GetLibPSMLVersion() result(v) Returns the library version in integer format Arguments None Return Value integer Contents Source Code ps_GetLibPSMLVersion Source Code function ps_GetLibPSMLVersion () result ( v ) integer :: v v = PSML_LIBRARY_VERSION end function ps_GetLibPSMLVersion","tags":"","loc":"proc/ps_getlibpsmlversion.html"},{"title":"ps_Provenance_Depth – libPSML","text":"public function ps_Provenance_Depth(ps) result(n) Arguments Type Intent Optional Attributes Name type( ps_t ), intent(in) :: ps Return Value integer Contents Source Code ps_Provenance_Depth Source Code function ps_Provenance_Depth ( ps ) result ( n ) type ( ps_t ), intent ( in ) :: ps integer :: n type ( provenance_t ), pointer :: p n = 0 p => ps % provenance do while ( associated ( p )) n = n + 1 p => p % next enddo end function ps_Provenance_Depth","tags":"","loc":"proc/ps_provenance_depth.html"},{"title":"ps_ValenceCharge_Value – libPSML","text":"public function ps_ValenceCharge_Value(ps, r) result(val) Computes the value of the valence charge at r\n @param ps is a handle to the psml information\n @param r is the radius\n It returns the valence charge density integrated over\n solid angle, so that Q_val = int{ val r r } Arguments Type Intent Optional Attributes Name type( ps_t ), intent(in) :: ps real(kind=dp), intent(in) :: r Return Value real(kind=dp) Contents Source Code ps_ValenceCharge_Value Source Code function ps_ValenceCharge_Value ( ps , r ) result ( val ) type ( ps_t ), intent ( in ) :: ps real ( dp ), intent ( in ) :: r real ( dp ) :: val val = ps_GetValue ( ps % valence_charge % rho_val , r ) end function ps_ValenceCharge_Value","tags":"","loc":"proc/ps_valencecharge_value.html"},{"title":"ps_CoreCharge_Value – libPSML","text":"public function ps_CoreCharge_Value(ps, r) result(val) Computes the value of the pseudo-core charge at r\n @param ps is a handle to the psml information\n @param r is the radius\n It returns the pseudo-core charge density integrated over\n solid angle, so that Q_core = int{ val r r } Arguments Type Intent Optional Attributes Name type( ps_t ), intent(in) :: ps real(kind=dp), intent(in) :: r Return Value real(kind=dp) Contents Source Code ps_CoreCharge_Value Source Code function ps_CoreCharge_Value ( ps , r ) result ( val ) type ( ps_t ), intent ( in ) :: ps real ( dp ), intent ( in ) :: r real ( dp ) :: val val = ps_GetValue ( ps % core_charge % rho_core , r ) end function ps_CoreCharge_Value","tags":"","loc":"proc/ps_corecharge_value.html"},{"title":"ps_GridAnnotation – libPSML","text":"public function ps_GridAnnotation(ps, radfunc) result(annotation) Returns the annotation associated to a grid.\n If a radial function\n handle is given, the annotation for that \n radial function's grid is returned. Otherwise,\n the return value is the annotation for the global grid.\n If there is no appropriate annotation, an empty\n structure is returned.\n @param ps is a handle to the psml information\n @param radfunc is a handle to a radial function structure Arguments Type Intent Optional Attributes Name type( ps_t ), intent(in) :: ps type(ps_radfunc_t), intent(in), optional :: radfunc Return Value type(ps_annotation_t) Contents Source Code ps_GridAnnotation Source Code function ps_GridAnnotation ( ps , radfunc ) result ( annotation ) type ( ps_t ), intent ( in ) :: ps type ( ps_radfunc_t ), intent ( in ), optional :: radfunc type ( ps_annotation_t ) :: annotation type ( ps_annotation_t ), pointer :: annotation_p if ( present ( radfunc )) then ! We are told to get the grid annotation ! for a specific radial function if (. not . initialized ( radfunc % grid )) then call die ( \"get_annotation: Invalid radial function\" ) endif annotation_p => annotationGrid ( radfunc % grid ) ! If npts_data /= npts_grid, add a record to reflect this annotation = annotation_p else ! This is the global grid annotation if (. not . initialized ( ps % global_grid )) then annotation = EMPTY_ANNOTATION else annotation_p => annotationGrid ( ps % global_grid ) annotation = annotation_p endif endif end function ps_GridAnnotation","tags":"","loc":"proc/ps_gridannotation.html"},{"title":"ps_GetValue – libPSML","text":"public function ps_GetValue(f, r) result(val) Arguments Type Intent Optional Attributes Name type(ps_radfunc_t), intent(in) :: f real(kind=dp), intent(in) :: r Return Value real(kind=dp) Contents Source Code ps_GetValue Source Code function ps_GetValue ( f , r ) result ( val ) type ( ps_radfunc_t ), intent ( in ) :: f real ( dp ), intent ( in ) :: r real ( dp ) :: val if ( r > max_range ( f )) then if ( f % has_coulomb_tail ) then val = f % tail_factor / r else val = 0.0_dp endif else val = eval_radfunc ( f , r , debug = global_debug ) endif end function ps_GetValue","tags":"","loc":"proc/ps_getvalue.html"},{"title":"ps_Potential_Value – libPSML","text":"public function ps_Potential_Value(ps, i, r) result(val) Evaluator by storage index Arguments Type Intent Optional Attributes Name type( ps_t ), intent(in) :: ps integer, intent(in) :: i real(kind=dp), intent(in) :: r Return Value real(kind=dp) Contents Source Code ps_Potential_Value Source Code function ps_Potential_Value ( ps , i , r ) result ( val ) type ( ps_t ), intent ( in ) :: ps integer , intent ( in ) :: i real ( dp ), intent ( in ) :: r real ( dp ) :: val call check_index ( i , size ( ps % sl_table ), \"SL pot\" ) val = ps_GetValue ( ps % sl_table ( i )% p % V , r ) end function ps_Potential_Value","tags":"","loc":"proc/ps_potential_value.html"},{"title":"ps_PseudoWf_Value – libPSML","text":"public function ps_PseudoWf_Value(ps, i, r) result(val) Arguments Type Intent Optional Attributes Name type( ps_t ), intent(in) :: ps integer, intent(in) :: i real(kind=dp), intent(in) :: r Return Value real(kind=dp) Contents Source Code ps_PseudoWf_Value Source Code function ps_PseudoWf_Value ( ps , i , r ) result ( val ) type ( ps_t ), intent ( in ) :: ps integer , intent ( in ) :: i real ( dp ), intent ( in ) :: r real ( dp ) :: val call check_index ( i , size ( ps % wf_table ), \"Wf\" ) val = ps_GetValue ( ps % wf_table ( i )% p % Phi , r ) end function ps_PseudoWf_Value","tags":"","loc":"proc/ps_pseudowf_value.html"},{"title":"ps_HasProjectors – libPSML","text":"public function ps_HasProjectors(ps) result(p) Arguments Type Intent Optional Attributes Name type( ps_t ), intent(in) :: ps Return Value logical Contents Source Code ps_HasProjectors Source Code function ps_HasProjectors ( ps ) result ( p ) type ( ps_t ), intent ( in ) :: ps logical :: p ! p = ( size ( ps % nl_table ) > 0 ) end function ps_HasProjectors","tags":"","loc":"proc/ps_hasprojectors.html"},{"title":"ps_HasLocalPotential – libPSML","text":"public function ps_HasLocalPotential(ps) result(p) Arguments Type Intent Optional Attributes Name type( ps_t ), intent(in) :: ps Return Value logical Contents Source Code ps_HasLocalPotential Source Code function ps_HasLocalPotential ( ps ) result ( p ) type ( ps_t ), intent ( in ) :: ps logical :: p ! p = ( initialized ( ps % local % Vlocal % grid )) end function ps_HasLocalPotential","tags":"","loc":"proc/ps_haslocalpotential.html"},{"title":"ps_LocalPotential_Value – libPSML","text":"public function ps_LocalPotential_Value(ps, r) result(val) Arguments Type Intent Optional Attributes Name type( ps_t ), intent(in) :: ps real(kind=dp), intent(in) :: r Return Value real(kind=dp) Contents Source Code ps_LocalPotential_Value Source Code function ps_LocalPotential_Value ( ps , r ) result ( val ) type ( ps_t ), intent ( in ) :: ps real ( dp ), intent ( in ) :: r real ( dp ) :: val val = ps_GetValue ( ps % local % vlocal , r ) end function ps_LocalPotential_Value","tags":"","loc":"proc/ps_localpotential_value.html"},{"title":"ps_HasPSOperator – libPSML","text":"public function ps_HasPSOperator(ps) result(psop) Arguments Type Intent Optional Attributes Name type( ps_t ), intent(in) :: ps Return Value logical Contents Source Code ps_HasPSOperator Source Code function ps_HasPSOperator ( ps ) result ( psop ) type ( ps_t ), intent ( in ) :: ps logical :: psop ! psop = ( ps_HasProjectors ( ps ) . and . ps_HasLocalPotential ( ps )) end function ps_HasPSOperator","tags":"","loc":"proc/ps_haspsoperator.html"},{"title":"ps_HasSemilocalPotentials – libPSML","text":"public function ps_HasSemilocalPotentials(ps) result(p) Arguments Type Intent Optional Attributes Name type( ps_t ), intent(in) :: ps Return Value logical Contents Source Code ps_HasSemilocalPotentials Source Code function ps_HasSemilocalPotentials ( ps ) result ( p ) type ( ps_t ), intent ( in ) :: ps logical :: p ! p = ( associated ( ps % semilocal )) end function ps_HasSemilocalPotentials","tags":"","loc":"proc/ps_hassemilocalpotentials.html"},{"title":"ps_Projector_Value – libPSML","text":"public function ps_Projector_Value(ps, i, r) result(val) Arguments Type Intent Optional Attributes Name type( ps_t ), intent(in) :: ps integer, intent(in) :: i real(kind=dp), intent(in) :: r Return Value real(kind=dp) Contents Source Code ps_Projector_Value Source Code function ps_Projector_Value ( ps , i , r ) result ( val ) !+ display: private type ( ps_t ), intent ( in ) :: ps integer , intent ( in ) :: i real ( dp ), intent ( in ) :: r real ( dp ) :: val call check_index ( i , size ( ps % nl_table ), \"proj\" ) val = ps_GetValue ( ps % nl_table ( i )% p % proj , r ) end function ps_Projector_Value","tags":"","loc":"proc/ps_projector_value.html"},{"title":"l_of_sym – libPSML","text":"private function l_of_sym(str, name) result(l) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: str character(len=*), intent(in) :: name Return Value integer Contents Source Code l_of_sym Source Code function l_of_sym ( str , name ) result ( l ) character ( len =* ), intent ( in ) :: str , name integer :: l ! ! This routine will disappear once we store ! l as integer in the data structure ! do l = 0 , 4 if ( str == sym ( l )) RETURN enddo call die ( \"Wrong l symbol in \" // trim ( name )) end function l_of_sym","tags":"","loc":"proc/l_of_sym.html"},{"title":"max_range – libPSML","text":"private function max_range(f) result(range) Returns the maximum radius in a radfunc's data Arguments Type Intent Optional Attributes Name type( radfunc_t ), intent(in) :: f Return Value real(kind=dp) Contents Source Code max_range Source Code function max_range ( f ) result ( range ) type ( radfunc_t ), intent ( in ) :: f real ( dp ) :: range real ( dp ), pointer :: a (:) integer :: npts_data a => valGrid ( f % grid ) ! if ( global_use_effective_range ) then ! We use the effective end_of_range range = f % rcut_eff else ! Use the nominal range ! This covers the case in which the data set uses only ! a first section of the grid npts_data = size ( f % data ) range = a ( npts_data ) endif end function max_range","tags":"","loc":"proc/max_range.html"},{"title":"eval_radfunc – libPSML","text":"private function eval_radfunc(f, r, debug) result(val) Uses m_psml_interp Arguments Type Intent Optional Attributes Name type( radfunc_t ), intent(in) :: f real(kind=dp), intent(in) :: r logical, intent(in) :: debug Return Value real(kind=dp) Contents Source Code eval_radfunc Source Code function eval_radfunc ( f , r , debug ) result ( val ) use m_psml_interp , only : interpolator , nq type ( radfunc_t ), intent ( in ) :: f real ( dp ), intent ( in ) :: r logical , intent ( in ) :: debug real ( dp ) :: val real ( dp ), pointer :: x (:) => null (), y (:) => null () integer :: npts x => valGrid ( f % grid ) y => f % data (:) !Note size(y) to cover the case in which the data set uses only ! a first section of the grid npts = size ( y ) call interpolator ( nq , x , y , npts , r , val , debug ) end function eval_radfunc","tags":"","loc":"proc/eval_radfunc.html"},{"title":"ps_SetEvaluatorOptions – libPSML","text":"public subroutine ps_SetEvaluatorOptions(quality_level, debug, use_effective_range, custom_interpolator) Uses m_psml_interp Sets various parameters for the operation of\n the evaluator Arguments Type Intent Optional Attributes Name integer, intent(in), optional :: quality_level logical, intent(in), optional :: debug logical, intent(in), optional :: use_effective_range procedure(interp), optional :: custom_interpolator Contents Source Code ps_SetEvaluatorOptions Source Code subroutine ps_SetEvaluatorOptions ( quality_level , debug ,& use_effective_range ,& custom_interpolator ) use m_psml_interp , only : nq , interpolator ! Parameter for interpolator's quality ! It might mean different things for different ! interpolators integer , intent ( in ), optional :: quality_level logical , intent ( in ), optional :: debug logical , intent ( in ), optional :: use_effective_range interface subroutine interp ( nquality , x , y , npts , r , val , debug ) integer , parameter :: dp = selected_real_kind ( 10 , 100 ) integer , intent ( in ) :: nquality ! Quality parameter real ( dp ), intent ( in ) :: x ( * ), y ( * ) integer , intent ( in ) :: npts ! Size of x, y arrays real ( dp ), intent ( in ) :: r real ( dp ), intent ( out ) :: val logical , intent ( in ) :: debug end subroutine interp end interface procedure ( interp ), optional :: custom_interpolator if ( present ( quality_level )) then nq = quality_level endif if ( present ( debug )) then global_debug = debug endif if ( present ( use_effective_range )) then global_use_effective_range = use_effective_range endif if ( present ( custom_interpolator )) then interpolator => custom_interpolator endif end subroutine ps_SetEvaluatorOptions","tags":"","loc":"proc/ps_setevaluatoroptions.html"},{"title":"ps_RootAttributes_Get – libPSML","text":"public subroutine ps_RootAttributes_Get(ps, uuid, version, namespace, annotation) Arguments Type Intent Optional Attributes Name type( ps_t ), intent(in) :: ps character(len=*), intent(out), optional :: uuid character(len=*), intent(out), optional :: version character(len=*), intent(out), optional :: namespace type(ps_annotation_t), intent(out), optional :: annotation Contents Source Code ps_RootAttributes_Get Source Code subroutine ps_RootAttributes_Get ( ps , uuid , version , namespace , annotation ) type ( ps_t ), intent ( in ) :: ps character ( len =* ), intent ( out ), optional :: uuid character ( len =* ), intent ( out ), optional :: version character ( len =* ), intent ( out ), optional :: namespace type ( ps_annotation_t ), intent ( out ), optional :: annotation if ( present ( uuid )) then uuid = trim ( ps % uuid ) endif if ( present ( version )) then version = trim ( ps % version ) endif if ( present ( annotation )) then annotation = ps % annotation endif if ( present ( namespace )) then namespace = ps % namespace endif end subroutine ps_RootAttributes_Get","tags":"","loc":"proc/ps_rootattributes_get.html"},{"title":"ps_Provenance_Get – libPSML","text":"public subroutine ps_Provenance_Get(ps, level, creator, date, annotation, number_of_input_files) Arguments Type Intent Optional Attributes Name type( ps_t ), intent(in) :: ps integer, intent(in) :: level character(len=*), intent(out), optional :: creator character(len=*), intent(out), optional :: date type(ps_annotation_t), intent(out), optional :: annotation integer, intent(out), optional :: number_of_input_files Contents Source Code ps_Provenance_Get Source Code subroutine ps_Provenance_Get ( ps , level , creator , date ,& annotation , number_of_input_files ) type ( ps_t ), intent ( in ) :: ps integer , intent ( in ) :: level character ( len =* ), intent ( out ), optional :: creator character ( len =* ), intent ( out ), optional :: date type ( ps_annotation_t ), intent ( out ), optional :: annotation integer , intent ( out ), optional :: number_of_input_files type ( provenance_t ), pointer :: p logical :: found_level ! Here \"level\" means \"record_number\", with ! the oldest having a value of 1. found_level = . false . p => ps % provenance do while ( associated ( p )) if ( p % record_number == level ) then found_level = . true . exit endif p => p % next enddo if (. not . found_level ) call die ( \"Cannot reach provenance level\" ) if ( present ( creator )) then creator = p % creator endif if ( present ( date )) then date = p % date endif if ( present ( number_of_input_files )) then number_of_input_files = p % n_input_files endif if ( present ( annotation )) then annotation = p % annotation endif end subroutine ps_Provenance_Get","tags":"","loc":"proc/ps_provenance_get.html"},{"title":"ps_PseudoAtomSpec_Get – libPSML","text":"public subroutine ps_PseudoAtomSpec_Get(ps, atomic_symbol, atomic_label, atomic_number, z_pseudo, pseudo_flavor, relativity, spin_dft, core_corrections, annotation) Arguments Type Intent Optional Attributes Name type( ps_t ), intent(in) :: ps character(len=*), intent(out), optional :: atomic_symbol character(len=*), intent(out), optional :: atomic_label real(kind=dp), intent(out), optional :: atomic_number real(kind=dp), intent(out), optional :: z_pseudo character(len=*), intent(out), optional :: pseudo_flavor character(len=*), intent(out), optional :: relativity logical, intent(out), optional :: spin_dft logical, intent(out), optional :: core_corrections type(ps_annotation_t), intent(out), optional :: annotation Contents Source Code ps_PseudoAtomSpec_Get Source Code subroutine ps_PseudoAtomSpec_Get ( ps , atomic_symbol , atomic_label , & atomic_number , z_pseudo , pseudo_flavor ,& relativity , spin_dft , core_corrections , annotation ) type ( ps_t ), intent ( in ) :: ps character ( len =* ), intent ( out ), optional :: atomic_symbol character ( len =* ), intent ( out ), optional :: atomic_label real ( dp ), intent ( out ), optional :: atomic_number real ( dp ), intent ( out ), optional :: z_pseudo character ( len =* ), intent ( out ), optional :: pseudo_flavor character ( len =* ), intent ( out ), optional :: relativity logical , intent ( out ), optional :: spin_dft logical , intent ( out ), optional :: core_corrections type ( ps_annotation_t ), intent ( out ), optional :: annotation if ( present ( atomic_symbol )) then atomic_symbol = ps % header % atomic_label ( 1 : 2 ) endif if ( present ( atomic_label )) then atomic_label = trim ( ps % header % atomic_label ) endif if ( present ( atomic_number )) then atomic_number = ps % header % z endif if ( present ( z_pseudo )) then z_pseudo = ps % header % zpseudo endif if ( present ( pseudo_flavor )) then pseudo_flavor = trim ( ps % header % flavor ) endif if ( present ( relativity )) then relativity = trim ( ps % header % relativity ) endif if ( present ( spin_dft )) then spin_dft = ps % header % polarized endif if ( present ( core_corrections )) then core_corrections = ( ps % header % core_corrections == \"yes\" ) endif if ( present ( annotation )) then annotation = ps % header % annotation endif end subroutine ps_PseudoAtomSpec_Get","tags":"","loc":"proc/ps_pseudoatomspec_get.html"},{"title":"ps_ValenceConfiguration_Get – libPSML","text":"public subroutine ps_ValenceConfiguration_Get(ps, nshells, charge, annotation) Arguments Type Intent Optional Attributes Name type( ps_t ), intent(in) :: ps integer, intent(out), optional :: nshells real(kind=dp), intent(out), optional :: charge type(ps_annotation_t), intent(out), optional :: annotation Contents Source Code ps_ValenceConfiguration_Get Source Code subroutine ps_ValenceConfiguration_Get ( ps , nshells , charge , annotation ) type ( ps_t ), intent ( in ) :: ps integer , intent ( out ), optional :: nshells real ( dp ), intent ( out ), optional :: charge type ( ps_annotation_t ), intent ( out ), optional :: annotation if ( present ( nshells )) then nshells = ps % config_val % nshells endif if ( present ( charge )) then charge = ps % config_val % total_charge endif if ( present ( annotation )) then annotation = ps % config_val % annotation endif end subroutine ps_ValenceConfiguration_Get","tags":"","loc":"proc/ps_valenceconfiguration_get.html"},{"title":"ps_ValenceShell_Get – libPSML","text":"public subroutine ps_ValenceShell_Get(ps, i, n, l, occupation, occ_up, occ_down) Arguments Type Intent Optional Attributes Name type( ps_t ), intent(in) :: ps integer, intent(in) :: i integer, intent(out), optional :: n integer, intent(out), optional :: l real(kind=dp), intent(out), optional :: occupation real(kind=dp), intent(out), optional :: occ_up real(kind=dp), intent(out), optional :: occ_down Contents Source Code ps_ValenceShell_Get Source Code subroutine ps_ValenceShell_Get ( ps , i , n , l , occupation , occ_up , occ_down ) type ( ps_t ), intent ( in ) :: ps integer , intent ( in ) :: i integer , intent ( out ), optional :: n integer , intent ( out ), optional :: l real ( dp ), intent ( out ), optional :: occupation real ( dp ), intent ( out ), optional :: occ_up real ( dp ), intent ( out ), optional :: occ_down call check_index ( i , ps % config_val % nshells , \"valence shell\" ) if ( present ( n )) then n = ps % config_val % n ( i ) endif if ( present ( l )) then l = l_of_sym ( ps % config_val % l ( i ), \"valence shell\" ) endif if ( present ( occupation )) then occupation = ps % config_val % occ ( i ) endif if ( present ( occ_up )) then if ( ps % header % polarized ) then occ_up = ps % config_val % occ_up ( i ) else call die ( \"Cannot get per spin occupation\" ) endif endif if ( present ( occ_down )) then if ( ps % header % polarized ) then occ_down = ps % config_val % occ_down ( i ) else call die ( \"Cannot get per spin occupation\" ) endif endif end subroutine ps_ValenceShell_Get","tags":"","loc":"proc/ps_valenceshell_get.html"},{"title":"ps_ValenceCharge_Get – libPSML","text":"public subroutine ps_ValenceCharge_Get(ps, total_charge, is_unscreening_charge, rescaled_to_z_pseudo, annotation, func) Arguments Type Intent Optional Attributes Name type( ps_t ), intent(in) :: ps real(kind=dp), intent(out), optional :: total_charge character(len=*), intent(out), optional :: is_unscreening_charge character(len=*), intent(out), optional :: rescaled_to_z_pseudo type(ps_annotation_t), intent(out), optional :: annotation type(ps_radfunc_t), intent(out), optional :: func Contents Source Code ps_ValenceCharge_Get Source Code subroutine ps_ValenceCharge_Get ( ps , total_charge ,& is_unscreening_charge , rescaled_to_z_pseudo ,& annotation , func ) type ( ps_t ), intent ( in ) :: ps real ( dp ), intent ( out ), optional :: total_charge character ( len =* ), intent ( out ), optional :: is_unscreening_charge character ( len =* ), intent ( out ), optional :: rescaled_to_z_pseudo type ( ps_annotation_t ), intent ( out ), optional :: annotation type ( ps_radfunc_t ), intent ( out ), optional :: func if ( present ( total_charge )) then total_charge = ps % valence_charge % total_charge endif if ( present ( is_unscreening_charge )) then is_unscreening_charge = ps % valence_charge % is_unscreening_charge endif if ( present ( rescaled_to_z_pseudo )) then rescaled_to_z_pseudo = ps % valence_charge % rescaled_to_z_pseudo endif if ( present ( annotation )) then annotation = ps % valence_charge % annotation endif if ( present ( func )) then func = ps % valence_charge % rho_val endif end subroutine ps_ValenceCharge_Get","tags":"","loc":"proc/ps_valencecharge_get.html"},{"title":"ps_CoreCharge_Get – libPSML","text":"public subroutine ps_CoreCharge_Get(ps, rc, nderivs, annotation, func) Arguments Type Intent Optional Attributes Name type( ps_t ), intent(in) :: ps real(kind=dp), intent(out), optional :: rc integer, intent(out), optional :: nderivs type(ps_annotation_t), intent(out), optional :: annotation type(ps_radfunc_t), intent(out), optional :: func Contents Source Code ps_CoreCharge_Get Source Code subroutine ps_CoreCharge_Get ( ps , rc , nderivs , annotation , func ) type ( ps_t ), intent ( in ) :: ps real ( dp ), intent ( out ), optional :: rc integer , intent ( out ), optional :: nderivs type ( ps_annotation_t ), intent ( out ), optional :: annotation type ( ps_radfunc_t ), intent ( out ), optional :: func if ( present ( rc )) then rc = ps % core_charge % rcore endif if ( present ( nderivs )) then nderivs = ps % core_charge % n_cont_derivs endif if ( present ( annotation )) then annotation = ps % core_charge % annotation endif if ( present ( func )) then func = ps % core_charge % rho_core endif end subroutine ps_CoreCharge_Get","tags":"","loc":"proc/ps_corecharge_get.html"},{"title":"ps_ExchangeCorrelation_Get – libPSML","text":"public subroutine ps_ExchangeCorrelation_Get(ps, annotation, n_libxc_functionals) Arguments Type Intent Optional Attributes Name type( ps_t ), intent(in) :: ps type(ps_annotation_t), intent(out), optional :: annotation integer, intent(out), optional :: n_libxc_functionals Contents Source Code ps_ExchangeCorrelation_Get Source Code subroutine ps_ExchangeCorrelation_Get ( ps , annotation , n_libxc_functionals ) type ( ps_t ), intent ( in ) :: ps type ( ps_annotation_t ), intent ( out ), optional :: annotation integer , intent ( out ), optional :: n_libxc_functionals if ( present ( annotation )) then annotation = ps % xc_info % annotation endif if ( present ( n_libxc_functionals )) then n_libxc_functionals = ps % xc_info % n_functs_libxc endif end subroutine ps_ExchangeCorrelation_Get","tags":"","loc":"proc/ps_exchangecorrelation_get.html"},{"title":"ps_LibxcFunctional_Get – libPSML","text":"public subroutine ps_LibxcFunctional_Get(ps, i, name, code, type, weight) Arguments Type Intent Optional Attributes Name type( ps_t ), intent(in) :: ps integer, intent(in) :: i character(len=*), intent(out), optional :: name integer, intent(out), optional :: code character(len=*), intent(out), optional :: type real(kind=dp), intent(out), optional :: weight Contents Source Code ps_LibxcFunctional_Get Source Code subroutine ps_LibxcFunctional_Get ( ps , i , name , code , type , weight ) type ( ps_t ), intent ( in ) :: ps integer , intent ( in ) :: i character ( len =* ), intent ( out ), optional :: name integer , intent ( out ), optional :: code character ( len =* ), intent ( out ), optional :: type real ( dp ), intent ( out ), optional :: weight call check_index ( i , ps % xc_info % n_functs_libxc , \"libxc functional\" ) if ( present ( name )) then name = ps % xc_info % libxc_name ( i ) endif if ( present ( code )) then code = ps % xc_info % libxc_id ( i ) endif if ( present ( type )) then type = ps % xc_info % libxc_type ( i ) endif if ( present ( weight )) then weight = ps % xc_info % libxc_weight ( i ) endif end subroutine ps_LibxcFunctional_Get","tags":"","loc":"proc/ps_libxcfunctional_get.html"},{"title":"ps_Potential_Get – libPSML","text":"public subroutine ps_Potential_Get(ps, i, l, j, n, rc, set, flavor, eref, annotation, func) Arguments Type Intent Optional Attributes Name type( ps_t ), intent(in), target :: ps integer, intent(in) :: i integer, intent(out), optional :: l real(kind=dp), intent(out), optional :: j integer, intent(out), optional :: n real(kind=dp), intent(out), optional :: rc integer, intent(out), optional :: set character(len=*), intent(out), optional :: flavor real(kind=dp), intent(out), optional :: eref type(ps_annotation_t), intent(out), optional :: annotation type(ps_radfunc_t), intent(out), optional :: func Contents Source Code ps_Potential_Get Source Code subroutine ps_Potential_Get ( ps , i ,& l , j , n , rc , set , flavor , eref , annotation , func ) type ( ps_t ), intent ( in ), target :: ps integer , intent ( in ) :: i integer , intent ( out ), optional :: set integer , intent ( out ), optional :: l real ( dp ), intent ( out ), optional :: j integer , intent ( out ), optional :: n real ( dp ), intent ( out ), optional :: rc real ( dp ), intent ( out ), optional :: eref character ( len =* ), intent ( out ), optional :: flavor type ( ps_annotation_t ), intent ( out ), optional :: annotation type ( ps_radfunc_t ), intent ( out ), optional :: func type ( sl_table_t ), pointer :: q (:) q => ps % sl_table call check_index ( i , size ( q ), \"SL pot\" ) if ( present ( set )) then set = q ( i )% p % set endif if ( present ( l )) then l = l_of_sym ( q ( i )% p % l , \"SL pot\" ) endif if ( present ( n )) then n = q ( i )% p % n endif if ( present ( j )) then if ( q ( i )% p % j < 0.0 ) then j = - 1.0_dp ! Maybe optional status flag raised? else j = q ( i )% p % j endif endif if ( present ( rc )) then rc = q ( i )% p % rc endif if ( present ( eref )) then ! Will return a very large positive value if the attribute eref is not ! present in the file eref = q ( i )% p % eref endif if ( present ( flavor )) then flavor = q ( i )% p % flavor endif if ( present ( annotation )) then annotation = q ( i )% p % parent_group % annotation endif if ( present ( func )) then func = q ( i )% p % V endif end subroutine ps_Potential_Get","tags":"","loc":"proc/ps_potential_get.html"},{"title":"ps_SemilocalPotentials_Filter – libPSML","text":"public subroutine ps_SemilocalPotentials_Filter(ps, indexes_in, l, j, n, set, indexes, number) Arguments Type Intent Optional Attributes Name type( ps_t ), intent(in), target :: ps integer, intent(in), optional :: indexes_in (:) integer, intent(in), optional :: l real(kind=dp), intent(in), optional :: j integer, intent(in), optional :: n integer, intent(in), optional :: set integer, intent(out), optional allocatable :: indexes (:) integer, intent(out), optional :: number Contents Source Code ps_SemilocalPotentials_Filter Source Code subroutine ps_SemilocalPotentials_Filter ( ps ,& indexes_in , & l , j , n , set , & indexes , number ) type ( ps_t ), intent ( in ), target :: ps integer , intent ( in ), optional :: indexes_in (:) integer , intent ( in ), optional :: set integer , intent ( in ), optional :: l real ( dp ), intent ( in ), optional :: j integer , intent ( in ), optional :: n integer , intent ( out ), allocatable , optional :: indexes (:) integer , intent ( out ), optional :: number integer :: i , ii , num integer , allocatable :: idx (:), range (:) type ( sl_table_t ), pointer :: q (:) q => ps % sl_table ! !  If we specify an initial domain, we !  only loop over it for the rest of !  the operations ! if ( present ( indexes_in )) then allocate ( range ( size ( indexes_in ))) range (:) = indexes_in (:) else allocate ( range ( size ( q ))) do ii = 1 , size ( q ) range ( ii ) = ii enddo endif num = 0 do ii = 1 , size ( range ) i = range ( ii ) if ( present ( set )) then if ( iand ( q ( i )% p % set , set ) == 0 ) cycle endif if ( present ( l )) then if ( l_of_sym ( q ( i )% p % l , \"pot\" ) /= l ) cycle endif if ( present ( j )) then ! A negative p%j signals the absence of j... if ( q ( i )% p % j < 0.0 ) cycle ! Perform integer comparison if ( nint ( 10 * q ( i )% p % j ) /= nint ( 10 * j )) cycle endif if ( present ( n )) then if ( q ( i )% p % n /= n ) cycle endif num = num + 1 enddo allocate ( idx ( num )) num = 0 do ii = 1 , size ( range ) i = range ( ii ) if ( present ( set )) then if ( iand ( q ( i )% p % set , set ) == 0 ) cycle endif if ( present ( j )) then ! A negative p%j signals the absence of j... if ( q ( i )% p % j < 0.0 ) cycle ! Perform integer comparison if ( nint ( 10 * q ( i )% p % j ) /= nint ( 10 * j )) cycle endif if ( present ( l )) then if ( l_of_sym ( q ( i )% p % l , \"pot\" ) /= l ) cycle endif if ( present ( n )) then if ( q ( i )% p % n /= n ) cycle endif num = num + 1 idx ( num ) = i enddo if ( present ( indexes )) then if ( allocated ( indexes )) deallocate ( indexes ) allocate ( indexes ( num )) indexes (:) = idx (:) endif if ( present ( number )) then number = num endif deallocate ( idx , range ) end subroutine ps_SemilocalPotentials_Filter","tags":"","loc":"proc/ps_semilocalpotentials_filter.html"},{"title":"ps_GetRawData – libPSML","text":"public subroutine ps_GetRawData(f, raw_r, raw_data) Arguments Type Intent Optional Attributes Name type(ps_radfunc_t), intent(in) :: f real(kind=dp), intent(out), allocatable :: raw_r (:) real(kind=dp), intent(out), allocatable :: raw_data (:) Contents Source Code ps_GetRawData Source Code subroutine ps_GetRawData ( f , raw_r , raw_data ) type ( ps_radfunc_t ), intent ( in ) :: f real ( dp ), allocatable , intent ( out ) :: raw_r (:), raw_data (:) integer npts_data real ( dp ), pointer :: a (:) ! Cover the case in which the data set uses only ! a first section of the grid npts_data = size ( f % data ) allocate ( raw_r ( npts_data ), raw_data ( npts_data )) a => valGrid ( f % grid ) raw_r ( 1 : npts_data ) = a ( 1 : npts_data ) raw_data (:) = f % data (:) end subroutine ps_GetRawData","tags":"","loc":"proc/ps_getrawdata.html"},{"title":"ps_PseudoWaveFunctions_Filter – libPSML","text":"public subroutine ps_PseudoWaveFunctions_Filter(ps, indexes_in, l, j, n, set, indexes, number) Arguments Type Intent Optional Attributes Name type( ps_t ), intent(in), target :: ps integer, intent(in), optional :: indexes_in (:) integer, intent(in), optional :: l real(kind=dp), intent(in), optional :: j integer, intent(in), optional :: n integer, intent(in), optional :: set integer, intent(out), optional allocatable :: indexes (:) integer, intent(out), optional :: number Contents Source Code ps_PseudoWaveFunctions_Filter Source Code subroutine ps_PseudoWaveFunctions_Filter ( ps ,& indexes_in ,& l , j , n , set , & indexes , number ) type ( ps_t ), intent ( in ), target :: ps integer , intent ( in ), optional :: indexes_in (:) integer , intent ( in ), optional :: set integer , intent ( in ), optional :: l real ( dp ), intent ( in ), optional :: j integer , intent ( in ), optional :: n integer , intent ( out ), allocatable , optional :: indexes (:) integer , intent ( out ), optional :: number integer :: i , ii , num integer , allocatable :: idx (:), range (:) type ( wf_table_t ), pointer :: q (:) q => ps % wf_table ! !  If we specify an initial domain, we !  only loop over it for the rest of !  the operations ! if ( present ( indexes_in )) then allocate ( range ( size ( indexes_in ))) range (:) = indexes_in (:) else allocate ( range ( size ( q ))) do ii = 1 , size ( q ) range ( ii ) = ii enddo endif num = 0 do ii = 1 , size ( range ) i = range ( ii ) if ( present ( set )) then if ( iand ( q ( i )% p % set , set ) == 0 ) cycle endif if ( present ( l )) then if ( l_of_sym ( q ( i )% p % l , \"wf\" ) /= l ) cycle endif if ( present ( j )) then ! A negative p%j signals the absence of j... if ( q ( i )% p % j < 0.0 ) cycle ! Perform integer comparison if ( nint ( 10 * q ( i )% p % j ) /= nint ( 10 * j )) cycle endif if ( present ( n )) then if ( q ( i )% p % n /= n ) cycle endif num = num + 1 enddo allocate ( idx ( num )) num = 0 do ii = 1 , size ( range ) i = range ( ii ) if ( present ( set )) then if ( iand ( q ( i )% p % set , set ) == 0 ) cycle endif if ( present ( j )) then ! A negative p%j signals the absence of j... if ( q ( i )% p % j < 0.0 ) cycle ! Perform integer comparison if ( nint ( 10 * q ( i )% p % j ) /= nint ( 10 * j )) cycle endif if ( present ( l )) then if ( l_of_sym ( q ( i )% p % l , \"wf\" ) /= l ) cycle endif if ( present ( n )) then if ( q ( i )% p % n /= n ) cycle endif num = num + 1 idx ( num ) = i enddo if ( present ( indexes )) then if ( allocated ( indexes )) deallocate ( indexes ) allocate ( indexes ( num )) indexes (:) = idx (:) endif if ( present ( number )) then number = num endif deallocate ( idx , range ) end subroutine ps_PseudoWaveFunctions_Filter","tags":"","loc":"proc/ps_pseudowavefunctions_filter.html"},{"title":"ps_PseudoWf_Get – libPSML","text":"public subroutine ps_PseudoWf_Get(ps, i, l, j, n, set, energy_level, annotation, func) Arguments Type Intent Optional Attributes Name type( ps_t ), intent(in), target :: ps integer, intent(in) :: i integer, intent(out), optional :: l real(kind=dp), intent(out), optional :: j integer, intent(out), optional :: n integer, intent(out), optional :: set real(kind=dp), intent(out), optional :: energy_level type(ps_annotation_t), intent(out), optional :: annotation type(ps_radfunc_t), intent(out), optional :: func Contents Source Code ps_PseudoWf_Get Source Code subroutine ps_PseudoWf_Get ( ps , i ,& l , j , n , set , energy_level , annotation , func ) type ( ps_t ), intent ( in ), target :: ps integer , intent ( in ) :: i integer , intent ( out ), optional :: set integer , intent ( out ), optional :: l real ( dp ), intent ( out ), optional :: j integer , intent ( out ), optional :: n real ( dp ), intent ( out ), optional :: energy_level type ( ps_annotation_t ), intent ( out ), optional :: annotation type ( ps_radfunc_t ), intent ( out ), optional :: func type ( wf_table_t ), pointer :: q (:) q => ps % wf_table call check_index ( i , size ( q ), \"wf\" ) if ( present ( set )) then set = q ( i )% p % set endif if ( present ( l )) then l = l_of_sym ( q ( i )% p % l , \"wf\" ) endif if ( present ( n )) then n = q ( i )% p % n endif if ( present ( j )) then if ( q ( i )% p % j < 0.0 ) then j = - 1.0_dp ! Maybe optional status flag raised? else j = q ( i )% p % j endif endif if ( present ( energy_level )) then ! Will return a very large positive value if the attribute energy_level is not ! present in the file energy_level = q ( i )% p % energy_level endif if ( present ( annotation )) then annotation = q ( i )% p % parent_group % annotation endif if ( present ( func )) then func = q ( i )% p % Phi endif end subroutine ps_PseudoWf_Get","tags":"","loc":"proc/ps_pseudowf_get.html"},{"title":"ps_LocalPotential_Get – libPSML","text":"public subroutine ps_LocalPotential_Get(ps, type, annotation, func, has_local_charge, func_local_charge) Arguments Type Intent Optional Attributes Name type( ps_t ), intent(in) :: ps character(len=*), intent(out), optional :: type type(ps_annotation_t), intent(out), optional :: annotation type(ps_radfunc_t), intent(out), optional :: func logical, intent(out), optional :: has_local_charge type(ps_radfunc_t), intent(out), optional :: func_local_charge Contents Source Code ps_LocalPotential_Get Source Code subroutine ps_LocalPotential_Get ( ps , type , annotation , func ,& has_local_charge , func_local_charge ) type ( ps_t ), intent ( in ) :: ps character ( len =* ), intent ( out ), optional :: type type ( ps_annotation_t ), intent ( out ), optional :: annotation type ( ps_radfunc_t ), intent ( out ), optional :: func logical , intent ( out ), optional :: has_local_charge type ( ps_radfunc_t ), intent ( out ), optional :: func_local_charge if ( present ( type )) then type = ps % local % vlocal_type endif if ( present ( annotation )) then annotation = ps % local % annotation endif if ( present ( func )) then func = ps % local % vlocal endif if ( present ( has_local_charge )) then has_local_charge = ( initialized ( ps % local % chlocal % grid )) endif if ( present ( func_local_charge )) then ! No checks func_local_charge = ps % local % chlocal endif end subroutine ps_LocalPotential_Get","tags":"","loc":"proc/ps_localpotential_get.html"},{"title":"ps_NonlocalProjectors_Filter – libPSML","text":"public subroutine ps_NonlocalProjectors_Filter(ps, indexes_in, l, j, seq, set, indexes, number) Arguments Type Intent Optional Attributes Name type( ps_t ), intent(in), target :: ps integer, intent(in), optional :: indexes_in (:) integer, intent(in), optional :: l real(kind=dp), intent(in), optional :: j integer, intent(in), optional :: seq integer, intent(in), optional :: set integer, intent(out), optional allocatable :: indexes (:) integer, intent(out), optional :: number Contents Source Code ps_NonlocalProjectors_Filter Source Code subroutine ps_NonlocalProjectors_Filter ( ps ,& indexes_in ,& l , j , seq , set , & indexes , number ) type ( ps_t ), intent ( in ), target :: ps integer , intent ( in ), optional :: indexes_in (:) integer , intent ( in ), optional :: set integer , intent ( in ), optional :: l real ( dp ), intent ( in ), optional :: j integer , intent ( in ), optional :: seq integer , intent ( out ), allocatable , optional :: indexes (:) integer , intent ( out ), optional :: number integer :: i , ii , num integer , allocatable :: idx (:), range (:) type ( nl_table_t ), pointer :: q (:) q => ps % nl_table ! !  If we specify an initial domain, we !  only loop over it for the rest of !  the operations ! if ( present ( indexes_in )) then allocate ( range ( size ( indexes_in ))) range (:) = indexes_in (:) else allocate ( range ( size ( q ))) do ii = 1 , size ( q ) range ( ii ) = ii enddo endif num = 0 do ii = 1 , size ( range ) i = range ( ii ) if ( present ( set )) then if ( iand ( q ( i )% p % set , set ) == 0 ) cycle endif if ( present ( l )) then if ( l_of_sym ( q ( i )% p % l , \"pot\" ) /= l ) cycle endif if ( present ( j )) then ! A negative p%j signals the absence of j... if ( q ( i )% p % j < 0.0 ) cycle ! Perform integer comparison if ( nint ( 10 * q ( i )% p % j ) /= nint ( 10 * j )) cycle endif if ( present ( seq )) then if ( q ( i )% p % seq /= seq ) cycle endif num = num + 1 enddo allocate ( idx ( num )) num = 0 do ii = 1 , size ( range ) i = range ( ii ) if ( present ( set )) then if ( iand ( q ( i )% p % set , set ) == 0 ) cycle endif if ( present ( j )) then ! A negative p%j signals the absence of j... if ( q ( i )% p % j < 0.0 ) cycle ! Perform integer comparison if ( nint ( 10 * q ( i )% p % j ) /= nint ( 10 * j )) cycle endif if ( present ( l )) then if ( l_of_sym ( q ( i )% p % l , \"pot\" ) /= l ) cycle endif if ( present ( seq )) then if ( q ( i )% p % seq /= seq ) cycle endif num = num + 1 idx ( num ) = i enddo if ( present ( indexes )) then if ( allocated ( indexes )) deallocate ( indexes ) allocate ( indexes ( num )) indexes (:) = idx (:) endif if ( present ( number )) then number = num endif deallocate ( idx , range ) end subroutine ps_NonlocalProjectors_Filter","tags":"","loc":"proc/ps_nonlocalprojectors_filter.html"},{"title":"ps_Projector_Get – libPSML","text":"public subroutine ps_Projector_Get(ps, i, l, j, seq, set, ekb, eref, type, annotation, func) Arguments Type Intent Optional Attributes Name type( ps_t ), intent(in), target :: ps integer, intent(in) :: i integer, intent(out), optional :: l real(kind=dp), intent(out), optional :: j integer, intent(out), optional :: seq integer, intent(out), optional :: set real(kind=dp), intent(out), optional :: ekb real(kind=dp), intent(out), optional :: eref character(len=*), intent(out), optional :: type type(ps_annotation_t), intent(out), optional :: annotation type(ps_radfunc_t), intent(out), optional :: func Contents Source Code ps_Projector_Get Source Code subroutine ps_Projector_Get ( ps , i ,& l , j , seq , set , ekb , eref , type , annotation , func ) type ( ps_t ), intent ( in ), target :: ps integer , intent ( in ) :: i integer , intent ( out ), optional :: set integer , intent ( out ), optional :: l real ( dp ), intent ( out ), optional :: j integer , intent ( out ), optional :: seq real ( dp ), intent ( out ), optional :: ekb real ( dp ), intent ( out ), optional :: eref character ( len =* ), intent ( out ), optional :: type type ( ps_annotation_t ), intent ( out ), optional :: annotation type ( ps_radfunc_t ), intent ( out ), optional :: func type ( nl_table_t ), pointer :: q (:) q => ps % nl_table call check_index ( i , size ( q ), \"NL pot\" ) if ( present ( set )) then set = q ( i )% p % set endif if ( present ( l )) then l = l_of_sym ( q ( i )% p % l , \"NL pot\" ) endif if ( present ( seq )) then seq = q ( i )% p % seq endif if ( present ( j )) then if ( q ( i )% p % j < 0.0 ) then j = - 1.0_dp ! Maybe optional status flag raised? else j = q ( i )% p % j endif endif if ( present ( ekb )) then ekb = q ( i )% p % ekb endif if ( present ( eref )) then ! Will return a very large positive value if the attribute eref is not ! present in the file eref = q ( i )% p % eref endif if ( present ( type )) then type = q ( i )% p % type endif if ( present ( annotation )) then annotation = q ( i )% p % parent_group % annotation endif if ( present ( func )) then func = q ( i )% p % proj endif end subroutine ps_Projector_Get","tags":"","loc":"proc/ps_projector_get.html"},{"title":"check_index – libPSML","text":"private subroutine check_index(i, n, str) Arguments Type Intent Optional Attributes Name integer, intent(in) :: i integer, intent(in) :: n character(len=*), intent(in) :: str Contents Source Code check_index Source Code subroutine check_index ( i , n , str ) integer , intent ( in ) :: i , n character ( len =* ), intent ( in ) :: str call assert ( ( i <= n ), \"Index overflow in \" // trim ( str )) call assert ( ( i > 0 ), \"Non-positive index in \" // trim ( str )) end subroutine check_index","tags":"","loc":"proc/check_index.html"},{"title":"assert – libPSML","text":"private subroutine assert(cond, message) Arguments Type Intent Optional Attributes Name logical, intent(in) :: cond character(len=*) :: message Contents Source Code assert Source Code subroutine assert ( cond , message ) logical , intent ( in ) :: cond character ( len =* ) message if (. not . cond ) call die ( message ) end subroutine assert","tags":"","loc":"proc/assert.html"},{"title":"ps_Potential_Filter – libPSML","text":"public interface ps_Potential_Filter Contents Module Procedures ps_SemiLocalPotentials_Filter Module Procedures public subroutine ps_SemilocalPotentials_Filter (ps, indexes_in, l, j, n, set, indexes, number) Arguments Type Intent Optional Attributes Name type( ps_t ), intent(in), target :: ps integer, intent(in), optional :: indexes_in (:) integer, intent(in), optional :: l real(kind=dp), intent(in), optional :: j integer, intent(in), optional :: n integer, intent(in), optional :: set integer, intent(out), optional allocatable :: indexes (:) integer, intent(out), optional :: number","tags":"","loc":"interface/ps_potential_filter.html"},{"title":"ps_Projector_Filter – libPSML","text":"public interface ps_Projector_Filter Contents Module Procedures ps_NonLocalProjectors_Filter Module Procedures public subroutine ps_NonlocalProjectors_Filter (ps, indexes_in, l, j, seq, set, indexes, number) Arguments Type Intent Optional Attributes Name type( ps_t ), intent(in), target :: ps integer, intent(in), optional :: indexes_in (:) integer, intent(in), optional :: l real(kind=dp), intent(in), optional :: j integer, intent(in), optional :: seq integer, intent(in), optional :: set integer, intent(out), optional allocatable :: indexes (:) integer, intent(out), optional :: number","tags":"","loc":"interface/ps_projector_filter.html"},{"title":"ps_PseudoWf_Filter – libPSML","text":"public interface ps_PseudoWf_Filter Contents Module Procedures ps_PseudoWaveFunctions_Filter Module Procedures public subroutine ps_PseudoWaveFunctions_Filter (ps, indexes_in, l, j, n, set, indexes, number) Arguments Type Intent Optional Attributes Name type( ps_t ), intent(in), target :: ps integer, intent(in), optional :: indexes_in (:) integer, intent(in), optional :: l real(kind=dp), intent(in), optional :: j integer, intent(in), optional :: n integer, intent(in), optional :: set integer, intent(out), optional allocatable :: indexes (:) integer, intent(out), optional :: number","tags":"","loc":"interface/ps_pseudowf_filter.html"},{"title":"ps_DumpToPSMLFile – libPSML","text":"public subroutine ps_DumpToPSMLFile(ps, fname, indent) Uses xmlf90_wxml Arguments Type Intent Optional Attributes Name type( ps_t ), intent(in) :: ps character(len=*), intent(in) :: fname logical, intent(in), optional :: indent Contents Source Code ps_DumpToPSMLFile Source Code subroutine ps_DumpToPSMLFile ( ps , fname , indent ) use xmlf90_wxml type ( ps_t ), intent ( in ) :: ps character ( len =* ), intent ( in ) :: fname logical , intent ( in ), optional :: indent type ( xmlf_t ) :: xf call xml_OpenFile ( trim ( fname ), xf , indent ) call xml_AddXMLDeclaration ( xf , \"UTF-8\" ) call xml_NewElement ( xf , \"psml\" ) call my_add_attribute ( xf , \"version\" , trim ( ps % version )) call my_add_attribute ( xf , \"energy_unit\" , trim ( ps % energy_unit )) call my_add_attribute ( xf , \"length_unit\" , trim ( ps % length_unit )) call my_add_attribute ( xf , \"uuid\" , ps % uuid ) call my_add_attribute ( xf , \"xmlns\" , ps % namespace ) ! No top-level annotations in V1.1 !      call dump_annotation(xf,ps%annotation) call dump_provenance ( xf , ps % provenance ) call dump_pseudo_atom_spec ( xf , ps ) if ( initialized ( ps % global_grid )) then call dump_grid ( xf , ps % global_grid ) endif call dump_valence_charge ( xf , ps % valence_charge , ps % global_grid ) if ( trim ( ps % header % core_corrections ) == \"yes\" ) then call dump_core_charge ( xf , ps % core_charge , ps % global_grid ) endif call dump_semilocal_potentials ( xf , ps ) call dump_local_potential ( xf , ps ) call dump_nonlocal_projectors ( xf , ps ) call dump_pseudo_wavefunctions ( xf , ps ) call xml_EndElement ( xf , \"psml\" ) call xml_Close ( xf ) end subroutine ps_DumpToPSMLFile","tags":"","loc":"proc/ps_dumptopsmlfile.html"},{"title":"dump_provenance – libPSML","text":"private subroutine dump_provenance(xf, p) Uses xmlf90_wxml Arguments Type Intent Optional Attributes Name type(xmlf_t), intent(inout) :: xf type( provenance_t ), pointer :: p Contents Source Code dump_provenance Source Code subroutine dump_provenance ( xf , p ) use xmlf90_wxml type ( xmlf_t ), intent ( inout ) :: xf type ( provenance_t ), pointer :: p integer :: depth type ( provenance_t ), pointer :: q depth = 0 q => p do while ( associated ( q )) depth = depth + 1 q => q % next enddo do while ( associated ( p )) call xml_NewElement ( xf , \"provenance\" ) call my_add_attribute ( xf , \"record-number\" , str ( p % record_number )) call my_add_attribute ( xf , \"creator\" , trim ( p % creator )) call my_add_attribute ( xf , \"date\" , trim ( p % date )) call dump_annotation ( xf , p % annotation ) if ( len ( p % input_file % buffer ) > 0 ) then call xml_NewElement ( xf , \"input-file\" ) call my_add_attribute ( xf , \"name\" , trim ( p % input_file % name )) call xml_AddCDataSection ( xf , p % input_file % buffer , & line_feed = . true .) call xml_EndElement ( xf , \"input-file\" ) endif call xml_EndElement ( xf , \"provenance\" ) p => p % next end do end subroutine dump_provenance","tags":"","loc":"proc/dump_provenance.html"},{"title":"dump_xc_info – libPSML","text":"private subroutine dump_xc_info(xf, p) Uses xmlf90_wxml Arguments Type Intent Optional Attributes Name type(xmlf_t), intent(inout) :: xf type( xc_t ), intent(in) :: p Contents Source Code dump_xc_info Source Code subroutine dump_xc_info ( xf , p ) use xmlf90_wxml type ( xmlf_t ), intent ( inout ) :: xf type ( xc_t ), intent ( in ) :: p integer :: i call xml_NewElement ( xf , \"exchange-correlation\" ) call dump_annotation ( xf , p % annotation ) call xml_NewElement ( xf , \"libxc-info\" ) call my_add_attribute ( xf , \"number-of-functionals\" , str ( p % n_functs_libxc )) do i = 1 , p % n_functs_libxc call xml_NewElement ( xf , \"functional\" ) call my_add_attribute ( xf , \"name\" , trim ( p % libxc_name ( i ))) if ( trim ( p % libxc_type ( i )) /= \"UNKNOWN\" ) then call my_add_attribute ( xf , \"type\" , trim ( p % libxc_type ( i ))) endif call my_add_attribute ( xf , \"id\" , str ( p % libxc_id ( i ))) if ( p % libxc_weight ( i ) /= 1.0_dp ) then call my_add_attribute ( xf , \"weight\" , str ( p % libxc_weight ( i ))) endif call xml_EndElement ( xf , \"functional\" ) enddo call xml_EndElement ( xf , \"libxc-info\" ) call xml_EndElement ( xf , \"exchange-correlation\" ) end subroutine dump_xc_info","tags":"","loc":"proc/dump_xc_info.html"},{"title":"dump_config_val – libPSML","text":"private subroutine dump_config_val(xf, p) Uses xmlf90_wxml Arguments Type Intent Optional Attributes Name type(xmlf_t), intent(inout) :: xf type( config_val_t ), intent(in) :: p Contents Source Code dump_config_val Source Code subroutine dump_config_val ( xf , p ) use xmlf90_wxml type ( xmlf_t ), intent ( inout ) :: xf type ( config_val_t ), intent ( in ) :: p integer :: i call xml_NewElement ( xf , \"valence-configuration\" ) call my_add_attribute ( xf , \"total-valence-charge\" , str ( p % total_charge )) call dump_annotation ( xf , p % annotation ) do i = 1 , p % nshells call xml_NewElement ( xf , \"shell\" ) call my_add_attribute ( xf , \"n\" , str ( p % n ( i ))) call my_add_attribute ( xf , \"l\" , p % l ( i )) call my_add_attribute ( xf , \"occupation\" , str ( p % occ ( i ))) if (( p % occ_up ( i ) + p % occ_down ( i )) /= 0.0_dp ) then call my_add_attribute ( xf , \"occupation-down\" , str ( p % occ_down ( i ))) call my_add_attribute ( xf , \"occupation-up\" , str ( p % occ_up ( i ))) endif call xml_EndElement ( xf , \"shell\" ) enddo call xml_EndElement ( xf , \"valence-configuration\" ) end subroutine dump_config_val","tags":"","loc":"proc/dump_config_val.html"},{"title":"dump_pseudo_atom_spec – libPSML","text":"private subroutine dump_pseudo_atom_spec(xf, ps) Uses xmlf90_wxml Arguments Type Intent Optional Attributes Name type(xmlf_t), intent(inout) :: xf type( ps_t ), intent(in), target :: ps Contents Source Code dump_pseudo_atom_spec Source Code subroutine dump_pseudo_atom_spec ( xf , ps ) use xmlf90_wxml type ( xmlf_t ), intent ( inout ) :: xf type ( ps_t ), intent ( in ), target :: ps type ( header_t ), pointer :: h h => ps % header call xml_NewElement ( xf , \"pseudo-atom-spec\" ) call my_add_attribute ( xf , \"atomic-label\" , trim ( h % atomic_label )) call my_add_attribute ( xf , \"atomic-number\" , str ( h % z )) call my_add_attribute ( xf , \"z-pseudo\" , str ( h % zpseudo )) call my_add_attribute ( xf , \"flavor\" , trim ( h % flavor )) call my_add_attribute ( xf , \"relativity\" , trim ( h % relativity )) if ( h % polarized ) then call my_add_attribute ( xf , \"spin-dft\" , \"yes\" ) else call my_add_attribute ( xf , \"spin-dft\" , \"no\" ) endif call my_add_attribute ( xf , \"core-corrections\" , trim ( h % core_corrections )) call dump_annotation ( xf , h % annotation ) call dump_xc_info ( xf , ps % xc_info ) call dump_config_val ( xf , ps % config_val ) call xml_EndElement ( xf , \"pseudo-atom-spec\" ) end subroutine dump_pseudo_atom_spec","tags":"","loc":"proc/dump_pseudo_atom_spec.html"},{"title":"dump_radfunc – libPSML","text":"private subroutine dump_radfunc(xf, rf, parent_grid) Uses xmlf90_wxml Arguments Type Intent Optional Attributes Name type(xmlf_t), intent(inout) :: xf type( radfunc_t ), intent(in) :: rf type(Grid_t) :: parent_grid Contents Source Code dump_radfunc Source Code subroutine dump_radfunc ( xf , rf , parent_grid ) use xmlf90_wxml type ( xmlf_t ), intent ( inout ) :: xf type ( radfunc_t ), intent ( in ) :: rf type ( Grid_t ) :: parent_grid ! Only one level for now if (. not . initialized ( rf % grid )) return call xml_NewElement ( xf , \"radfunc\" ) if ( same ( rf % grid , parent_grid )) then ! do nothing else call dump_grid ( xf , rf % grid ) endif call xml_NewElement ( xf , \"data\" ) ! Cover the case in which the data uses only an ! initial section of the grid if ( size ( rf % data ) < sizeGrid ( rf % grid )) then call my_add_attribute ( xf , \"npts\" , str ( size ( rf % data ))) endif call xml_AddArray ( xf , rf % data (:)) call xml_EndElement ( xf , \"data\" ) call xml_EndElement ( xf , \"radfunc\" ) end subroutine dump_radfunc","tags":"","loc":"proc/dump_radfunc.html"},{"title":"dump_valence_charge – libPSML","text":"private subroutine dump_valence_charge(xf, val, parent_grid) Uses xmlf90_wxml Arguments Type Intent Optional Attributes Name type(xmlf_t), intent(inout) :: xf type( valence_charge_t ), intent(in) :: val type(Grid_t) :: parent_grid Contents Source Code dump_valence_charge Source Code subroutine dump_valence_charge ( xf , val , parent_grid ) use xmlf90_wxml type ( xmlf_t ), intent ( inout ) :: xf type ( valence_charge_t ), intent ( in ) :: val type ( Grid_t ) :: parent_grid call xml_NewElement ( xf , \"valence-charge\" ) call my_add_attribute ( xf , \"total-charge\" , str ( val % total_charge )) call dump_annotation ( xf , val % annotation ) call dump_radfunc ( xf , val % rho_val , parent_grid ) call xml_EndElement ( xf , \"valence-charge\" ) end subroutine dump_valence_charge","tags":"","loc":"proc/dump_valence_charge.html"},{"title":"dump_core_charge – libPSML","text":"private subroutine dump_core_charge(xf, core, parent_grid) Uses xmlf90_wxml Arguments Type Intent Optional Attributes Name type(xmlf_t), intent(inout) :: xf type( core_charge_t ), intent(in) :: core type(Grid_t) :: parent_grid Contents Source Code dump_core_charge Source Code subroutine dump_core_charge ( xf , core , parent_grid ) use xmlf90_wxml type ( xmlf_t ), intent ( inout ) :: xf type ( core_charge_t ), intent ( in ) :: core type ( Grid_t ) :: parent_grid call xml_NewElement ( xf , \"pseudocore-charge\" ) if ( core % rcore >= 0.0_dp ) then call my_add_attribute ( xf , \"matching-radius\" , str ( core % rcore )) endif if ( core % n_cont_derivs >= 0 ) then call my_add_attribute ( xf , \"number-of-continuous-derivatives\" , str ( core % n_cont_derivs )) endif call dump_annotation ( xf , core % annotation ) call dump_radfunc ( xf , core % rho_core , parent_grid ) call xml_EndElement ( xf , \"pseudocore-charge\" ) end subroutine dump_core_charge","tags":"","loc":"proc/dump_core_charge.html"},{"title":"dump_semilocal_potentials – libPSML","text":"private subroutine dump_semilocal_potentials(xf, ps) Uses xmlf90_wxml Arguments Type Intent Optional Attributes Name type(xmlf_t), intent(inout) :: xf type( ps_t ), intent(in), target :: ps Contents Source Code dump_semilocal_potentials Source Code subroutine dump_semilocal_potentials ( xf , ps ) use xmlf90_wxml type ( xmlf_t ), intent ( inout ) :: xf type ( ps_t ), intent ( in ), target :: ps type ( semilocal_t ), pointer :: slp type ( slps_t ), pointer :: slvp type ( Grid_t ) :: parent_grid integer :: i , j , set slp => ps % semilocal do while ( associated ( slp )) set = slp % set call xml_NewElement ( xf , \"semilocal-potentials\" ) if ( set /= SET_NULL ) then ! Group set was specified call my_add_attribute ( xf , \"set\" , str_of_set ( set )) else call die ( \"Set not specified in SemiLocalPotentials block\" ) endif call dump_annotation ( xf , slp % annotation ) if ( initialized ( slp % grid )) then parent_grid = slp % grid call dump_grid ( xf , slp % grid ) else parent_grid = ps % global_grid endif slvp => slp % pot do while ( associated ( slvp )) call xml_NewElement ( xf , \"slps\" ) call my_add_attribute ( xf , \"n\" , str ( slvp % n )) call my_add_attribute ( xf , \"l\" , slvp % l ) call my_add_attribute ( xf , \"rc\" , str ( slvp % rc )) ! If eref has a physical value, output it if ( slvp % eref < 0.1 * huge ( 1.0_dp )) then call my_add_attribute ( xf , \"eref\" , str ( slvp % eref )) endif call my_add_attribute ( xf , \"flavor\" , slvp % flavor ) if ( set == SET_LJ ) then call my_add_attribute ( xf , \"j\" , str ( slvp % j , format = \"(f3.1)\" )) endif call dump_radfunc ( xf , slvp % V , parent_grid ) call xml_EndElement ( xf , \"slps\" ) slvp => slvp % next enddo call xml_EndElement ( xf , \"semilocal-potentials\" ) slp => slp % next enddo call delete ( parent_grid ) end subroutine dump_semilocal_potentials","tags":"","loc":"proc/dump_semilocal_potentials.html"},{"title":"dump_local_potential – libPSML","text":"private subroutine dump_local_potential(xf, ps) Uses xmlf90_wxml Arguments Type Intent Optional Attributes Name type(xmlf_t), intent(inout) :: xf type( ps_t ), intent(in), target :: ps Contents Source Code dump_local_potential Source Code subroutine dump_local_potential ( xf , ps ) use xmlf90_wxml type ( xmlf_t ), intent ( inout ) :: xf type ( ps_t ), intent ( in ), target :: ps type ( local_t ), pointer :: lop type ( Grid_t ) :: parent_grid logical :: has_vlocal , has_local_charge lop => ps % local has_vlocal = associated ( lop % Vlocal % data ) has_local_charge = associated ( lop % Chlocal % data ) if ( has_vlocal ) then call xml_NewElement ( xf , \"local-potential\" ) call my_add_attribute ( xf , \"type\" , lop % vlocal_type ) call dump_annotation ( xf , lop % annotation ) ! No processing of grids here if ( initialized ( lop % grid )) then parent_grid = lop % grid call dump_grid ( xf , lop % grid ) else parent_grid = ps % global_grid endif call dump_radfunc ( xf , lop % Vlocal , parent_grid ) if ( has_local_charge ) then call xml_NewElement ( xf , \"local-charge\" ) call dump_radfunc ( xf , lop % chlocal , parent_grid ) call xml_EndElement ( xf , \"local-charge\" ) endif call xml_EndElement ( xf , \"local-potential\" ) call delete ( parent_grid ) endif end subroutine dump_local_potential","tags":"","loc":"proc/dump_local_potential.html"},{"title":"dump_nonlocal_projectors – libPSML","text":"private subroutine dump_nonlocal_projectors(xf, ps) Uses xmlf90_wxml Arguments Type Intent Optional Attributes Name type(xmlf_t), intent(inout) :: xf type( ps_t ), intent(in), target :: ps Contents Source Code dump_nonlocal_projectors Source Code subroutine dump_nonlocal_projectors ( xf , ps ) use xmlf90_wxml type ( xmlf_t ), intent ( inout ) :: xf type ( ps_t ), intent ( in ), target :: ps type ( nonlocal_t ), pointer :: nlp type ( nlpj_t ), pointer :: nlpp type ( Grid_t ) :: parent_grid integer :: set nlp => ps % nonlocal do while ( associated ( nlp )) set = nlp % set call xml_NewElement ( xf , \"nonlocal-projectors\" ) if ( set /= SET_NULL ) then ! Group set was specified call my_add_attribute ( xf , \"set\" , str_of_set ( set )) else call die ( \"Set not specified in NonLocalProjectors block\" ) endif call dump_annotation ( xf , nlp % annotation ) if ( initialized ( nlp % grid )) then parent_grid = nlp % grid call dump_grid ( xf , nlp % grid ) else parent_grid = ps % global_grid endif nlpp => nlp % proj do while ( associated ( nlpp )) call xml_NewElement ( xf , \"proj\" ) call my_add_attribute ( xf , \"l\" , nlpp % l ) if ( set == SET_LJ ) then call my_add_attribute ( xf , \"j\" , str ( nlpp % j , format = \"(f3.1)\" )) endif call my_add_attribute ( xf , \"seq\" , str ( nlpp % seq )) call my_add_attribute ( xf , \"ekb\" , str ( nlpp % ekb )) ! If eref has a physical value, output it if ( nlpp % eref < 0.1 * huge ( 1.0_dp )) then call my_add_attribute ( xf , \"eref\" , str ( nlpp % eref )) endif call my_add_attribute ( xf , \"type\" , nlpp % type ) call dump_radfunc ( xf , nlpp % proj , parent_grid ) call xml_EndElement ( xf , \"proj\" ) nlpp => nlpp % next enddo call xml_EndElement ( xf , \"nonlocal-projectors\" ) nlp => nlp % next enddo call delete ( parent_grid ) end subroutine dump_nonlocal_projectors","tags":"","loc":"proc/dump_nonlocal_projectors.html"},{"title":"dump_pseudo_wavefunctions – libPSML","text":"private subroutine dump_pseudo_wavefunctions(xf, ps) Uses xmlf90_wxml Arguments Type Intent Optional Attributes Name type(xmlf_t), intent(inout) :: xf type( ps_t ), intent(in), target :: ps Contents Source Code dump_pseudo_wavefunctions Source Code subroutine dump_pseudo_wavefunctions ( xf , ps ) use xmlf90_wxml type ( xmlf_t ), intent ( inout ) :: xf type ( ps_t ), intent ( in ), target :: ps type ( wfns_t ), pointer :: wfp type ( wf_t ), pointer :: wfpp type ( Grid_t ) :: parent_grid integer :: set wfp => ps % wavefunctions do while ( associated ( wfp )) set = wfp % set call xml_NewElement ( xf , \"pseudo-wave-functions\" ) if ( set /= SET_NULL ) then ! Group set was specified call my_add_attribute ( xf , \"set\" , str_of_set ( set )) else call die ( \"Set not specified in Wavefunctions block\" ) endif !     if (wfp%type /= \"\") then !        call my_add_attribute(xf,\"type\",wfp%type) !     endif call dump_annotation ( xf , wfp % annotation ) if ( initialized ( wfp % grid )) then parent_grid = wfp % grid call dump_grid ( xf , wfp % grid ) else parent_grid = ps % global_grid endif wfpp => wfp % wf do while ( associated ( wfpp )) call xml_NewElement ( xf , \"pswf\" ) call my_add_attribute ( xf , \"n\" , str ( wfpp % n )) call my_add_attribute ( xf , \"l\" , wfpp % l ) if ( set == SET_LJ ) then call my_add_attribute ( xf , \"j\" , str ( wfpp % j , format = \"(f3.1)\" )) endif ! If energy_level has a physical value, output it if ( wfpp % energy_level < 0.1 * huge ( 1.0_dp )) then call my_add_attribute ( xf , \"energy_level\" , str ( wfpp % energy_level )) endif call dump_radfunc ( xf , wfpp % Phi , parent_grid ) call xml_EndElement ( xf , \"pswf\" ) wfpp => wfpp % next enddo call xml_EndElement ( xf , \"pseudo-wave-functions\" ) wfp => wfp % next enddo call delete ( parent_grid ) end subroutine dump_pseudo_wavefunctions","tags":"","loc":"proc/dump_pseudo_wavefunctions.html"},{"title":"dump_grid – libPSML","text":"private subroutine dump_grid(xf, agrid) Uses xmlf90_wxml Arguments Type Intent Optional Attributes Name type(xmlf_t), intent(inout) :: xf type(Grid_t), intent(in) :: agrid Contents Source Code dump_grid Source Code subroutine dump_grid ( xf , agrid ) use xmlf90_wxml type ( xmlf_t ), intent ( inout ) :: xf type ( Grid_t ), intent ( in ) :: agrid if (. not . initialized ( agrid )) return call xml_NewElement ( xf , \"grid\" ) call my_add_attribute ( xf , \"npts\" , str ( sizeGrid ( agrid ))) call dump_annotation ( xf , annotationGrid ( agrid )) call xml_NewElement ( xf , \"grid-data\" ) call xml_AddArray ( xf , valGrid ( agrid )) call xml_EndElement ( xf , \"grid-data\" ) call xml_EndElement ( xf , \"grid\" ) end subroutine dump_grid","tags":"","loc":"proc/dump_grid.html"},{"title":"dump_annotation – libPSML","text":"private subroutine dump_annotation(xf, annotation) Uses xmlf90_wxml assoc_list assoc_list assoc_list assoc_list Arguments Type Intent Optional Attributes Name type(xmlf_t), intent(inout) :: xf type(ps_annotation_t), intent(in) :: annotation Contents Source Code dump_annotation Source Code subroutine dump_annotation ( xf , annotation ) use xmlf90_wxml use assoc_list , only : ps_annotation_t => assoc_list_t use assoc_list , only : nitems_annotation => assoc_list_nitems use assoc_list , only : get_annotation_key => assoc_list_get_key use assoc_list , only : get_annotation_value => assoc_list_get_value type ( xmlf_t ), intent ( inout ) :: xf type ( ps_annotation_t ), intent ( in ) :: annotation integer :: n_items , i , stat character ( len = 256 ) :: key , val n_items = nitems_annotation ( annotation ) if ( n_items > 0 ) then call xml_NewElement ( xf , \"annotation\" ) do i = 1 , n_items call get_annotation_key ( annotation , i , key , stat ) call get_annotation_value ( annotation , i , val , stat ) call my_add_attribute ( xf , trim ( key ), trim ( val )) enddo call xml_EndElement ( xf , \"annotation\" ) endif end subroutine dump_annotation","tags":"","loc":"proc/dump_annotation.html"},{"title":"my_add_attribute – libPSML","text":"private subroutine my_add_attribute(xf, name, value) Uses xmlf90_wxml Arguments Type Intent Optional Attributes Name type(xmlf_t), intent(inout) :: xf character(len=*), intent(in) :: name character(len=*), intent(in) :: value Contents Source Code my_add_attribute Source Code subroutine my_add_attribute ( xf , name , value ) use xmlf90_wxml type ( xmlf_t ), intent ( inout ) :: xf character ( len =* ), intent ( in ) :: name character ( len =* ), intent ( in ) :: value call xml_AddAttribute ( xf , name , trim ( value )) end subroutine my_add_attribute","tags":"","loc":"proc/my_add_attribute.html"},{"title":"initialized_ – libPSML","text":"private pure function initialized_(this) result(init) Arguments Type Intent Optional Attributes Name type( Grid ), intent(in) :: this Return Value logical Contents None","tags":"","loc":"proc/initialized_.html"},{"title":"same_ – libPSML","text":"private pure function same_(this1, this2) result(same) Arguments Type Intent Optional Attributes Name type( Grid ), intent(in) :: this1 type( Grid ), intent(in) :: this2 Return Value logical Contents None","tags":"","loc":"proc/same_.html"},{"title":"refcount_ – libPSML","text":"private function refcount_(this) result(count) Arguments Type Intent Optional Attributes Name type( Grid ), intent(in) :: this Return Value integer Contents None","tags":"","loc":"proc/refcount_.html"},{"title":"id_ – libPSML","text":"private function id_(this) result(str) Arguments Type Intent Optional Attributes Name type( Grid ), intent(in) :: this Return Value character(len=36) Contents None","tags":"","loc":"proc/id_.html"},{"title":"name_ – libPSML","text":"private function name_(this) result(str) Arguments Type Intent Optional Attributes Name type( Grid ), intent(in) :: this Return Value character(len=len_trim(this%data%name)) Contents None","tags":"","loc":"proc/name_.html"},{"title":"valGrid – libPSML","text":"public function valGrid(this) result(p) Arguments Type Intent Optional Attributes Name type( Grid ), intent(in) :: this Return Value real(kind=dp),\n  pointer,(:) Contents Source Code valGrid Source Code function valGrid ( this ) result ( p ) type ( Grid ), intent ( in ) :: this real ( dp ), pointer :: p (:) nullify ( p ) p => this % data % grid_data end function valGrid","tags":"","loc":"proc/valgrid.html"},{"title":"annotationGrid – libPSML","text":"public function annotationGrid(this) result(p) Arguments Type Intent Optional Attributes Name type( Grid ), intent(in) :: this Return Value type(ps_annotation_t),\n  pointer Contents Source Code annotationGrid Source Code function annotationGrid ( this ) result ( p ) type ( Grid ), intent ( in ) :: this type ( ps_annotation_t ) , pointer :: p nullify ( p ) p => this % data % annotation end function annotationGrid","tags":"","loc":"proc/annotationgrid.html"},{"title":"sizeGrid – libPSML","text":"public function sizeGrid(this) result(n) Arguments Type Intent Optional Attributes Name type( Grid ), intent(in) :: this Return Value integer Contents Source Code sizeGrid Source Code function sizeGrid ( this ) result ( n ) type ( Grid ), intent ( in ) :: this integer :: n if (. not . initialized ( this )) then n = 0 else n = size ( this % data % grid_data ) endif end function sizeGrid","tags":"","loc":"proc/sizegrid.html"},{"title":"init_ – libPSML","text":"private subroutine init_(this) Arguments Type Intent Optional Attributes Name type( Grid ), intent(inout) :: this Contents None","tags":"","loc":"proc/init_.html"},{"title":"delete_ – libPSML","text":"private subroutine delete_(this) Arguments Type Intent Optional Attributes Name type( Grid ), intent(inout) :: this Contents None","tags":"","loc":"proc/delete_.html"},{"title":"assign_ – libPSML","text":"private subroutine assign_(this, other) Arguments Type Intent Optional Attributes Name type( Grid ), intent(inout) :: this type( Grid ), intent(in) :: other Contents None","tags":"","loc":"proc/assign_.html"},{"title":"tag_new_object – libPSML","text":"private subroutine tag_new_object(this) Arguments Type Intent Optional Attributes Name type( Grid ), intent(inout) :: this Contents None","tags":"","loc":"proc/tag_new_object.html"},{"title":"delete_Data – libPSML","text":"private subroutine delete_Data(gd) Arguments Type Intent Optional Attributes Name type( Grid_ ) :: gd Contents Source Code delete_Data Source Code subroutine delete_Data ( gd ) type ( Grid_ ) :: gd if ( associated ( gd % grid_data )) then deallocate ( gd % grid_data ) gd % grid_data => null () endif call ps_clean_annotation ( gd % annotation ) end subroutine delete_Data","tags":"","loc":"proc/delete_data.html"},{"title":"newGrid – libPSML","text":"public subroutine newGrid(this, n, name) Arguments Type Intent Optional Attributes Name type( Grid ), intent(inout) :: this integer, intent(in) :: n character(len=*), intent(in), optional :: name Contents Source Code newGrid Source Code subroutine newGrid ( this , n , name ) type ( Grid ), intent ( inout ) :: this integer , intent ( in ) :: n character ( len =* ), intent ( in ), optional :: name integer :: stat ! We release the previous incarnation ! This means that we relinquish access to the previous ! memory location. It will be deallocated when nobody ! else is using it. call init ( this ) if ( present ( name )) then this % data % name = trim ( name ) else this % data % name = \"(Grid from n)\" endif allocate ( this % data % grid_data ( n )) call tag_new_object ( this ) end subroutine newGrid","tags":"","loc":"proc/newgrid.html"},{"title":"printGrid – libPSML","text":"private subroutine printGrid(this) Arguments Type Intent Optional Attributes Name type( Grid ), intent(in) :: this Contents Source Code printGrid Source Code subroutine printGrid ( this ) type ( Grid ), intent ( in ) :: this integer :: n , m if (. not . associated ( this % data )) then print \"(a)\" , \"Grid Not Associated\" RETURN endif n = size ( this % data % grid_data ) print \"(a,i0,a,i0,a,i0,a)\" , \"  <grid:\" // trim ( this % data % name ) // & \" n=\" , n , & \", refcount: \" , refcount ( this ), \">\" end subroutine printGrid","tags":"","loc":"proc/printgrid.html"},{"title":"print_type – libPSML","text":"public interface print_type Contents Module Procedures printGrid Module Procedures private subroutine printGrid (this) Arguments Type Intent Optional Attributes Name type( Grid ), intent(in) :: this","tags":"","loc":"interface/print_type.html"},{"title":"assignment(=) – libPSML","text":"public interface assignment(=) Contents Module Procedures assign_ Module Procedures private subroutine assign_ (this, other) Arguments Type Intent Optional Attributes Name type( Grid ), intent(inout) :: this type( Grid ), intent(in) :: other","tags":"","loc":"interface/assignment(=).html"},{"title":"init – libPSML","text":"public interface init Contents Module Procedures init_ Module Procedures private subroutine init_ (this) Arguments Type Intent Optional Attributes Name type( Grid ), intent(inout) :: this","tags":"","loc":"interface/init.html"},{"title":"delete – libPSML","text":"public interface delete Contents Module Procedures delete_ Module Procedures private subroutine delete_ (this) Arguments Type Intent Optional Attributes Name type( Grid ), intent(inout) :: this","tags":"","loc":"interface/delete.html"},{"title":"refcount – libPSML","text":"public interface refcount Contents Module Procedures refcount_ Module Procedures private function refcount_ (this) result(count) Arguments Type Intent Optional Attributes Name type( Grid ), intent(in) :: this Return Value integer","tags":"","loc":"interface/refcount.html"},{"title":"id – libPSML","text":"public interface id Contents Module Procedures id_ Module Procedures private function id_ (this) result(str) Arguments Type Intent Optional Attributes Name type( Grid ), intent(in) :: this Return Value character(len=36)","tags":"","loc":"interface/id.html"},{"title":"name – libPSML","text":"public interface name Contents Module Procedures name_ Module Procedures private function name_ (this) result(str) Arguments Type Intent Optional Attributes Name type( Grid ), intent(in) :: this Return Value character(len=len_trim(this%data%name))","tags":"","loc":"interface/name.html"},{"title":"initialized – libPSML","text":"public interface initialized Contents Module Procedures initialized_ Module Procedures private pure function initialized_ (this) result(init) Arguments Type Intent Optional Attributes Name type( Grid ), intent(in) :: this Return Value logical","tags":"","loc":"interface/initialized.html"},{"title":"same – libPSML","text":"public interface same Contents Module Procedures same_ Module Procedures private pure function same_ (this1, this2) result(same) Arguments Type Intent Optional Attributes Name type( Grid ), intent(in) :: this1 type( Grid ), intent(in) :: this2 Return Value logical","tags":"","loc":"interface/same.html"},{"title":"psml_die – libPSML","text":"interface private subroutine psml_die(str) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: str","tags":"","loc":"interface/psml_die.html"},{"title":"assoc_list_nitems – libPSML","text":"public function assoc_list_nitems(a) result(n) Arguments Type Intent Optional Attributes Name type( assoc_list_t ), intent(in) :: a Return Value integer Contents Source Code assoc_list_nitems Source Code function assoc_list_nitems ( a ) result ( n ) type ( assoc_list_t ), intent ( in ) :: a integer :: n n = a % nitems end function assoc_list_nitems","tags":"","loc":"proc/assoc_list_nitems.html"},{"title":"assoc_list_init – libPSML","text":"public subroutine assoc_list_init(a, n, stat) Arguments Type Intent Optional Attributes Name type( assoc_list_t ), intent(inout) :: a integer, intent(in) :: n integer, intent(out) :: stat Contents Source Code assoc_list_init Source Code subroutine assoc_list_init ( a , n , stat ) type ( assoc_list_t ), intent ( inout ) :: a integer , intent ( in ) :: n integer , intent ( out ) :: stat if ( allocated ( a % key )) then deallocate ( a % key ) endif if ( allocated ( a % value )) then deallocate ( a % value ) endif a % nslots = n a % nitems = 0 allocate ( a % key ( n ), a % value ( n ), stat = stat ) end subroutine assoc_list_init","tags":"","loc":"proc/assoc_list_init.html"},{"title":"assoc_list_reset – libPSML","text":"public subroutine assoc_list_reset(a) Arguments Type Intent Optional Attributes Name type( assoc_list_t ), intent(inout) :: a Contents Source Code assoc_list_reset Source Code subroutine assoc_list_reset ( a ) type ( assoc_list_t ), intent ( inout ) :: a if ( allocated ( a % key )) then deallocate ( a % key ) endif if ( allocated ( a % value )) then deallocate ( a % value ) endif a % nslots = 0 a % nitems = 0 end subroutine assoc_list_reset","tags":"","loc":"proc/assoc_list_reset.html"},{"title":"assoc_list_insert – libPSML","text":"public subroutine assoc_list_insert(a, key, value, stat) Arguments Type Intent Optional Attributes Name type( assoc_list_t ), intent(inout) :: a character(len=*), intent(in) :: key character(len=*), intent(in) :: value integer, intent(out) :: stat Contents Source Code assoc_list_insert Source Code subroutine assoc_list_insert ( a , key , value , stat ) type ( assoc_list_t ), intent ( inout ) :: a character ( len =* ), intent ( in ) :: key , value integer , intent ( out ) :: stat integer :: i character ( len = 1000 ), allocatable :: b (:) if (. not . allocated ( a % key )) then call assoc_list_init ( a , 4 , stat ) if ( stat /= 0 ) return endif ! Replace if key exists already do i = 1 , a % nitems if ( a % key ( i ) == key ) then a % value ( i ) = value stat = 0 return endif enddo ! ! Add at the end a % nitems = a % nitems + 1 if ( a % nitems > a % nslots ) then ! Enlarge a%data by 4 slots ! allocate ( b ( a % nslots )) ! b = a % key deallocate ( a % key ) allocate ( a % key ( a % nslots + 4 )) a % key ( 1 : a % nslots ) = b ! b = a % value deallocate ( a % value ) allocate ( a % value ( a % nslots + 4 )) a % value ( 1 : a % nslots ) = b deallocate ( b ) ! a % nslots = size ( a % key ) endif i = a % nitems a % key ( i ) = key a % value ( i ) = value stat = 0 end subroutine assoc_list_insert","tags":"","loc":"proc/assoc_list_insert.html"},{"title":"assoc_list_get_key – libPSML","text":"public subroutine assoc_list_get_key(a, i, key, stat) Arguments Type Intent Optional Attributes Name type( assoc_list_t ), intent(in) :: a integer, intent(in) :: i character(len=*), intent(out) :: key integer, intent(out) :: stat Contents Source Code assoc_list_get_key Source Code subroutine assoc_list_get_key ( a , i , key , stat ) type ( assoc_list_t ), intent ( in ) :: a integer , intent ( in ) :: i character ( len =* ), intent ( out ) :: key integer , intent ( out ) :: stat if ( i > a % nitems ) then stat = - 1 return endif key = a % key ( i ) stat = 0 end subroutine assoc_list_get_key","tags":"","loc":"proc/assoc_list_get_key.html"},{"title":"assoc_list_get_value_of_key – libPSML","text":"public subroutine assoc_list_get_value_of_key(a, key, value, stat) Arguments Type Intent Optional Attributes Name type( assoc_list_t ), intent(in) :: a character(len=*), intent(in) :: key character(len=*), intent(out) :: value integer, intent(out) :: stat Contents Source Code assoc_list_get_value_of_key Source Code subroutine assoc_list_get_value_of_key ( a , key , value , stat ) type ( assoc_list_t ), intent ( in ) :: a character ( len =* ), intent ( in ) :: key character ( len =* ), intent ( out ) :: value integer , intent ( out ) :: stat integer :: i do i = 1 , a % nitems if ( a % key ( i ) == key ) then value = a % value ( i ) stat = 0 return endif enddo stat = - 1 end subroutine assoc_list_get_value_of_key","tags":"","loc":"proc/assoc_list_get_value_of_key.html"},{"title":"assoc_list_get_value_by_index – libPSML","text":"public subroutine assoc_list_get_value_by_index(a, i, value, stat) Arguments Type Intent Optional Attributes Name type( assoc_list_t ), intent(in) :: a integer, intent(in) :: i character(len=*), intent(out) :: value integer, intent(out) :: stat Contents Source Code assoc_list_get_value_by_index Source Code subroutine assoc_list_get_value_by_index ( a , i , value , stat ) type ( assoc_list_t ), intent ( in ) :: a integer , intent ( in ) :: i character ( len =* ), intent ( out ) :: value integer , intent ( out ) :: stat if ( i <= a % nitems ) then value = a % value ( i ) stat = 0 else stat = - 1 value = \"\" endif end subroutine assoc_list_get_value_by_index","tags":"","loc":"proc/assoc_list_get_value_by_index.html"},{"title":"assoc_list_print – libPSML","text":"public subroutine assoc_list_print(a) Arguments Type Intent Optional Attributes Name type( assoc_list_t ), intent(in) :: a Contents Source Code assoc_list_print Source Code subroutine assoc_list_print ( a ) type ( assoc_list_t ), intent ( in ) :: a integer :: i if ( a % nitems > 0 ) then print \"(a)\" , \"---------------------\" do i = 1 , a % nitems print \"(3x,a,a,a)\" , trim ( a % key ( i )), \" : \" , trim ( a % value ( i )) enddo print \"(a)\" , \"---------------------\" endif end subroutine assoc_list_print","tags":"","loc":"proc/assoc_list_print.html"},{"title":"assoc_list_get_value – libPSML","text":"public interface assoc_list_get_value Contents Module Procedures assoc_list_get_value_by_index assoc_list_get_value_of_key Module Procedures public subroutine assoc_list_get_value_by_index (a, i, value, stat) Arguments Type Intent Optional Attributes Name type( assoc_list_t ), intent(in) :: a integer, intent(in) :: i character(len=*), intent(out) :: value integer, intent(out) :: stat public subroutine assoc_list_get_value_of_key (a, key, value, stat) Arguments Type Intent Optional Attributes Name type( assoc_list_t ), intent(in) :: a character(len=*), intent(in) :: key character(len=*), intent(out) :: value integer, intent(out) :: stat","tags":"","loc":"interface/assoc_list_get_value.html"},{"title":"setcode_of_string – libPSML","text":"public function setcode_of_string(str) result(code) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: str Return Value integer Contents Source Code setcode_of_string Source Code function setcode_of_string ( str ) result ( code ) character ( len =* ), intent ( in ) :: str integer :: code select case ( trim ( str )) case ( \"non_relativistic\" ) code = SET_NONREL case ( \"scalar_relativistic\" ) code = SET_SREL case ( \"spin_orbit\" ) code = SET_SO case ( \"lj\" ) code = SET_LJ case ( \"spin_up\" ) code = SET_UP case ( \"spin_down\" ) code = SET_DOWN case ( \"spin_average\" ) code = SET_SPINAVE case ( \"spin_difference\" ) code = SET_SPINDIFF case ( \"user_extension1\" ) code = SET_USER1 case ( \"user_extension2\" ) code = SET_USER2 case ( \"all\" , \"any\" ) code = SET_ALL case ( \"invalid\" , \"INVALID\" ) code = SET_NULL case default call die ( \"Wrong set string: \" // trim ( str )) end select end function setcode_of_string","tags":"","loc":"proc/setcode_of_string.html"},{"title":"str_of_set – libPSML","text":"public function str_of_set(code) result(str) Arguments Type Intent Optional Attributes Name integer, intent(in) :: code Return Value character(len=40) Contents Source Code str_of_set Source Code function str_of_set ( code ) result ( str ) integer , intent ( in ) :: code character ( len = 40 ) :: str character ( len = 100 ) :: msg select case ( code ) case ( SET_NONREL ) str = \"non_relativistic\" case ( SET_SREL ) str = \"scalar_relativistic\" case ( SET_SO ) str = \"spin_orbit\" case ( SET_LJ ) str = \"lj\" case ( SET_UP ) str = \"spin_up\" case ( SET_DOWN ) str = \"spin_down\" case ( SET_SPINAVE ) str = \"spin_average\" case ( SET_SPINDIFF ) str = \"spin_difference\" case ( SET_USER1 ) str = \"user_extension1\" case ( SET_USER2 ) str = \"user_extension2\" case ( SET_ALL ) str = \"all\" case ( SET_NULL ) str = \"invalid\" case default write ( msg , \"(a,i4)\" ) \"Wrong set code: \" , code call die ( msg ) end select end function str_of_set","tags":"","loc":"proc/str_of_set.html"},{"title":"ps_destroy – libPSML","text":"public subroutine ps_destroy(ps) Arguments Type Intent Optional Attributes Name type( ps_t ), intent(inout) :: ps Contents Source Code ps_destroy Source Code subroutine ps_destroy ( ps ) !! Cleans the ps object type ( ps_t ), intent ( inout ) :: ps integer :: i call ps_clean_annotation ( ps % annotation ) call destroy_provenance ( ps % provenance ) call ps_clean_annotation ( ps % header % annotation ) call ps_clean_annotation ( ps % config_val % annotation ) call ps_clean_annotation ( ps % config_core % annotation ) call destroy_xc ( ps % xc_info ) ! ! Note that freshly declared objects must have ! npots = 0 and npswfs = 0 ! ! call destroy_semilocal ( ps % semilocal ) call destroy_nonlocal ( ps % nonlocal ) ! call destroy_local ( ps % local ) ! call destroy_wavefunctions ( ps % wavefunctions ) ! call destroy_radfunc ( ps % valence_charge % rho_val ) call ps_clean_annotation ( ps % valence_charge % annotation ) ! call destroy_radfunc ( ps % core_charge % rho_core ) call ps_clean_annotation ( ps % core_charge % annotation ) ! call delete ( ps % global_grid ) end subroutine ps_destroy","tags":"","loc":"proc/ps_destroy.html"},{"title":"destroy_provenance – libPSML","text":"private subroutine destroy_provenance(p) Arguments Type Intent Optional Attributes Name type( provenance_t ), pointer :: p Contents Source Code destroy_provenance Source Code subroutine destroy_provenance ( p ) type ( provenance_t ), pointer :: p type ( provenance_t ), pointer :: q do while ( associated ( p )) call ps_clean_annotation ( p % annotation ) ! clean buffers for input files? q => p % next deallocate ( p ) p => q enddo end subroutine destroy_provenance","tags":"","loc":"proc/destroy_provenance.html"},{"title":"destroy_semilocal – libPSML","text":"private subroutine destroy_semilocal(p) Arguments Type Intent Optional Attributes Name type( semilocal_t ), pointer :: p Contents Source Code destroy_semilocal Source Code subroutine destroy_semilocal ( p ) type ( semilocal_t ), pointer :: p type ( semilocal_t ), pointer :: q do while ( associated ( p )) call ps_clean_annotation ( p % annotation ) call destroy_slps ( p % pot ) call delete ( p % grid ) q => p % next deallocate ( p ) p => q enddo end subroutine destroy_semilocal","tags":"","loc":"proc/destroy_semilocal.html"},{"title":"destroy_slps – libPSML","text":"private subroutine destroy_slps(p) Arguments Type Intent Optional Attributes Name type( slps_t ), pointer :: p Contents Source Code destroy_slps Source Code subroutine destroy_slps ( p ) type ( slps_t ), pointer :: p type ( slps_t ), pointer :: q do while ( associated ( p )) call destroy_radfunc ( p % V ) q => p % next deallocate ( p ) p => q enddo end subroutine destroy_slps","tags":"","loc":"proc/destroy_slps.html"},{"title":"destroy_local – libPSML","text":"public subroutine destroy_local(p) Arguments Type Intent Optional Attributes Name type( local_t ) :: p Contents Source Code destroy_local Source Code subroutine destroy_local ( p ) type ( local_t ) :: p call ps_clean_annotation ( p % annotation ) call delete ( p % grid ) call destroy_radfunc ( p % vlocal ) call destroy_radfunc ( p % chlocal ) end subroutine destroy_local","tags":"","loc":"proc/destroy_local.html"},{"title":"destroy_nonlocal – libPSML","text":"public subroutine destroy_nonlocal(p) Arguments Type Intent Optional Attributes Name type( nonlocal_t ), pointer :: p Contents Source Code destroy_nonlocal Source Code subroutine destroy_nonlocal ( p ) type ( nonlocal_t ), pointer :: p type ( nonlocal_t ), pointer :: q do while ( associated ( p )) call ps_clean_annotation ( p % annotation ) call destroy_nlpj ( p % proj ) call delete ( p % grid ) q => p % next deallocate ( p ) p => q enddo end subroutine destroy_nonlocal","tags":"","loc":"proc/destroy_nonlocal.html"},{"title":"destroy_nlpj – libPSML","text":"private subroutine destroy_nlpj(p) Arguments Type Intent Optional Attributes Name type( nlpj_t ), pointer :: p Contents Source Code destroy_nlpj Source Code subroutine destroy_nlpj ( p ) type ( nlpj_t ), pointer :: p type ( nlpj_t ), pointer :: q do while ( associated ( p )) call destroy_radfunc ( p % proj ) q => p % next deallocate ( p ) p => q enddo end subroutine destroy_nlpj","tags":"","loc":"proc/destroy_nlpj.html"},{"title":"destroy_wavefunctions – libPSML","text":"public subroutine destroy_wavefunctions(p) Arguments Type Intent Optional Attributes Name type( wfns_t ), pointer :: p Contents Source Code destroy_wavefunctions Source Code subroutine destroy_wavefunctions ( p ) type ( wfns_t ), pointer :: p type ( wfns_t ), pointer :: q do while ( associated ( p )) call ps_clean_annotation ( p % annotation ) call destroy_pswf ( p % wf ) call delete ( p % grid ) q => p % next deallocate ( p ) p => q enddo end subroutine destroy_wavefunctions","tags":"","loc":"proc/destroy_wavefunctions.html"},{"title":"destroy_pswf – libPSML","text":"private subroutine destroy_pswf(p) Arguments Type Intent Optional Attributes Name type( wf_t ), pointer :: p Contents Source Code destroy_pswf Source Code subroutine destroy_pswf ( p ) type ( wf_t ), pointer :: p type ( wf_t ), pointer :: q do while ( associated ( p )) call destroy_radfunc ( p % Phi ) q => p % next deallocate ( p ) p => q enddo end subroutine destroy_pswf","tags":"","loc":"proc/destroy_pswf.html"},{"title":"destroy_radfunc – libPSML","text":"private subroutine destroy_radfunc(rp) Arguments Type Intent Optional Attributes Name type( radfunc_t ) :: rp Contents Source Code destroy_radfunc Source Code subroutine destroy_radfunc ( rp ) type ( radfunc_t ) :: rp call delete ( rp % grid ) if ( associated ( rp % data )) then deallocate ( rp % data ) rp % data => null () endif end subroutine destroy_radfunc","tags":"","loc":"proc/destroy_radfunc.html"},{"title":"destroy_xc – libPSML","text":"private subroutine destroy_xc(xp) Arguments Type Intent Optional Attributes Name type( xc_t ), intent(inout) :: xp Contents Source Code destroy_xc Source Code subroutine destroy_xc ( xp ) type ( xc_t ), intent ( inout ) :: xp if ( allocated ( xp % libxc_name )) deallocate ( xp % libxc_name ) if ( allocated ( xp % libxc_type )) deallocate ( xp % libxc_type ) if ( allocated ( xp % libxc_id )) deallocate ( xp % libxc_id ) if ( allocated ( xp % libxc_weight )) deallocate ( xp % libxc_weight ) call ps_clean_annotation ( xp % annotation ) end subroutine destroy_xc","tags":"","loc":"proc/destroy_xc.html"},{"title":"set_interpolator – libPSML","text":"public subroutine set_interpolator(func, nquality) Arguments Type Intent Optional Attributes Name public subroutine func(nquality, x, y, npts, r, val, debug) Arguments Type Intent Optional Attributes Name integer, intent(in) :: nquality real(kind=dp), intent(in) :: x (*) real(kind=dp), intent(in) :: y (*) integer, intent(in) :: npts real(kind=dp), intent(in) :: r real(kind=dp), intent(out) :: val logical, intent(in) :: debug integer, intent(in) :: nquality Contents Source Code set_interpolator Source Code subroutine set_interpolator ( func , nquality ) ! Parameter for interpolator's quality ! It might mean different things for different ! interpolators integer , intent ( in ) :: nquality ! We should not need to repeat this... interface subroutine func ( nquality , x , y , npts , r , val , debug ) integer , parameter :: dp = selected_real_kind ( 10 , 100 ) integer , intent ( in ) :: nquality ! Quality parameter real ( dp ), intent ( in ) :: x ( * ), y ( * ) integer , intent ( in ) :: npts ! Size of x, y arrays real ( dp ), intent ( in ) :: r real ( dp ), intent ( out ) :: val logical , intent ( in ) :: debug end subroutine func end interface interpolator => func nq = nquality end subroutine set_interpolator","tags":"","loc":"proc/set_interpolator.html"},{"title":"set_default_interpolator – libPSML","text":"public subroutine set_default_interpolator() Arguments None Contents Source Code set_default_interpolator Source Code subroutine set_default_interpolator () ! Default interpolator and quality parameter ! DRH's dpnint modified by AG, at 7th order ! (Included in this module with permission) ! call set_interpolator ( dpnint1 , 7 ) end subroutine set_default_interpolator","tags":"","loc":"proc/set_default_interpolator.html"},{"title":"dpnint1 – libPSML","text":"private subroutine dpnint1(npoly, xx, yy, nn, r, val, debug) Arguments Type Intent Optional Attributes Name integer, intent(in) :: npoly real(kind=dp), intent(in) :: xx (*) real(kind=dp), intent(in) :: yy (*) integer, intent(in) :: nn real(kind=dp), intent(in) :: r real(kind=dp), intent(out) :: val logical, intent(in) :: debug Contents Source Code dpnint1 Source Code subroutine dpnint1 ( npoly , xx , yy , nn , r , val , debug ) ! Modified by Alberto Garcia, March 2015 from routine ! dpnint by D.R. Hamann. ! Changes: !   -- A single value is returned !   -- It can extrapolate, instead of stopping, !      when called with an abscissa outside the !      data range. !   -- If the number of data points is less than !      npoly+1, npoly is implicitly reduced, without !      error, and without warning. !   -- Debug interface ! ! local polynomial interpolation of data yy on nn points xx ! giving value val on point r ! npoly sets order of polynomial ! xx must be ordered in ascending order ! output interpolated value val on point r implicit none integer , parameter :: dp = kind ( 1.0d0 ) !Input variables real ( dp ), intent ( in ) :: xx ( * ), yy ( * ) real ( dp ), intent ( in ) :: r real ( dp ), intent ( out ) :: val integer , intent ( in ) :: nn , npoly logical , intent ( in ) :: debug !Local variables real ( dp ) :: sum , term , zz integer ii , imin , imax , iprod , iy , istart , kk , iend ! interval halving search for xx(ii) points bracketing r imin = 1 imax = nn do kk = 1 , nn ii = ( imin + imax ) / 2 if ( r > xx ( ii )) then imin = ii else imax = ii end if if ( imax - imin . eq . 1 ) then exit end if end do zz = r !   if (debug) print *, \"imin, imax: \", imin, imax if ( mod ( npoly , 2 ) == 1 ) then istart = imin - npoly / 2 else if ( zz - xx ( imin ) < xx ( imax ) - zz ) then istart = imin - npoly / 2 else istart = imax - npoly / 2 end if istart = min ( istart , nn - npoly ) istart = max ( istart , 1 ) iend = min ( istart + npoly , nn ) !  if (debug) print *, \"istart, iend: \", istart, iend sum = 0.0d0 do iy = istart , iend if ( yy ( iy ) == 0.0d0 ) cycle term = yy ( iy ) do iprod = istart , iend if ( iprod == iy ) cycle term = term * ( zz - xx ( iprod )) / ( xx ( iy ) - xx ( iprod )) end do sum = sum + term end do val = sum end subroutine dpnint1","tags":"","loc":"proc/dpnint1.html"},{"title":"interpolate – libPSML","text":"interface public subroutine interpolate(nquality, x, y, npts, r, val, debug) Arguments Type Intent Optional Attributes Name integer, intent(in) :: nquality real(kind=dp), intent(in) :: x (*) real(kind=dp), intent(in) :: y (*) integer, intent(in) :: npts real(kind=dp), intent(in) :: r real(kind=dp), intent(out) :: val logical, intent(in) :: debug","tags":"","loc":"interface/interpolate.html"},{"title":"approx – libPSML","text":"private function approx(x, y, tol) result(is_close) Arguments Type Intent Optional Attributes Name real(kind=dp), intent(in) :: x real(kind=dp), intent(in) :: y real(kind=dp), intent(in) :: tol Return Value logical Contents Source Code approx Source Code function approx ( x , y , tol ) result ( is_close ) real ( dp ), intent ( in ) :: x , y real ( dp ), intent ( in ) :: tol logical :: is_close is_close = abs ( x - y ) < tol end function approx","tags":"","loc":"proc/approx.html"},{"title":"begin_element – libPSML","text":"public subroutine begin_element(name, attributes) Uses xmlf90_sax Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: name type(dictionary_t), intent(in) :: attributes Contents Source Code begin_element Source Code subroutine begin_element ( name , attributes ) use xmlf90_sax , only : dictionary_t , get_value character ( len =* ), intent ( in ) :: name type ( dictionary_t ), intent ( in ) :: attributes character ( len = 100 ) :: value , msg real :: version_number integer :: status integer :: i , npts if ( debug_parsing ) print * , \"Element: \" , trim ( name ) select case ( name ) case ( \"psml\" ) in_psml = . true . ! Make sure that pseudo is pointing to something if (. not . associated ( pseudo )) then call die ( \"ps_t object not initialized by client\" ) endif call get_value ( attributes , \"version\" , value , status ) if ( status /= 0 ) call die ( \"No psml version\" ) read ( value , fmt =* ) version_number if ( ( version_number < PSML_TARGET_VERSION_LO ) . or . & ( version_number > PSML_TARGET_VERSION_HI )) then write ( msg , \"('[',f4.2,',',f4.2,']')\" ) & PSML_TARGET_VERSION_LO , & PSML_TARGET_VERSION_HI call die ( \"This version of the library can \" // & \"process PSML files with version in \" // trim ( msg )) endif pseudo % version = value call get_value ( attributes , \"energy_unit\" , pseudo % energy_unit , status ) if ( status /= 0 ) call die ( \"No energy unit\" ) call get_value ( attributes , \"length_unit\" , pseudo % length_unit , status ) if ( status /= 0 ) call die ( \"No length unit\" ) call get_value ( attributes , \"uuid\" , pseudo % uuid , status ) if ( status /= 0 ) pseudo % uuid = \"no-uuid-specified\" call get_value ( attributes , \"xmlns\" , pseudo % namespace , status ) if ( status /= 0 ) pseudo % namespace = \"no-namespace-specified\" case ( \"provenance\" ) in_provenance = . true . ! This will gather all element provenances at the top level allocate ( pp ) if ( associated ( pseudo % provenance )) then qp => pseudo % provenance do while ( associated ( qp % next )) qp => qp % next enddo qp % next => pp else pseudo % provenance => pp endif pp % n_input_files = 0 call get_value ( attributes , \"creator\" , pp % creator , status ) if ( status /= 0 ) pp % creator = \"unknown\" call get_value ( attributes , \"date\" , pp % date , status ) if ( status /= 0 ) pp % date = \"unknown\" ! Support the optional attribute 'record-number'. ! SAX will keep the order. In this parser we require ! that the records be in the right order in the file. ! (Check performed at the end of parsing) ! Other parsers (e.g. DOM) might need to worry about ! internal ordering pp % record_number = 0 call get_value ( attributes , \"record-number\" , value , status ) if ( status == 0 ) then read ( unit = value , fmt =* ) pp % record_number endif case ( \"input-file\" ) if (. not . in_provenance ) call die ( \"<input-file> outside <provenance>\" ) in_input_file = . true . pp % n_input_files = pp % n_input_files + 1 ifp => pp % input_file call get_value ( attributes , \"name\" , ifp % name , status ) if ( status /= 0 ) ifp % name = \"unknown\" case ( \"header\" , \"pseudo-atom-spec\" ) in_header = . true . hp => pseudo % header call get_value ( attributes , \"atomic-label\" , hp % atomic_label , status ) if ( status /= 0 ) call die ( \"Cannot determine atomic-label\" ) call get_value ( attributes , \"z-pseudo\" , value , status ) if ( status /= 0 ) call die ( \"Cannot determine z-pseudo\" ) read ( unit = value , fmt =* ) hp % zpseudo call get_value ( attributes , \"atomic-number\" , value , status ) if ( status /= 0 ) call die ( \"Cannot determine atomic number\" ) read ( unit = value , fmt =* ) hp % z call get_value ( attributes , \"flavor\" , hp % flavor , status ) if ( status /= 0 ) hp % flavor = \"\" ! empty string signals absence call get_value ( attributes , \"relativity\" , hp % relativity , status ) if ( status /= 0 ) call die ( \"Cannot determine relativity scheme\" ) call get_value ( attributes , \"spin-dft\" , value , status ) if ( status /= 0 ) then ! Check v1.0 form call get_value ( attributes , \"polarized\" , value , status ) if ( status /= 0 ) value = \"no\" endif hp % polarized = ( value == \"yes\" ) if ( hp % polarized . and . trim ( hp % relativity ) == \"dirac\" ) then call die ( \"Cannot be polarized and fully relativistic at the same time\" ) endif call get_value ( attributes , \"core-corrections\" , & hp % core_corrections , status ) if ( status /= 0 ) hp % core_corrections = \"no\" ! Check yes/no value?? case ( \"exchange-correlation\" ) in_xc = . true . xp => pseudo % xc_info case ( \"libxc-info\" ) if (. not . in_xc ) call die ( \"Orphan <libxc-info>\" ) in_libxc_info = . true . call get_value ( attributes , \"number-of-functionals\" , & value , status ) if ( status /= 0 ) call die ( \"Error reading number of libxc functs\" ) read ( unit = value , fmt =* ) xp % n_functs_libxc n_funct = xp % n_functs_libxc allocate ( xp % libxc_name ( n_funct ), xp % libxc_id ( n_funct )) allocate ( xp % libxc_weight ( n_funct ), xp % libxc_type ( n_funct )) xp % libxc_weight ( 1 : n_funct ) = 1.0_dp xp % libxc_type ( 1 : n_funct ) = \"UNKNOWN\" n_funct = 0 ! for checking the counting on the fly case ( \"functional\" ) if (. not . in_libxc_info ) call die ( \"Orphan <functional>\" ) n_funct = n_funct + 1 if ( n_funct > xp % n_functs_libxc ) & call die ( \"Too many <functional> elements in <libxc-info>\" ) call get_value ( attributes , \"name\" , & xp % libxc_name ( n_funct ), status ) if ( status /= 0 ) call die ( \"Error reading libxc name\" ) call get_value ( attributes , \"id\" , value , status ) if ( status /= 0 ) call die ( \"Error reading libxc id\" ) read ( unit = value , fmt =* ) xp % libxc_id ( n_funct ) ! optional attribute(s) call get_value ( attributes , \"weight\" , value , status ) if ( status == 0 ) then read ( unit = value , fmt =* ) xp % libxc_weight ( n_funct ) endif call get_value ( attributes , \"type\" , value , status ) if ( status == 0 ) then xp % libxc_type ( n_funct ) = trim ( value ) endif case ( \"valence-configuration\" ) in_valence_config = . true . pseudo % config_val % nshells = 0 pseudo % config_val % occ_up (:) = 0.0_dp pseudo % config_val % occ_down (:) = 0.0_dp pseudo % config_val % occ (:) = 0.0_dp call get_value ( attributes , \"total-valence-charge\" , value , status ) if ( status /= 0 ) call die ( \"Cannot determine total-valence-charge\" ) read ( unit = value , fmt =* ) pseudo % config_val % total_charge case ( \"shell\" ) if ( in_valence_config ) then cp => pseudo % config_val !         else if (in_core_config) then !            cp => pseudo%config_core else call die ( \"Orphan <shell> element\" ) endif cp % nshells = cp % nshells + 1 call get_value ( attributes , \"l\" , cp % l ( cp % nshells ), status ) if ( status /= 0 ) call die ( \"Cannot determine l for shell\" ) call get_value ( attributes , \"n\" , value , status ) if ( status /= 0 ) call die ( \"Cannot determine n for shell\" ) read ( unit = value , fmt =* ) cp % n ( cp % nshells ) call get_value ( attributes , \"occupation\" , value , status ) if ( status /= 0 ) call die ( \"Cannot determine occupation for shell\" ) read ( unit = value , fmt =* ) cp % occ ( cp % nshells ) call get_value ( attributes , \"occupation-up\" , value , status ) if ( status == 0 ) then read ( unit = value , fmt =* ) cp % occ_up ( cp % nshells ) endif call get_value ( attributes , \"occupation-down\" , value , status ) if ( status == 0 ) then read ( unit = value , fmt =* ) cp % occ_down ( cp % nshells ) endif case ( \"slps\" ) in_slps = . true . if (. not . in_semilocal ) call die ( \"Orphan <slps> element\" ) allocate ( slvp ) ! Append to end of list  !! call append(slp%pot,slvp) if ( associated ( slp % pot )) then qslvp => slp % pot do while ( associated ( qslvp % next )) qslvp => qslvp % next enddo qslvp % next => slvp else !First link slp % pot => slvp endif rp => slvp % V slvp % parent_group => slp ! current semilocal-potentials element call get_value ( attributes , \"set\" , value , status ) if ( status /= 0 ) then value = current_sl_set endif slvp % set = setcode_of_string ( value ) call get_value ( attributes , \"l\" , slvp % l , status ) if ( status /= 0 ) call die ( \"Cannot determine l for SL potential\" ) call get_value ( attributes , \"n\" , value , status ) if ( status /= 0 ) call die ( \"Cannot determine n for SL potential\" ) read ( unit = value , fmt =* ) slvp % n call get_value ( attributes , \"rc\" , value , status ) if ( status /= 0 ) call die ( \"Cannot determine rc for SL potential\" ) read ( unit = value , fmt =* ) slvp % rc call get_value ( attributes , \"j\" , value , status ) if ( status /= 0 ) then if ( slvp % set == SET_LJ ) & call die ( \"Cannot determine j for SLPS in set \" // str_of_set ( SET_LJ )) else read ( unit = value , fmt =* ) slvp % j endif slvp % eref = huge ( 1.0_dp ) ! Signal absence of eref attribute call get_value ( attributes , \"eref\" , value , status ) if ( status == 0 ) then read ( unit = value , fmt =* ) slvp % eref endif call get_value ( attributes , \"flavor\" , slvp % flavor , status ) if ( status /= 0 ) then slvp % flavor = top_flavor endif ! Encode the behavior beyond the range ! The only current possibility is to have ! a Coulomb tail, or zero. select case ( slvp % set ) case ( SET_SO , SET_SPINDIFF ) rp % has_coulomb_tail = . false . case default rp % has_coulomb_tail = . true . rp % tail_factor = - pseudo % header % zpseudo end select case ( \"proj\" ) in_proj = . true . if (. not . in_nonlocal ) call die ( \"Orphan <proj> element\" ) allocate ( nlpp ) ! Append to end of list  !! call append(nlp%proj,nlpp) if ( associated ( nlp % proj )) then qnlpp => nlp % proj do while ( associated ( qnlpp % next )) qnlpp => qnlpp % next enddo qnlpp % next => nlpp else !First link nlp % proj => nlpp endif rp => nlpp % proj rp % has_coulomb_tail = . false . nlpp % parent_group => nlp ! current nonlocal-projectors element call get_value ( attributes , \"set\" , value , status ) if ( status /= 0 ) then value = current_proj_set endif nlpp % set = setcode_of_string ( value ) call get_value ( attributes , \"l\" , nlpp % l , status ) if ( status /= 0 ) call die ( \"Cannot determine l for proj\" ) call get_value ( attributes , \"seq\" , value , status ) if ( status /= 0 ) call die ( \"Cannot determine seq number for proj\" ) read ( unit = value , fmt =* ) nlpp % seq call get_value ( attributes , \"ekb\" , value , status ) if ( status /= 0 ) call die ( \"Cannot determine Ekb for proj\" ) read ( unit = value , fmt =* ) nlpp % ekb nlpp % eref = huge ( 1.0_dp ) ! Signal absence of eref attribute call get_value ( attributes , \"eref\" , value , status ) if ( status == 0 ) then read ( unit = value , fmt =* ) nlpp % eref endif call get_value ( attributes , \"j\" , value , status ) if ( status /= 0 ) then if ( nlpp % set == SET_LJ ) & call die ( \"Cannot determine j for Proj in set \" // str_of_set ( SET_LJ )) else read ( unit = value , fmt =* ) nlpp % j endif call get_value ( attributes , \"type\" , nlpp % type , status ) if ( status /= 0 ) call die ( \"Cannot determine type of proj\" ) case ( \"pswf\" ) if (. not . in_pseudowavefun ) call die ( \"Orphan <pswf> element\" ) in_pswf = . true . allocate ( wfpp ) ! Append to end of list  !! call append(wfp%proj,wfpp) if ( associated ( wfp % wf )) then qwfpp => wfp % wf do while ( associated ( qwfpp % next )) qwfpp => qwfpp % next enddo qwfpp % next => wfpp else !First link wfp % wf => wfpp endif rp => wfpp % Phi rp % has_coulomb_tail = . false . wfpp % parent_group => wfp ! current nowfocal-projectors element call get_value ( attributes , \"set\" , value , status ) if ( status /= 0 ) then value = current_wf_set endif wfpp % set = setcode_of_string ( value ) call get_value ( attributes , \"l\" , wfpp % l , status ) if ( status /= 0 ) call die ( \"Cannot determine l for wf\" ) call get_value ( attributes , \"n\" , value , status ) if ( status /= 0 ) call die ( \"Cannot determine n for wf\" ) read ( unit = value , fmt =* ) wfpp % n call get_value ( attributes , \"j\" , value , status ) if ( status /= 0 ) then if ( wfpp % set == SET_LJ ) & call die ( \"Cannot determine j for wf in set \" // str_of_set ( SET_LJ )) else read ( unit = value , fmt =* ) wfpp % j endif wfpp % energy_level = huge ( 1.0_dp ) call get_value ( attributes , \"energy_level\" , value , status ) if ( status == 0 ) then read ( unit = value , fmt =* ) wfpp % energy_level endif case ( \"grid\" ) in_grid = . true . got_explicit_grid_data = . false . ! This attribute is mandatory call get_value ( attributes , \"npts\" , value , status ) if ( status /= 0 ) call die ( \"Cannot determine grid npts\" ) read ( unit = value , fmt =* ) npts if ( npts == 0 ) call die ( \"Grid size not specified correctly\" ) ! Create working object and associate inner sections ! while the parsing is active call newGrid ( tmp_grid , npts ) gdata => valGrid ( tmp_grid ) gannot => annotationGrid ( tmp_grid ) ! ! In this way we allow for a private grid for each radfunc, ! or for a global grid specification ! if ( in_radfunc ) then if ( debug_parsing ) print * , \"Found grid in radfunc\" if ( initialized ( rp % grid )) then call die ( \"psml: Two grids specified for a radfunc\" ) endif rp % grid = tmp_grid ! We check whether we are at the top level, ! or at an intermediate grouping level that allows a grid else if ( in_nonlocal ) then if ( initialized ( nlp % grid )) then call die ( \"psml: Two grids in same nonlocal block\" ) endif if ( debug_parsing ) print * , \"Found nonlocal grid\" nlp % grid = tmp_grid else if ( in_local_potential ) then if ( initialized ( lop % grid )) then call die ( \"psml: Two grids in same local block\" ) endif if ( debug_parsing ) print * , \"Found local grid\" lop % grid = tmp_grid else if ( in_semilocal ) then if ( initialized ( slp % grid )) then call die ( \"psml: Two grids in same semilocal block\" ) endif if ( debug_parsing ) print * , \"Found semilocal grid\" slp % grid = tmp_grid else if ( in_pseudowavefun ) then if ( initialized ( wfp % grid )) then !call die(\"psml: Two pseudo-wavefunction grids specified\") endif if ( debug_parsing ) print * , \"Found pseudo-wavefunction grid\" wfp % grid = tmp_grid else ! We are at the top level if ( debug_parsing ) print * , \"Found grid at the top level\" if ( initialized ( pseudo % global_grid )) then ! Maybe allow this in the future call die ( \"psml: Two global grids specified\" ) endif pseudo % global_grid = tmp_grid endif case ( \"data\" ) if (. not . in_radfunc ) then call die ( \"<data> element outside <rad_func> element\" ) endif in_data = . true . ! The following blocks are a bit more verbose than needed since ! the Intel compiler seems to be trying to evaluate all the ! clauses joined by an .and. operator, instead of stopping if ! the first clause is .false. if (. not . initialized ( rp % grid )) then ! Try regional grids first if ( in_nonlocal ) then if ( initialized ( nlp % grid )) then rp % grid = nlp % grid if ( debug_parsing ) print * , \"Associated proj grid with nl parent grid\" endif else if ( in_local_potential ) then if ( initialized ( lop % grid )) then rp % grid = lop % grid if ( debug_parsing ) print * , \"Associated grid with vlocal parent grid\" endif else if ( in_semilocal ) then if ( initialized ( slp % grid )) then rp % grid = slp % grid if ( debug_parsing ) print * , \"Associated slps grid with sl parent grid\" endif else if ( in_pseudowavefun ) then if ( initialized ( wfp % grid )) then rp % grid = wfp % grid endif endif endif ! If the parent block does not include a grid, try the global grid if (. not . initialized ( rp % grid )) then if ( initialized ( pseudo % global_grid )) then rp % grid = pseudo % global_grid if ( debug_parsing ) print * , \"Associated grid with global grid\" endif endif ! Now give up if (. not . initialized ( rp % grid )) call die ( \"Cannot find grid data for radfunc\" ) ! This attribute is optional ! If present, it determines the actual number of points of the grid used ! (for example, for a function of shorter range) ! This is an experimental feature that can save space ! (if implemented correctly!!!) call get_value ( attributes , \"npts\" , value , status ) if ( status == 0 ) then read ( unit = value , fmt =* ) npts_data if ( npts_data > sizeGrid ( rp % grid )) call die ( \"data npts too big\" ) else npts_data = sizeGrid ( rp % grid ) endif allocate ( rp % data ( npts_data )) ndata = 0 ! To start the build up case ( \"grid-data\" ) if (. not . in_grid ) call die ( \"Grid_data element outside grid element\" ) in_grid_data = . true . got_explicit_grid_data = . true . if ( size ( gdata ) == 0 ) call die ( \"Grid npts attribute faulty\" ) ndata_grid = 0 ! To start the build up case ( \"radfunc\" ) ! We need to make sure that a radfunc is allowed at this level ! ! For example, if an old-style file with <vps> is used, the finding ! of a <vps> element will not increase npots, and there will be a ! segmentation fault when trying to store the data in the rp pointer, ! which would be non-associated if the vps section is the first ! case of radfuncs in the file ! ! Actually, it gets worse: if there is a <core-charge> element ! before the old-style <vps> section, the rp pointer used for ! core-charge will be reused and assigned the data for the first ! and subsequent vps elements. ! if ( in_slps . or . in_coreCharge . or . in_valenceCharge & . or . in_pswf . or . in_proj . or . in_local_potential & . or . in_chlocal ) then in_radfunc = . true . else call die ( \"<radfunc> element found under unallowed <\" // & trim ( parent_element ) // \">\" ) endif case ( \"pseudocore-charge\" ) in_coreCharge = . true . corep => pseudo % core_charge rp => corep % rho_core rp % has_coulomb_tail = . false . call get_value ( attributes , \"matching-radius\" , value , status ) if ( status == 0 ) then read ( unit = value , fmt =* ) corep % rcore else ! Signal absence of attribute with a negative number corep % rcore = - 1.0_dp endif call get_value ( attributes , \"number-of-continuous-derivatives\" , & value , status ) if ( status == 0 ) then read ( unit = value , fmt =* ) corep % n_cont_derivs else ! Signal absence of attribute with a negative number corep % n_cont_derivs = - 1 endif case ( \"valence-charge\" ) in_valenceCharge = . true . valp => pseudo % valence_charge rp => valp % rho_val rp % has_coulomb_tail = . false . call get_value ( attributes , \"total-charge\" , value , status ) if ( status /= 0 ) call die ( \"Cannot determine total valence charge\" ) read ( unit = value , fmt =* ) valp % total_charge call get_value ( attributes , \"is-unscreening-charge\" ,& valp % is_unscreening_charge , status ) if ( status /= 0 ) valp % is_unscreening_charge = \"\" call get_value ( attributes , \"rescaled-to-z-pseudo\" ,& valp % rescaled_to_z_pseudo , status ) if ( status /= 0 ) valp % rescaled_to_z_pseudo = \"\" case ( \"semilocal-potentials\" ) in_semilocal = . true . allocate ( slp ) if ( associated ( pseudo % semilocal )) then qslp => pseudo % semilocal do while ( associated ( qslp % next )) qslp => qslp % next enddo qslp % next => slp else pseudo % semilocal => slp endif current_sl_set = \"invalid\" slp % set = SET_NULL call get_value ( attributes , \"set\" , value , status ) if ( status == 0 ) then current_sl_set = value slp % set = setcode_of_string ( value ) endif if ( debug_parsing ) print * , \"Found semilocal-potentials set: \" , trim ( current_sl_set ) top_flavor = pseudo % header % flavor call get_value ( attributes , \"flavor\" , value , status ) if ( status == 0 ) then top_flavor = value endif case ( \"nonlocal-projectors\" ) in_nonlocal = . true . ! Allocate new node and add to the end of the linked list allocate ( nlp ) if ( associated ( pseudo % nonlocal )) then qnlp => pseudo % nonlocal do while ( associated ( qnlp % next )) qnlp => qnlp % next enddo qnlp % next => nlp else pseudo % nonlocal => nlp endif current_proj_set = \"invalid\" nlp % set = SET_NULL call get_value ( attributes , \"set\" , value , status ) if ( status == 0 ) then current_proj_set = value nlp % set = setcode_of_string ( value ) endif if ( debug_parsing ) print * , \"Found nonlocal-projectors set: \" , trim ( current_proj_set ) nlp % set = setcode_of_string ( value ) case ( \"local-potential\" ) in_local_potential = . true . lop => pseudo % local rp => lop % vlocal rp % has_coulomb_tail = . true . rp % tail_factor = - pseudo % header % zpseudo call get_value ( attributes , \"type\" , lop % vlocal_type , status ) if ( status /= 0 ) call die ( \"Cannot determine type of local potential\" ) case ( \"local-charge\" ) if (. not . in_local_potential ) call die ( \"<local-charge> outside <local-potential>\" ) in_chlocal = . true . lop => pseudo % local rp => lop % chlocal rp % has_coulomb_tail = . false . ! Future expansion: chlocal attributes case ( \"pseudo-wave-functions\" ) in_pseudowavefun = . true . ! Allocate new node and add to the end of the linked list allocate ( wfp ) if ( associated ( pseudo % wavefunctions )) then qwfp => pseudo % wavefunctions do while ( associated ( qwfp % next )) qwfp => qwfp % next enddo qwfp % next => wfp else pseudo % wavefunctions => wfp endif current_wf_set = \"invalid\" wfp % set = SET_NULL call get_value ( attributes , \"set\" , value , status ) if ( status == 0 ) then current_wf_set = value wfp % set = setcode_of_string ( value ) endif if ( debug_parsing ) print * , \"Found wavefunctions set: \" , trim ( current_wf_set ) wfp % set = setcode_of_string ( value ) !! Optional call get_value ( attributes , \"type\" , value , status ) if ( status == 0 ) wfp % type = trim ( value ) case ( \"annotation\" ) ! Deeper elements first... if ( in_xc ) then call save_annotation ( attributes , xp % annotation ) else if ( in_valence_config ) then call save_annotation ( attributes , cp % annotation ) else if ( in_header ) then call save_annotation ( attributes , hp % annotation ) else if ( in_provenance ) then call save_annotation ( attributes , pp % annotation ) else if ( in_grid ) then call save_annotation ( attributes , gannot ) else if ( in_semilocal ) then call save_annotation ( attributes , slp % annotation ) else if ( in_nonlocal ) then call save_annotation ( attributes , nlp % annotation ) else if ( in_local_potential ) then call save_annotation ( attributes , lop % annotation ) else if ( in_pseudowavefun ) then call save_annotation ( attributes , wfp % annotation ) else if ( in_valenceCharge ) then call save_annotation ( attributes , valp % annotation ) else if ( in_coreCharge ) then call save_annotation ( attributes , corep % annotation ) else if ( in_psml ) then ! It must be at the top level ! Version 1.0 only. Keep it in the structure call save_annotation ( attributes , pseudo % annotation ) else ! Do nothing instead of dying ! call die(\"Misplaced <annotation> element\") endif end select parent_element = name end subroutine begin_element","tags":"","loc":"proc/begin_element.html"},{"title":"end_element – libPSML","text":"public subroutine end_element(name) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: name Contents Source Code end_element Source Code subroutine end_element ( name ) character ( len =* ), intent ( in ) :: name integer :: i , nnz real ( dp ) :: Z real ( dp ), parameter :: tol = 1.0e-20_dp !! Scale or other data dependence? real ( dp ), pointer :: rg (:) type ( provenance_t ), pointer :: q => null () integer :: depth if ( debug_parsing ) print * , \"-- end Element: \" , trim ( name ) select case ( name ) case ( \"radfunc\" ) in_radfunc = . false . if (. not . associated ( rp % data )) then call die ( \"No data for radfunc!\" ) endif ! Determine the effective range ! by skipping over (nearly) zeros ! For functions with tail, use r*f rg => valGrid ( rp % grid ) if ( rp % has_coulomb_tail ) then Z = - rp % tail_factor nnz = size ( rp % data ) do while ( approx ( ( rg ( nnz ) * rp % data ( nnz ) + Z ), 0.0_dp , tol ) ) nnz = nnz - 1 enddo else nnz = size ( rp % data ) do while ( approx ( rp % data ( nnz ) , 0.0_dp , tol ) ) nnz = nnz - 1 enddo endif rp % nnz = nnz if ( nnz == size ( rp % data )) then rp % rcut_eff = rg ( nnz ) else rp % rcut_eff = rg ( nnz + 1 ) if ( debug_parsing ) print \"(a,i4,f10.4)\" ,& \"Effective npts and range:\" , nnz + 1 , rp % rcut_eff endif case ( \"grid\" ) in_grid = . false . ! if (. not . got_explicit_grid_data ) then call die ( \"Need explicit grid data!\" ) endif call delete ( tmp_grid ) case ( \"data\" ) ! ! We are done filling up the radfunc data ! Check that we got the advertised number of items ! in_data = . false . if ( ndata /= size ( rp % data )) then call die ( \"npts mismatch in radfunc data\" ) endif case ( \"grid-data\" ) ! ! We are done filling up the grid data ! Check that we got the advertised number of items ! in_grid_data = . false . if ( ndata_grid /= size ( gdata )) then call die ( \"npts mismatch in grid\" ) endif if ( debug_parsing ) print * , \"Got grid data: \" , got_explicit_grid_data case ( \"pseudocore-charge\" ) in_coreCharge = . false . case ( \"valence-charge\" ) in_valenceCharge = . false . case ( \"semilocal-potentials\" ) in_semilocal = . false . slp => null () case ( \"nonlocal-projectors\" ) in_nonlocal = . false . nlp => null () case ( \"slps\" ) in_slps = . false . case ( \"proj\" ) in_proj = . false . case ( \"local-potential\" ) in_local_potential = . false . lop => null () case ( \"local-charge\" ) in_chlocal = . false . case ( \"pseudo-wave-functions\" ) in_pseudowavefun = . false . case ( \"pswf\" ) in_pswf = . false . case ( \"valence-configuration\" ) in_valence_config = . false . case ( \"exchange-correlation\" ) in_xc = . false . case ( \"libxc-info\" ) in_libxc_info = . false . if ( n_funct /= xp % n_functs_libxc ) & call die ( \"Too few <functional> elements in <libxc-info>\" ) case ( \"provenance\" ) in_provenance = . false . case ( \"input-file\" ) in_input_file = . false . case ( \"header\" , \"pseudo-atom-spec\" ) ! v1.0, v1.1 in_header = . false . case ( \"psml\" ) in_psml = . false . ! ! Check provenance elements ! ! First, determine how many there are depth = 0 q => pseudo % provenance do while ( associated ( q )) depth = depth + 1 q => q % next enddo ! ! Assign record numbers. For now, we ! require that the records are ordered in the file ! q => pseudo % provenance do while ( associated ( q )) ! A value of zero means that there is no (optional) record number if ( ( q % record_number /= 0 ) . and . & ( q % record_number /= depth )) then call die ( \"Provenance records out of order\" ) endif q % record_number = depth q => q % next depth = depth - 1 enddo end select end subroutine end_element","tags":"","loc":"proc/end_element.html"},{"title":"pcdata_chunk – libPSML","text":"public subroutine pcdata_chunk(chunk) Uses xmlf90_sax Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: chunk Contents Source Code pcdata_chunk Source Code subroutine pcdata_chunk ( chunk ) use xmlf90_sax , only : build_data_array character ( len =* ), intent ( in ) :: chunk if ( len_trim ( chunk ) == 0 ) RETURN ! skip empty chunk if ( in_data ) then ! ! Note that we know where we need to put it through the pointer rp... ! call build_data_array ( chunk , rp % data , ndata ) else if ( in_grid_data ) then ! !     Fill the explicit grid data pointer call build_data_array ( chunk , gdata , ndata_grid ) else if ( in_input_file ) then call safe_str_assign ( ifp % buffer , ifp % buffer // chunk ) else if ( in_header ) then ! ! There should not be any pcdata in header in this version... !      print *, \"Header data:\" !      print *, trim(chunk) endif end subroutine pcdata_chunk","tags":"","loc":"proc/pcdata_chunk.html"},{"title":"cdata_section_chunk – libPSML","text":"public subroutine cdata_section_chunk(chunk) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: chunk Contents Source Code cdata_section_chunk Source Code subroutine cdata_section_chunk ( chunk ) character ( len =* ), intent ( in ) :: chunk if ( len_trim ( chunk ) == 0 ) RETURN ! skip empty chunk if ( in_input_file ) then call safe_str_assign ( ifp % buffer , ifp % buffer // chunk ) endif end subroutine cdata_section_chunk","tags":"","loc":"proc/cdata_section_chunk.html"},{"title":"save_annotation – libPSML","text":"private subroutine save_annotation(atts, annotation) Uses assoc_list xmlf90_sax Arguments Type Intent Optional Attributes Name type(dictionary_t), intent(in) :: atts type(ps_annotation_t), intent(out) :: annotation Contents Source Code save_annotation Source Code subroutine save_annotation ( atts , annotation ) use assoc_list , ps_annotation_t => assoc_list_t use xmlf90_sax , only : dictionary_t , get_value , get_key , len type ( dictionary_t ), intent ( in ) :: atts type ( ps_annotation_t ), intent ( out ) :: annotation integer :: n , i , status character ( len = 300 ) :: key , value n = len ( atts ) call assoc_list_init ( annotation , n , status ) if ( status /= 0 ) call die ( \"Failed to init annotation object\" ) do i = 1 , n call get_key ( atts , i , key , status ) if ( status /= 0 ) call die ( \"cannot get key in atts dict\" ) call get_value ( atts , i , value , status ) if ( status /= 0 ) call die ( \"cannot get value in atts dict\" ) call assoc_list_insert ( annotation , key , value , status ) if ( status /= 0 ) call die ( \"Failed to insert annotation pair\" ) enddo end subroutine save_annotation","tags":"","loc":"proc/save_annotation.html"},{"title":"psml_die – libPSML","text":"interface public subroutine psml_die(str) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: str","tags":"","loc":"interface/psml_die~2.html"},{"title":"ps_RootAttributes_Set – libPSML","text":"public subroutine ps_RootAttributes_Set(ps, version, uuid, namespace) Arguments Type Intent Optional Attributes Name type( ps_t ), intent(inout) :: ps character(len=*), intent(in), optional :: version character(len=*), intent(in), optional :: uuid character(len=*), intent(in), optional :: namespace Contents Source Code ps_RootAttributes_Set Source Code subroutine ps_RootAttributes_Set ( ps , version , uuid , namespace ) type ( ps_t ), intent ( inout ) :: ps character ( len =* ), intent ( in ), optional :: version character ( len =* ), intent ( in ), optional :: uuid character ( len =* ), intent ( in ), optional :: namespace if ( present ( version )) then ps % version = version endif if ( present ( uuid )) then ps % uuid = uuid endif if ( present ( namespace )) then ps % namespace = namespace endif end  subroutine ps_RootAttributes_Set","tags":"","loc":"proc/ps_rootattributes_set.html"},{"title":"ps_SetPSMLVersion – libPSML","text":"public subroutine ps_SetPSMLVersion(ps, version) Arguments Type Intent Optional Attributes Name type( ps_t ), intent(inout) :: ps character(len=*), intent(in) :: version Contents Source Code ps_SetPSMLVersion Source Code subroutine ps_SetPSMLVersion ( ps , version ) type ( ps_t ), intent ( inout ) :: ps character ( len =* ), intent ( in ) :: version ps % version = version end subroutine ps_SetPSMLVersion","tags":"","loc":"proc/ps_setpsmlversion.html"},{"title":"ps_SetUUID – libPSML","text":"public subroutine ps_SetUUID(ps, id) Arguments Type Intent Optional Attributes Name type( ps_t ), intent(inout) :: ps character(len=36), intent(in) :: id Contents Source Code ps_SetUUID Source Code subroutine ps_SetUUID ( ps , id ) type ( ps_t ), intent ( inout ) :: ps character ( len = 36 ), intent ( in ) :: id ps % uuid = id end subroutine ps_SetUUID","tags":"","loc":"proc/ps_setuuid.html"},{"title":"ps_AddProvenanceRecord – libPSML","text":"public subroutine ps_AddProvenanceRecord(ps, creator, date, annotation) Arguments Type Intent Optional Attributes Name type( ps_t ), intent(inout) :: ps character(len=*), intent(in) :: creator character(len=*), intent(in) :: date type(ps_annotation_t), intent(in), target :: annotation Contents Source Code ps_AddProvenanceRecord Source Code subroutine ps_AddProvenanceRecord ( ps , creator , date , annotation ) type ( ps_t ), intent ( inout ) :: ps character ( len =* ), intent ( in ) :: creator character ( len =* ), intent ( in ) :: date type ( ps_annotation_t ), intent ( in ), target :: annotation type ( provenance_t ), pointer :: p type ( provenance_t ), pointer :: q integer :: depth allocate ( p ) ! ! Find the depth of the provenance stack ! depth = 0 q => ps % provenance do while ( associated ( q )) depth = depth + 1 q => q % next enddo q => ps % provenance if ( associated ( q )) then p % next => q q % prev => p endif ps % provenance => p p % record_number = depth + 1 p % creator = trim ( creator ) p % date = trim ( date ) p % annotation = annotation end subroutine ps_AddProvenanceRecord","tags":"","loc":"proc/ps_addprovenancerecord.html"},{"title":"ps_Delete_NonlocalProjectors – libPSML","text":"public subroutine ps_Delete_NonlocalProjectors(ps) Arguments Type Intent Optional Attributes Name type( ps_t ), intent(inout) :: ps Contents Source Code ps_Delete_NonlocalProjectors Source Code subroutine ps_Delete_NonlocalProjectors ( ps ) type ( ps_t ), intent ( inout ) :: ps call destroy_nonlocal ( ps % nonlocal ) end subroutine ps_Delete_NonlocalProjectors","tags":"","loc":"proc/ps_delete_nonlocalprojectors.html"},{"title":"ps_Delete_LocalPotential – libPSML","text":"public subroutine ps_Delete_LocalPotential(ps) Arguments Type Intent Optional Attributes Name type( ps_t ), intent(inout) :: ps Contents Source Code ps_Delete_LocalPotential Source Code subroutine ps_Delete_LocalPotential ( ps ) type ( ps_t ), intent ( inout ) :: ps call destroy_local ( ps % local ) end subroutine ps_Delete_LocalPotential","tags":"","loc":"proc/ps_delete_localpotential.html"},{"title":"ps_Provenance_Add – libPSML","text":"public interface ps_Provenance_Add Contents Module Procedures ps_AddProvenanceRecord Module Procedures public subroutine ps_AddProvenanceRecord (ps, creator, date, annotation) Arguments Type Intent Optional Attributes Name type( ps_t ), intent(inout) :: ps character(len=*), intent(in) :: creator character(len=*), intent(in) :: date type(ps_annotation_t), intent(in), target :: annotation","tags":"","loc":"interface/ps_provenance_add.html"},{"title":"ps_NonLocalProjectors_Delete – libPSML","text":"public interface ps_NonLocalProjectors_Delete Contents Module Procedures ps_Delete_NonLocalProjectors Module Procedures public subroutine ps_Delete_NonlocalProjectors (ps) Arguments Type Intent Optional Attributes Name type( ps_t ), intent(inout) :: ps","tags":"","loc":"interface/ps_nonlocalprojectors_delete.html"},{"title":"ps_LocalPotential_Delete – libPSML","text":"public interface ps_LocalPotential_Delete Contents Module Procedures ps_Delete_LocalPotential Module Procedures public subroutine ps_Delete_LocalPotential (ps) Arguments Type Intent Optional Attributes Name type( ps_t ), intent(inout) :: ps","tags":"","loc":"interface/ps_localpotential_delete.html"},{"title":"generate_table_sl – libPSML","text":"private subroutine generate_table_sl(ps) Arguments Type Intent Optional Attributes Name type( ps_t ), intent(inout), target :: ps Contents Source Code generate_table_sl Source Code subroutine generate_table_sl ( ps ) type ( ps_t ), intent ( inout ), target :: ps type ( semilocal_t ), pointer :: slp type ( slps_t ), pointer :: slvp integer :: npots if ( allocated ( ps % sl_table )) then deallocate ( ps % sl_table ) endif npots = 0 slp => ps % semilocal do while ( associated ( slp )) slvp => slp % pot do while ( associated ( slvp )) npots = npots + 1 slvp => slvp % next enddo slp => slp % next enddo allocate ( ps % sl_table ( npots )) npots = 0 slp => ps % semilocal do while ( associated ( slp )) slvp => slp % pot do while ( associated ( slvp )) npots = npots + 1 ps % sl_table ( npots )% p => slvp slvp => slvp % next enddo slp => slp % next enddo end subroutine generate_table_sl","tags":"","loc":"proc/generate_table_sl.html"},{"title":"generate_table_nl – libPSML","text":"private subroutine generate_table_nl(ps) Arguments Type Intent Optional Attributes Name type( ps_t ), intent(inout), target :: ps Contents Source Code generate_table_nl Source Code subroutine generate_table_nl ( ps ) type ( ps_t ), intent ( inout ), target :: ps type ( nonlocal_t ), pointer :: nlp type ( nlpj_t ), pointer :: nlpp integer :: nprojs if ( allocated ( ps % nl_table )) then deallocate ( ps % nl_table ) endif nprojs = 0 nlp => ps % nonlocal do while ( associated ( nlp )) nlpp => nlp % proj do while ( associated ( nlpp )) nprojs = nprojs + 1 nlpp => nlpp % next enddo nlp => nlp % next enddo allocate ( ps % nl_table ( nprojs )) nprojs = 0 nlp => ps % nonlocal do while ( associated ( nlp )) nlpp => nlp % proj do while ( associated ( nlpp )) nprojs = nprojs + 1 ps % nl_table ( nprojs )% p => nlpp nlpp => nlpp % next enddo nlp => nlp % next enddo end subroutine generate_table_nl","tags":"","loc":"proc/generate_table_nl.html"},{"title":"generate_table_wf – libPSML","text":"private subroutine generate_table_wf(ps) Arguments Type Intent Optional Attributes Name type( ps_t ), intent(inout), target :: ps Contents Source Code generate_table_wf Source Code subroutine generate_table_wf ( ps ) type ( ps_t ), intent ( inout ), target :: ps type ( wfns_t ), pointer :: wfp type ( wf_t ), pointer :: wfpp integer :: nwfns if ( allocated ( ps % wf_table )) then deallocate ( ps % wf_table ) endif nwfns = 0 wfp => ps % wavefunctions do while ( associated ( wfp )) wfpp => wfp % wf do while ( associated ( wfpp )) nwfns = nwfns + 1 wfpp => wfpp % next enddo wfp => wfp % next enddo allocate ( ps % wf_table ( nwfns )) nwfns = 0 wfp => ps % wavefunctions do while ( associated ( wfp )) wfpp => wfp % wf do while ( associated ( wfpp )) nwfns = nwfns + 1 ps % wf_table ( nwfns )% p => wfpp wfpp => wfpp % next enddo wfp => wfp % next enddo end subroutine generate_table_wf","tags":"","loc":"proc/generate_table_wf.html"},{"title":"ps_GenerateTables – libPSML","text":"public subroutine ps_GenerateTables(ps) Arguments Type Intent Optional Attributes Name type( ps_t ), intent(inout), target :: ps Contents Source Code ps_GenerateTables Source Code subroutine ps_GenerateTables ( ps ) type ( ps_t ), intent ( inout ), target :: ps call generate_table_sl ( ps ) call generate_table_nl ( ps ) call generate_table_wf ( ps ) end subroutine ps_GenerateTables","tags":"","loc":"proc/ps_generatetables.html"},{"title":"m_psml_reader – libPSML","text":"Contents Subroutines psml_reader Subroutines public subroutine psml_reader (fname, ps, debug) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: fname type( ps_t ), intent(inout), target :: ps logical, intent(in), optional :: debug","tags":"","loc":"module/m_psml_reader.html"},{"title":"m_psml_api – libPSML","text":"Procedures to handle the PSML pseudopotential format. Uses m_psml_core m_aux_aliases assoc_list assoc_list external_interfaces class_Grid Contents Variables dp global_debug global_use_effective_range sym Interfaces ps_Potential_Filter ps_Projector_Filter ps_PseudoWf_Filter Functions ps_GetLibPSMLVersion ps_Provenance_Depth ps_ValenceCharge_Value ps_CoreCharge_Value ps_GridAnnotation ps_GetValue ps_Potential_Value ps_PseudoWf_Value ps_HasProjectors ps_HasLocalPotential ps_LocalPotential_Value ps_HasPSOperator ps_HasSemilocalPotentials ps_Projector_Value l_of_sym max_range eval_radfunc Subroutines ps_SetEvaluatorOptions ps_RootAttributes_Get ps_Provenance_Get ps_PseudoAtomSpec_Get ps_ValenceConfiguration_Get ps_ValenceShell_Get ps_ValenceCharge_Get ps_CoreCharge_Get ps_ExchangeCorrelation_Get ps_LibxcFunctional_Get ps_Potential_Get ps_SemilocalPotentials_Filter ps_GetRawData ps_PseudoWaveFunctions_Filter ps_PseudoWf_Get ps_LocalPotential_Get ps_NonlocalProjectors_Filter ps_Projector_Get check_index assert Variables Type Visibility Attributes Name Initial integer, public, parameter :: dp = selected_real_kind(14) logical, public :: global_debug = .false. logical, public :: global_use_effective_range = .true. character(len=1), public, dimension(0:4) :: sym = (/\"s\", \"p\", \"d\", \"f\", \"g\"/) Interfaces public interface ps_Potential_Filter public subroutine ps_SemilocalPotentials_Filter (ps, indexes_in, l, j, n, set, indexes, number) Arguments Type Intent Optional Attributes Name type( ps_t ), intent(in), target :: ps integer, intent(in), optional :: indexes_in (:) integer, intent(in), optional :: l real(kind=dp), intent(in), optional :: j integer, intent(in), optional :: n integer, intent(in), optional :: set integer, intent(out), optional allocatable :: indexes (:) integer, intent(out), optional :: number public interface ps_Projector_Filter public subroutine ps_NonlocalProjectors_Filter (ps, indexes_in, l, j, seq, set, indexes, number) Arguments Type Intent Optional Attributes Name type( ps_t ), intent(in), target :: ps integer, intent(in), optional :: indexes_in (:) integer, intent(in), optional :: l real(kind=dp), intent(in), optional :: j integer, intent(in), optional :: seq integer, intent(in), optional :: set integer, intent(out), optional allocatable :: indexes (:) integer, intent(out), optional :: number public interface ps_PseudoWf_Filter public subroutine ps_PseudoWaveFunctions_Filter (ps, indexes_in, l, j, n, set, indexes, number) Arguments Type Intent Optional Attributes Name type( ps_t ), intent(in), target :: ps integer, intent(in), optional :: indexes_in (:) integer, intent(in), optional :: l real(kind=dp), intent(in), optional :: j integer, intent(in), optional :: n integer, intent(in), optional :: set integer, intent(out), optional allocatable :: indexes (:) integer, intent(out), optional :: number Functions public function ps_GetLibPSMLVersion () result(v) Returns the library version in integer format Arguments None Return Value integer public function ps_Provenance_Depth (ps) result(n) Arguments Type Intent Optional Attributes Name type( ps_t ), intent(in) :: ps Return Value integer public function ps_ValenceCharge_Value (ps, r) result(val) Computes the value of the valence charge at r\n @param ps is a handle to the psml information\n @param r is the radius\n It returns the valence charge density integrated over\n solid angle, so that Q_val = int{ val r r } Arguments Type Intent Optional Attributes Name type( ps_t ), intent(in) :: ps real(kind=dp), intent(in) :: r Return Value real(kind=dp) public function ps_CoreCharge_Value (ps, r) result(val) Computes the value of the pseudo-core charge at r\n @param ps is a handle to the psml information\n @param r is the radius\n It returns the pseudo-core charge density integrated over\n solid angle, so that Q_core = int{ val r r } Arguments Type Intent Optional Attributes Name type( ps_t ), intent(in) :: ps real(kind=dp), intent(in) :: r Return Value real(kind=dp) public function ps_GridAnnotation (ps, radfunc) result(annotation) Returns the annotation associated to a grid.\n If a radial function\n handle is given, the annotation for that \n radial function's grid is returned. Otherwise,\n the return value is the annotation for the global grid.\n If there is no appropriate annotation, an empty\n structure is returned.\n @param ps is a handle to the psml information\n @param radfunc is a handle to a radial function structure Arguments Type Intent Optional Attributes Name type( ps_t ), intent(in) :: ps type(ps_radfunc_t), intent(in), optional :: radfunc Return Value type(ps_annotation_t) public function ps_GetValue (f, r) result(val) Arguments Type Intent Optional Attributes Name type(ps_radfunc_t), intent(in) :: f real(kind=dp), intent(in) :: r Return Value real(kind=dp) public function ps_Potential_Value (ps, i, r) result(val) Evaluator by storage index Arguments Type Intent Optional Attributes Name type( ps_t ), intent(in) :: ps integer, intent(in) :: i real(kind=dp), intent(in) :: r Return Value real(kind=dp) public function ps_PseudoWf_Value (ps, i, r) result(val) Arguments Type Intent Optional Attributes Name type( ps_t ), intent(in) :: ps integer, intent(in) :: i real(kind=dp), intent(in) :: r Return Value real(kind=dp) public function ps_HasProjectors (ps) result(p) Arguments Type Intent Optional Attributes Name type( ps_t ), intent(in) :: ps Return Value logical public function ps_HasLocalPotential (ps) result(p) Arguments Type Intent Optional Attributes Name type( ps_t ), intent(in) :: ps Return Value logical public function ps_LocalPotential_Value (ps, r) result(val) Arguments Type Intent Optional Attributes Name type( ps_t ), intent(in) :: ps real(kind=dp), intent(in) :: r Return Value real(kind=dp) public function ps_HasPSOperator (ps) result(psop) Arguments Type Intent Optional Attributes Name type( ps_t ), intent(in) :: ps Return Value logical public function ps_HasSemilocalPotentials (ps) result(p) Arguments Type Intent Optional Attributes Name type( ps_t ), intent(in) :: ps Return Value logical public function ps_Projector_Value (ps, i, r) result(val) Arguments Type Intent Optional Attributes Name type( ps_t ), intent(in) :: ps integer, intent(in) :: i real(kind=dp), intent(in) :: r Return Value real(kind=dp) private function l_of_sym (str, name) result(l) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: str character(len=*), intent(in) :: name Return Value integer private function max_range (f) result(range) Returns the maximum radius in a radfunc's data Arguments Type Intent Optional Attributes Name type( radfunc_t ), intent(in) :: f Return Value real(kind=dp) private function eval_radfunc (f, r, debug) result(val) Arguments Type Intent Optional Attributes Name type( radfunc_t ), intent(in) :: f real(kind=dp), intent(in) :: r logical, intent(in) :: debug Return Value real(kind=dp) Subroutines public subroutine ps_SetEvaluatorOptions (quality_level, debug, use_effective_range, custom_interpolator) Sets various parameters for the operation of\n the evaluator Arguments Type Intent Optional Attributes Name integer, intent(in), optional :: quality_level logical, intent(in), optional :: debug logical, intent(in), optional :: use_effective_range procedure(interp), optional :: custom_interpolator public subroutine ps_RootAttributes_Get (ps, uuid, version, namespace, annotation) Arguments Type Intent Optional Attributes Name type( ps_t ), intent(in) :: ps character(len=*), intent(out), optional :: uuid character(len=*), intent(out), optional :: version character(len=*), intent(out), optional :: namespace type(ps_annotation_t), intent(out), optional :: annotation public subroutine ps_Provenance_Get (ps, level, creator, date, annotation, number_of_input_files) Arguments Type Intent Optional Attributes Name type( ps_t ), intent(in) :: ps integer, intent(in) :: level character(len=*), intent(out), optional :: creator character(len=*), intent(out), optional :: date type(ps_annotation_t), intent(out), optional :: annotation integer, intent(out), optional :: number_of_input_files public subroutine ps_PseudoAtomSpec_Get (ps, atomic_symbol, atomic_label, atomic_number, z_pseudo, pseudo_flavor, relativity, spin_dft, core_corrections, annotation) Arguments Type Intent Optional Attributes Name type( ps_t ), intent(in) :: ps character(len=*), intent(out), optional :: atomic_symbol character(len=*), intent(out), optional :: atomic_label real(kind=dp), intent(out), optional :: atomic_number real(kind=dp), intent(out), optional :: z_pseudo character(len=*), intent(out), optional :: pseudo_flavor character(len=*), intent(out), optional :: relativity logical, intent(out), optional :: spin_dft logical, intent(out), optional :: core_corrections type(ps_annotation_t), intent(out), optional :: annotation public subroutine ps_ValenceConfiguration_Get (ps, nshells, charge, annotation) Arguments Type Intent Optional Attributes Name type( ps_t ), intent(in) :: ps integer, intent(out), optional :: nshells real(kind=dp), intent(out), optional :: charge type(ps_annotation_t), intent(out), optional :: annotation public subroutine ps_ValenceShell_Get (ps, i, n, l, occupation, occ_up, occ_down) Arguments Type Intent Optional Attributes Name type( ps_t ), intent(in) :: ps integer, intent(in) :: i integer, intent(out), optional :: n integer, intent(out), optional :: l real(kind=dp), intent(out), optional :: occupation real(kind=dp), intent(out), optional :: occ_up real(kind=dp), intent(out), optional :: occ_down public subroutine ps_ValenceCharge_Get (ps, total_charge, is_unscreening_charge, rescaled_to_z_pseudo, annotation, func) Arguments Type Intent Optional Attributes Name type( ps_t ), intent(in) :: ps real(kind=dp), intent(out), optional :: total_charge character(len=*), intent(out), optional :: is_unscreening_charge character(len=*), intent(out), optional :: rescaled_to_z_pseudo type(ps_annotation_t), intent(out), optional :: annotation type(ps_radfunc_t), intent(out), optional :: func public subroutine ps_CoreCharge_Get (ps, rc, nderivs, annotation, func) Arguments Type Intent Optional Attributes Name type( ps_t ), intent(in) :: ps real(kind=dp), intent(out), optional :: rc integer, intent(out), optional :: nderivs type(ps_annotation_t), intent(out), optional :: annotation type(ps_radfunc_t), intent(out), optional :: func public subroutine ps_ExchangeCorrelation_Get (ps, annotation, n_libxc_functionals) Arguments Type Intent Optional Attributes Name type( ps_t ), intent(in) :: ps type(ps_annotation_t), intent(out), optional :: annotation integer, intent(out), optional :: n_libxc_functionals public subroutine ps_LibxcFunctional_Get (ps, i, name, code, type, weight) Arguments Type Intent Optional Attributes Name type( ps_t ), intent(in) :: ps integer, intent(in) :: i character(len=*), intent(out), optional :: name integer, intent(out), optional :: code character(len=*), intent(out), optional :: type real(kind=dp), intent(out), optional :: weight public subroutine ps_Potential_Get (ps, i, l, j, n, rc, set, flavor, eref, annotation, func) Arguments Type Intent Optional Attributes Name type( ps_t ), intent(in), target :: ps integer, intent(in) :: i integer, intent(out), optional :: l real(kind=dp), intent(out), optional :: j integer, intent(out), optional :: n real(kind=dp), intent(out), optional :: rc integer, intent(out), optional :: set character(len=*), intent(out), optional :: flavor real(kind=dp), intent(out), optional :: eref type(ps_annotation_t), intent(out), optional :: annotation type(ps_radfunc_t), intent(out), optional :: func public subroutine ps_SemilocalPotentials_Filter (ps, indexes_in, l, j, n, set, indexes, number) Arguments Type Intent Optional Attributes Name type( ps_t ), intent(in), target :: ps integer, intent(in), optional :: indexes_in (:) integer, intent(in), optional :: l real(kind=dp), intent(in), optional :: j integer, intent(in), optional :: n integer, intent(in), optional :: set integer, intent(out), optional allocatable :: indexes (:) integer, intent(out), optional :: number public subroutine ps_GetRawData (f, raw_r, raw_data) Arguments Type Intent Optional Attributes Name type(ps_radfunc_t), intent(in) :: f real(kind=dp), intent(out), allocatable :: raw_r (:) real(kind=dp), intent(out), allocatable :: raw_data (:) public subroutine ps_PseudoWaveFunctions_Filter (ps, indexes_in, l, j, n, set, indexes, number) Arguments Type Intent Optional Attributes Name type( ps_t ), intent(in), target :: ps integer, intent(in), optional :: indexes_in (:) integer, intent(in), optional :: l real(kind=dp), intent(in), optional :: j integer, intent(in), optional :: n integer, intent(in), optional :: set integer, intent(out), optional allocatable :: indexes (:) integer, intent(out), optional :: number public subroutine ps_PseudoWf_Get (ps, i, l, j, n, set, energy_level, annotation, func) Arguments Type Intent Optional Attributes Name type( ps_t ), intent(in), target :: ps integer, intent(in) :: i integer, intent(out), optional :: l real(kind=dp), intent(out), optional :: j integer, intent(out), optional :: n integer, intent(out), optional :: set real(kind=dp), intent(out), optional :: energy_level type(ps_annotation_t), intent(out), optional :: annotation type(ps_radfunc_t), intent(out), optional :: func public subroutine ps_LocalPotential_Get (ps, type, annotation, func, has_local_charge, func_local_charge) Arguments Type Intent Optional Attributes Name type( ps_t ), intent(in) :: ps character(len=*), intent(out), optional :: type type(ps_annotation_t), intent(out), optional :: annotation type(ps_radfunc_t), intent(out), optional :: func logical, intent(out), optional :: has_local_charge type(ps_radfunc_t), intent(out), optional :: func_local_charge public subroutine ps_NonlocalProjectors_Filter (ps, indexes_in, l, j, seq, set, indexes, number) Arguments Type Intent Optional Attributes Name type( ps_t ), intent(in), target :: ps integer, intent(in), optional :: indexes_in (:) integer, intent(in), optional :: l real(kind=dp), intent(in), optional :: j integer, intent(in), optional :: seq integer, intent(in), optional :: set integer, intent(out), optional allocatable :: indexes (:) integer, intent(out), optional :: number public subroutine ps_Projector_Get (ps, i, l, j, seq, set, ekb, eref, type, annotation, func) Arguments Type Intent Optional Attributes Name type( ps_t ), intent(in), target :: ps integer, intent(in) :: i integer, intent(out), optional :: l real(kind=dp), intent(out), optional :: j integer, intent(out), optional :: seq integer, intent(out), optional :: set real(kind=dp), intent(out), optional :: ekb real(kind=dp), intent(out), optional :: eref character(len=*), intent(out), optional :: type type(ps_annotation_t), intent(out), optional :: annotation type(ps_radfunc_t), intent(out), optional :: func private subroutine check_index (i, n, str) Arguments Type Intent Optional Attributes Name integer, intent(in) :: i integer, intent(in) :: n character(len=*), intent(in) :: str private subroutine assert (cond, message) Arguments Type Intent Optional Attributes Name logical, intent(in) :: cond character(len=*) :: message","tags":"","loc":"module/m_psml_api.html"},{"title":"m_psml_dump – libPSML","text":"Functions to handle PSML pseudopotential format structures\n @author Alberto Garcia Uses m_psml_core assoc_list class_Grid external_interfaces Contents Variables dp global_debug sym Subroutines ps_DumpToPSMLFile dump_provenance dump_xc_info dump_config_val dump_pseudo_atom_spec dump_radfunc dump_valence_charge dump_core_charge dump_semilocal_potentials dump_local_potential dump_nonlocal_projectors dump_pseudo_wavefunctions dump_grid dump_annotation my_add_attribute Variables Type Visibility Attributes Name Initial integer, public, parameter :: dp = selected_real_kind(14) logical, public :: global_debug = .false. character(len=1), public, dimension(0:4) :: sym = (/\"s\", \"p\", \"d\", \"f\", \"g\"/) Subroutines public subroutine ps_DumpToPSMLFile (ps, fname, indent) Arguments Type Intent Optional Attributes Name type( ps_t ), intent(in) :: ps character(len=*), intent(in) :: fname logical, intent(in), optional :: indent private subroutine dump_provenance (xf, p) Arguments Type Intent Optional Attributes Name type(xmlf_t), intent(inout) :: xf type( provenance_t ), pointer :: p private subroutine dump_xc_info (xf, p) Arguments Type Intent Optional Attributes Name type(xmlf_t), intent(inout) :: xf type( xc_t ), intent(in) :: p private subroutine dump_config_val (xf, p) Arguments Type Intent Optional Attributes Name type(xmlf_t), intent(inout) :: xf type( config_val_t ), intent(in) :: p private subroutine dump_pseudo_atom_spec (xf, ps) Arguments Type Intent Optional Attributes Name type(xmlf_t), intent(inout) :: xf type( ps_t ), intent(in), target :: ps private subroutine dump_radfunc (xf, rf, parent_grid) Arguments Type Intent Optional Attributes Name type(xmlf_t), intent(inout) :: xf type( radfunc_t ), intent(in) :: rf type(Grid_t) :: parent_grid private subroutine dump_valence_charge (xf, val, parent_grid) Arguments Type Intent Optional Attributes Name type(xmlf_t), intent(inout) :: xf type( valence_charge_t ), intent(in) :: val type(Grid_t) :: parent_grid private subroutine dump_core_charge (xf, core, parent_grid) Arguments Type Intent Optional Attributes Name type(xmlf_t), intent(inout) :: xf type( core_charge_t ), intent(in) :: core type(Grid_t) :: parent_grid private subroutine dump_semilocal_potentials (xf, ps) Arguments Type Intent Optional Attributes Name type(xmlf_t), intent(inout) :: xf type( ps_t ), intent(in), target :: ps private subroutine dump_local_potential (xf, ps) Arguments Type Intent Optional Attributes Name type(xmlf_t), intent(inout) :: xf type( ps_t ), intent(in), target :: ps private subroutine dump_nonlocal_projectors (xf, ps) Arguments Type Intent Optional Attributes Name type(xmlf_t), intent(inout) :: xf type( ps_t ), intent(in), target :: ps private subroutine dump_pseudo_wavefunctions (xf, ps) Arguments Type Intent Optional Attributes Name type(xmlf_t), intent(inout) :: xf type( ps_t ), intent(in), target :: ps private subroutine dump_grid (xf, agrid) Arguments Type Intent Optional Attributes Name type(xmlf_t), intent(inout) :: xf type(Grid_t), intent(in) :: agrid private subroutine dump_annotation (xf, annotation) Arguments Type Intent Optional Attributes Name type(xmlf_t), intent(inout) :: xf type(ps_annotation_t), intent(in) :: annotation private subroutine my_add_attribute (xf, name, value) Arguments Type Intent Optional Attributes Name type(xmlf_t), intent(inout) :: xf character(len=*), intent(in) :: name character(len=*), intent(in) :: value","tags":"","loc":"module/m_psml_dump.html"},{"title":"class_Grid – libPSML","text":"Uses assoc_list assoc_list Contents Variables mod_name dp Interfaces print_type assignment(=) init delete refcount id name initialized same psml_die Derived Types Grid_ Grid Functions initialized_ same_ refcount_ id_ name_ valGrid annotationGrid sizeGrid Subroutines init_ delete_ assign_ tag_new_object delete_Data newGrid printGrid Variables Type Visibility Attributes Name Initial character(len=*), public, parameter :: mod_name = \"Grid\" integer, public, parameter :: dp = selected_real_kind(10, 100) Interfaces public interface print_type private subroutine printGrid (this) Arguments Type Intent Optional Attributes Name type( Grid ), intent(in) :: this public interface assignment(=) private subroutine assign_ (this, other) Arguments Type Intent Optional Attributes Name type( Grid ), intent(inout) :: this type( Grid ), intent(in) :: other public interface init private subroutine init_ (this) Arguments Type Intent Optional Attributes Name type( Grid ), intent(inout) :: this public interface delete private subroutine delete_ (this) Arguments Type Intent Optional Attributes Name type( Grid ), intent(inout) :: this public interface refcount private function refcount_ (this) result(count) Arguments Type Intent Optional Attributes Name type( Grid ), intent(in) :: this Return Value integer public interface id private function id_ (this) result(str) Arguments Type Intent Optional Attributes Name type( Grid ), intent(in) :: this Return Value character(len=36) public interface name private function name_ (this) result(str) Arguments Type Intent Optional Attributes Name type( Grid ), intent(in) :: this Return Value character(len=len_trim(this%data%name)) public interface initialized private pure function initialized_ (this) result(init) Arguments Type Intent Optional Attributes Name type( Grid ), intent(in) :: this Return Value logical public interface same private pure function same_ (this1, this2) result(same) Arguments Type Intent Optional Attributes Name type( Grid ), intent(in) :: this1 type( Grid ), intent(in) :: this2 Return Value logical interface private subroutine psml_die(str) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: str Derived Types type, public :: Grid_ Components Type Visibility Attributes Name Initial integer, public :: refCount = 0 character(len=36), public :: id = \"null_id\" character(len=256), public :: name = \"null Grid\" integer, public :: npts = 0 real(kind=dp), public, pointer :: grid_data (:) => null() type(ps_annotation_t), public :: annotation type, public :: Grid Components Type Visibility Attributes Name Initial type( Grid_ ), public, pointer :: data => null() Functions private pure function initialized_ (this) result(init) Arguments Type Intent Optional Attributes Name type( Grid ), intent(in) :: this Return Value logical private pure function same_ (this1, this2) result(same) Arguments Type Intent Optional Attributes Name type( Grid ), intent(in) :: this1 type( Grid ), intent(in) :: this2 Return Value logical private function refcount_ (this) result(count) Arguments Type Intent Optional Attributes Name type( Grid ), intent(in) :: this Return Value integer private function id_ (this) result(str) Arguments Type Intent Optional Attributes Name type( Grid ), intent(in) :: this Return Value character(len=36) private function name_ (this) result(str) Arguments Type Intent Optional Attributes Name type( Grid ), intent(in) :: this Return Value character(len=len_trim(this%data%name)) public function valGrid (this) result(p) Arguments Type Intent Optional Attributes Name type( Grid ), intent(in) :: this Return Value real(kind=dp),\n  pointer, (:) public function annotationGrid (this) result(p) Arguments Type Intent Optional Attributes Name type( Grid ), intent(in) :: this Return Value type(ps_annotation_t),\n  pointer public function sizeGrid (this) result(n) Arguments Type Intent Optional Attributes Name type( Grid ), intent(in) :: this Return Value integer Subroutines private subroutine init_ (this) Arguments Type Intent Optional Attributes Name type( Grid ), intent(inout) :: this private subroutine delete_ (this) Arguments Type Intent Optional Attributes Name type( Grid ), intent(inout) :: this private subroutine assign_ (this, other) Arguments Type Intent Optional Attributes Name type( Grid ), intent(inout) :: this type( Grid ), intent(in) :: other private subroutine tag_new_object (this) Arguments Type Intent Optional Attributes Name type( Grid ), intent(inout) :: this private subroutine delete_Data (gd) Arguments Type Intent Optional Attributes Name type( Grid_ ) :: gd public subroutine newGrid (this, n, name) Arguments Type Intent Optional Attributes Name type( Grid ), intent(inout) :: this integer, intent(in) :: n character(len=*), intent(in), optional :: name private subroutine printGrid (this) Arguments Type Intent Optional Attributes Name type( Grid ), intent(in) :: this","tags":"","loc":"module/class_grid.html"},{"title":"assoc_list – libPSML","text":"Contents Variables EMPTY_ASSOC_LIST Interfaces assoc_list_get_value Derived Types assoc_list_t Functions assoc_list_nitems Subroutines assoc_list_init assoc_list_reset assoc_list_insert assoc_list_get_key assoc_list_get_value_of_key assoc_list_get_value_by_index assoc_list_print Variables Type Visibility Attributes Name Initial type( assoc_list_t ), protected, save :: EMPTY_ASSOC_LIST Interfaces public interface assoc_list_get_value public subroutine assoc_list_get_value_by_index (a, i, value, stat) Arguments Type Intent Optional Attributes Name type( assoc_list_t ), intent(in) :: a integer, intent(in) :: i character(len=*), intent(out) :: value integer, intent(out) :: stat public subroutine assoc_list_get_value_of_key (a, key, value, stat) Arguments Type Intent Optional Attributes Name type( assoc_list_t ), intent(in) :: a character(len=*), intent(in) :: key character(len=*), intent(out) :: value integer, intent(out) :: stat Derived Types type, public :: assoc_list_t Components Type Visibility Attributes Name Initial integer, private :: nslots = 0 integer, private :: nitems = 0 character(len=200), private, allocatable :: key (:) character(len=1000), private, allocatable :: value (:) Functions public function assoc_list_nitems (a) result(n) Arguments Type Intent Optional Attributes Name type( assoc_list_t ), intent(in) :: a Return Value integer Subroutines public subroutine assoc_list_init (a, n, stat) Arguments Type Intent Optional Attributes Name type( assoc_list_t ), intent(inout) :: a integer, intent(in) :: n integer, intent(out) :: stat public subroutine assoc_list_reset (a) Arguments Type Intent Optional Attributes Name type( assoc_list_t ), intent(inout) :: a public subroutine assoc_list_insert (a, key, value, stat) Arguments Type Intent Optional Attributes Name type( assoc_list_t ), intent(inout) :: a character(len=*), intent(in) :: key character(len=*), intent(in) :: value integer, intent(out) :: stat public subroutine assoc_list_get_key (a, i, key, stat) Arguments Type Intent Optional Attributes Name type( assoc_list_t ), intent(in) :: a integer, intent(in) :: i character(len=*), intent(out) :: key integer, intent(out) :: stat public subroutine assoc_list_get_value_of_key (a, key, value, stat) Arguments Type Intent Optional Attributes Name type( assoc_list_t ), intent(in) :: a character(len=*), intent(in) :: key character(len=*), intent(out) :: value integer, intent(out) :: stat public subroutine assoc_list_get_value_by_index (a, i, value, stat) Arguments Type Intent Optional Attributes Name type( assoc_list_t ), intent(in) :: a integer, intent(in) :: i character(len=*), intent(out) :: value integer, intent(out) :: stat public subroutine assoc_list_print (a) Arguments Type Intent Optional Attributes Name type( assoc_list_t ), intent(in) :: a","tags":"","loc":"module/assoc_list.html"},{"title":"m_psml_core – libPSML","text":"Uses assoc_list assoc_list class_Grid external_interfaces Contents Variables PATCH_LEVEL PSML_LIBRARY_VERSION PSML_TARGET_VERSION_LO PSML_TARGET_VERSION_HI MAXN_SHELLS dp SET_NULL SET_SREL SET_NONREL SET_SO SET_LJ SET_UP SET_DOWN SET_SPINAVE SET_SPINDIFF SET_USER1 SET_USER2 SET_ALL Derived Types input_file_t provenance_t header_t config_val_t xc_t radfunc_t slps_t sl_table_t semilocal_t local_t nlpj_t nl_table_t nonlocal_t wf_t wf_table_t wfns_t valence_charge_t core_charge_t ps_t Functions setcode_of_string str_of_set Subroutines ps_destroy destroy_provenance destroy_semilocal destroy_slps destroy_local destroy_nonlocal destroy_nlpj destroy_wavefunctions destroy_pswf destroy_radfunc destroy_xc Variables Type Visibility Attributes Name Initial integer, private, parameter :: PATCH_LEVEL = 7 integer, public, parameter :: PSML_LIBRARY_VERSION = 1100+PATCH_LEVEL real, public, parameter :: PSML_TARGET_VERSION_LO = 1.00 real, public, parameter :: PSML_TARGET_VERSION_HI = 1.10 integer, private, parameter :: MAXN_SHELLS = 20 integer, private, parameter :: dp = selected_real_kind(14) integer, public, parameter :: SET_NULL = 0 integer, public, parameter :: SET_SREL = 1 integer, public, parameter :: SET_NONREL = 2 integer, public, parameter :: SET_SO = 4 integer, public, parameter :: SET_LJ = 8 integer, public, parameter :: SET_UP = 16 integer, public, parameter :: SET_DOWN = 32 integer, public, parameter :: SET_SPINAVE = 64 integer, public, parameter :: SET_SPINDIFF = 128 integer, public, parameter :: SET_USER1 = 256 integer, public, parameter :: SET_USER2 = 512 integer, public, parameter :: SET_ALL = 2**10-1 Derived Types type, public :: input_file_t Components Type Visibility Attributes Name Initial character(len=100), public :: name = \"-----\" character(len=:), public, allocatable :: buffer type, public :: provenance_t Components Type Visibility Attributes Name Initial type( provenance_t ), public, pointer :: prev => null() integer, public :: record_number character(len=100), public :: creator = \"-----\" character(len=60), public :: date = \"-----\" integer, public :: n_input_files = 0 type( input_file_t ), public :: input_file type(ps_annotation_t), public :: annotation type( provenance_t ), public, pointer :: next => null() type, public :: header_t Components Type Visibility Attributes Name Initial character(len=100), public :: atomic_label real(kind=dp), public :: z real(kind=dp), public :: zpseudo character(len=100), public :: flavor character(len=6), public :: relativity logical, public :: polarized character(len=3), public :: core_corrections type(ps_annotation_t), public :: annotation type, public :: config_val_t Components Type Visibility Attributes Name Initial integer, public :: nshells real(kind=dp), public :: total_charge integer, public, dimension(MAXN_SHELLS) :: n character(len=1), public, dimension(MAXN_SHELLS) :: l real(kind=dp), public, dimension(MAXN_SHELLS) :: occ real(kind=dp), public, dimension(MAXN_SHELLS) :: occ_up real(kind=dp), public, dimension(MAXN_SHELLS) :: occ_down type(ps_annotation_t), public :: annotation type, public :: xc_t Components Type Visibility Attributes Name Initial integer, public :: n_functs_libxc = 0 character(len=200), public, allocatable :: libxc_name (:) character(len=100), public, allocatable :: libxc_type (:) integer, public, allocatable :: libxc_id (:) real(kind=dp), public, allocatable :: libxc_weight (:) type(ps_annotation_t), public :: annotation type, public :: radfunc_t Components Type Visibility Attributes Name Initial type(Grid), public :: grid real(kind=dp), public, dimension(:), pointer :: data => null() logical, public :: has_coulomb_tail real(kind=dp), public :: tail_factor = 0.0_dp integer, public :: nnz real(kind=dp), public :: rcut_eff type, public :: slps_t Components Type Visibility Attributes Name Initial integer, public :: n character(len=1), public :: l real(kind=dp), public :: j = -1.0_dp integer, public :: set character(len=100), public :: flavor real(kind=dp), public :: rc real(kind=dp), public :: eref type( radfunc_t ), public :: V type( semilocal_t ), public, pointer :: parent_group => null() type( slps_t ), public, pointer :: next => null() type, public :: sl_table_t Components Type Visibility Attributes Name Initial type( slps_t ), public, pointer :: p => null() type, public :: semilocal_t Components Type Visibility Attributes Name Initial type( slps_t ), public, pointer :: pot => null() integer, public :: set type(Grid), public :: grid type(ps_annotation_t), public :: annotation type( semilocal_t ), public, pointer :: next => null() type, public :: local_t Components Type Visibility Attributes Name Initial type(ps_annotation_t), public :: annotation type(Grid), public :: grid type( radfunc_t ), public :: Vlocal character(len=100), public :: vlocal_type type( radfunc_t ), public :: Chlocal type, public :: nlpj_t Components Type Visibility Attributes Name Initial integer, public :: seq character(len=1), public :: l real(kind=dp), public :: j = -1.0_dp integer, public :: set character(len=100), public :: type real(kind=dp), public :: ekb real(kind=dp), public :: eref type( radfunc_t ), public :: proj type( nonlocal_t ), public, pointer :: parent_group => null() type( nlpj_t ), public, pointer :: next => null() type, public :: nl_table_t Components Type Visibility Attributes Name Initial type( nlpj_t ), public, pointer :: p => null() type, public :: nonlocal_t Components Type Visibility Attributes Name Initial type( nlpj_t ), public, pointer :: proj => null() integer, public :: set type(Grid), public :: grid type(ps_annotation_t), public :: annotation type( nonlocal_t ), public, pointer :: next => null() type, public :: wf_t Components Type Visibility Attributes Name Initial integer, public :: n character(len=1), public :: l integer, public :: set real(kind=dp), public :: j = -1.0_dp real(kind=dp), public :: energy_level type( radfunc_t ), public :: Phi type( wfns_t ), public, pointer :: parent_group => null() type( wf_t ), public, pointer :: next => null() type, public :: wf_table_t Components Type Visibility Attributes Name Initial type( wf_t ), public, pointer :: p => null() type, public :: wfns_t Components Type Visibility Attributes Name Initial type( wf_t ), public, pointer :: wf => null() integer, public :: set character(len=100), public :: type = \"\" type(Grid), public :: grid type(ps_annotation_t), public :: annotation type( wfns_t ), public, pointer :: next => null() type, public :: valence_charge_t Components Type Visibility Attributes Name Initial real(kind=dp), public :: total_charge character(len=3), public :: is_unscreening_charge = \"\" character(len=3), public :: rescaled_to_z_pseudo = \"\" type( radfunc_t ), public :: rho_val type(ps_annotation_t), public :: annotation type, public :: core_charge_t Components Type Visibility Attributes Name Initial integer, public :: n_cont_derivs real(kind=dp), public :: rcore type( radfunc_t ), public :: rho_core type(ps_annotation_t), public :: annotation type, public :: ps_t Components Type Visibility Attributes Name Initial character(len=10), public :: version = \"\" character(len=40), public :: energy_unit = \"\" character(len=40), public :: length_unit = \"\" character(len=36), public :: uuid = \"\" character(len=200), public :: namespace = \"\" type(ps_annotation_t), public :: annotation type( provenance_t ), public, pointer :: provenance => null() type( header_t ), public :: header type( config_val_t ), public :: config_val type( config_val_t ), public :: config_core type( xc_t ), public :: xc_info type(Grid), public :: global_grid type( local_t ), public :: local type( semilocal_t ), public, pointer :: semilocal => null() type( nonlocal_t ), public, pointer :: nonlocal => null() type( wfns_t ), public, pointer :: wavefunctions => null() type( valence_charge_t ), public :: valence_charge type( core_charge_t ), public :: core_charge type( sl_table_t ), public, allocatable :: sl_table (:) type( nl_table_t ), public, allocatable :: nl_table (:) type( wf_table_t ), public, allocatable :: wf_table (:) Functions public function setcode_of_string (str) result(code) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: str Return Value integer public function str_of_set (code) result(str) Arguments Type Intent Optional Attributes Name integer, intent(in) :: code Return Value character(len=40) Subroutines public subroutine ps_destroy (ps) Arguments Type Intent Optional Attributes Name type( ps_t ), intent(inout) :: ps private subroutine destroy_provenance (p) Arguments Type Intent Optional Attributes Name type( provenance_t ), pointer :: p private subroutine destroy_semilocal (p) Arguments Type Intent Optional Attributes Name type( semilocal_t ), pointer :: p private subroutine destroy_slps (p) Arguments Type Intent Optional Attributes Name type( slps_t ), pointer :: p public subroutine destroy_local (p) Arguments Type Intent Optional Attributes Name type( local_t ) :: p public subroutine destroy_nonlocal (p) Arguments Type Intent Optional Attributes Name type( nonlocal_t ), pointer :: p private subroutine destroy_nlpj (p) Arguments Type Intent Optional Attributes Name type( nlpj_t ), pointer :: p public subroutine destroy_wavefunctions (p) Arguments Type Intent Optional Attributes Name type( wfns_t ), pointer :: p private subroutine destroy_pswf (p) Arguments Type Intent Optional Attributes Name type( wf_t ), pointer :: p private subroutine destroy_radfunc (rp) Arguments Type Intent Optional Attributes Name type( radfunc_t ) :: rp private subroutine destroy_xc (xp) Arguments Type Intent Optional Attributes Name type( xc_t ), intent(inout) :: xp","tags":"","loc":"module/m_psml_core.html"},{"title":"m_psml_interp – libPSML","text":"Contents Variables nq interpolator Interfaces interpolate Subroutines set_interpolator set_default_interpolator dpnint1 Variables Type Visibility Attributes Name Initial integer, public, save :: nq = 7 procedure( interpolate ), public, pointer :: interpolator => null() Interfaces interface public subroutine interpolate(nquality, x, y, npts, r, val, debug) Arguments Type Intent Optional Attributes Name integer, intent(in) :: nquality real(kind=dp), intent(in) :: x (*) real(kind=dp), intent(in) :: y (*) integer, intent(in) :: npts real(kind=dp), intent(in) :: r real(kind=dp), intent(out) :: val logical, intent(in) :: debug Subroutines public subroutine set_interpolator (func, nquality) Arguments Type Intent Optional Attributes Name public subroutine func(nquality, x, y, npts, r, val, debug) Arguments Type Intent Optional Attributes Name integer, intent(in) :: nquality real(kind=dp), intent(in) :: x (*) real(kind=dp), intent(in) :: y (*) integer, intent(in) :: npts real(kind=dp), intent(in) :: r real(kind=dp), intent(out) :: val logical, intent(in) :: debug integer, intent(in) :: nquality public subroutine set_default_interpolator () Arguments None private subroutine dpnint1 (npoly, xx, yy, nn, r, val, debug) Arguments Type Intent Optional Attributes Name integer, intent(in) :: npoly real(kind=dp), intent(in) :: xx (*) real(kind=dp), intent(in) :: yy (*) integer, intent(in) :: nn real(kind=dp), intent(in) :: r real(kind=dp), intent(out) :: val logical, intent(in) :: debug","tags":"","loc":"module/m_psml_interp.html"},{"title":"m_psml_parsing_helpers – libPSML","text":"Uses m_psml_core external_interfaces class_Grid assoc_list strings_helpers Contents Variables pseudo debug_parsing in_psml in_slps in_radfunc in_semilocal in_header in_coreCharge in_data in_grid_data in_grid in_valenceCharge in_provenance in_input_file in_valence_config in_xc in_libxc_info in_pseudowavefun in_pswf in_chlocal in_nonlocal in_proj in_local_potential got_explicit_grid_data ndata ndata_grid n_funct current_wf_set current_sl_set current_proj_set top_flavor dp zval_generation tmp_grid gdata gannot pp qp ifp hp cp xp wfp qwfp wfpp qwfpp slp qslp slvp qslvp lop nlp qnlp nlpp qnlpp valp corep rp parent_element npts_data Functions approx Subroutines begin_element end_element pcdata_chunk cdata_section_chunk save_annotation Variables Type Visibility Attributes Name Initial type( ps_t ), public, pointer, save :: pseudo => null() logical, public, save :: debug_parsing = .false. logical, private, save :: in_psml = .false. logical, private, save :: in_slps = .false. logical, private, save :: in_radfunc = .false. logical, private, save :: in_semilocal = .false. logical, private, save :: in_header = .false. logical, private, save :: in_coreCharge = .false. logical, private, save :: in_data = .false. logical, private, save :: in_grid_data = .false. logical, private, save :: in_grid = .false. logical, private, save :: in_valenceCharge = .false. logical, private, save :: in_provenance = .false. logical, private, save :: in_input_file = .false. logical, private, save :: in_valence_config = .false. logical, private, save :: in_xc = .false. logical, private, save :: in_libxc_info = .false. logical, private, save :: in_pseudowavefun = .false. logical, private, save :: in_pswf = .false. logical, private, save :: in_chlocal = .false. logical, private, save :: in_nonlocal = .false. logical, private, save :: in_proj = .false. logical, private, save :: in_local_potential = .false. logical, private, save :: got_explicit_grid_data integer, private, save :: ndata integer, private, save :: ndata_grid integer, private, save :: n_funct character(len=20), private, save :: current_wf_set character(len=20), private, save :: current_sl_set character(len=20), private, save :: current_proj_set character(len=40), private, save :: top_flavor integer, private, parameter :: dp = selected_real_kind(14) real(kind=dp), private, save :: zval_generation type(Grid), private, save :: tmp_grid real(kind=dp), private, save, pointer :: gdata (:) => null() type(ps_annotation_t), private, save, pointer :: gannot => null() type( provenance_t ), private, pointer :: pp => null() type( provenance_t ), private, pointer :: qp => null() type( input_file_t ), private, pointer :: ifp => null() type( header_t ), private, pointer :: hp => null() type( config_val_t ), private, pointer :: cp => null() type( xc_t ), private, pointer :: xp => null() type( wfns_t ), private, pointer :: wfp => null() type( wfns_t ), private, pointer :: qwfp => null() type( wf_t ), private, pointer :: wfpp => null() type( wf_t ), private, pointer :: qwfpp => null() type( semilocal_t ), private, pointer :: slp => null() type( semilocal_t ), private, pointer :: qslp => null() type( slps_t ), private, pointer :: slvp => null() type( slps_t ), private, pointer :: qslvp => null() type( local_t ), private, pointer :: lop => null() type( nonlocal_t ), private, pointer :: nlp => null() type( nonlocal_t ), private, pointer :: qnlp => null() type( nlpj_t ), private, pointer :: nlpp => null() type( nlpj_t ), private, pointer :: qnlpp => null() type( valence_charge_t ), private, pointer :: valp => null() type( core_charge_t ), private, pointer :: corep => null() type( radfunc_t ), private, pointer :: rp => null() character(len=100), private, save :: parent_element = \"\" integer, private :: npts_data Functions private function approx (x, y, tol) result(is_close) Arguments Type Intent Optional Attributes Name real(kind=dp), intent(in) :: x real(kind=dp), intent(in) :: y real(kind=dp), intent(in) :: tol Return Value logical Subroutines public subroutine begin_element (name, attributes) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: name type(dictionary_t), intent(in) :: attributes public subroutine end_element (name) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: name public subroutine pcdata_chunk (chunk) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: chunk public subroutine cdata_section_chunk (chunk) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: chunk private subroutine save_annotation (atts, annotation) Arguments Type Intent Optional Attributes Name type(dictionary_t), intent(in) :: atts type(ps_annotation_t), intent(out) :: annotation","tags":"","loc":"module/m_psml_parsing_helpers.html"},{"title":"external_interfaces – libPSML","text":"Contents Interfaces psml_die Interfaces interface public subroutine psml_die(str) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: str","tags":"","loc":"module/external_interfaces.html"},{"title":"m_aux_aliases – libPSML","text":"Uses m_psml_core Contents None","tags":"","loc":"module/m_aux_aliases.html"},{"title":"m_psml – libPSML","text":"Uses m_psml_reader m_psml_core m_psml_core m_psml_core m_psml_core m_psml_api m_psml_dump m_psml_ps_edit m_psml_core assoc_list assoc_list assoc_list assoc_list assoc_list assoc_list assoc_list assoc_list assoc_list class_Grid Contents Variables ps_real_kind Variables Type Visibility Attributes Name Initial integer, public, parameter :: ps_real_kind = selected_real_kind(10, 100)","tags":"","loc":"module/m_psml.html"},{"title":"m_psml_ps_edit – libPSML","text":"Functions to edit the PSML ps_t structure\n @author Alberto Garcia Uses m_psml_core external_interfaces assoc_list Contents Interfaces ps_Provenance_Add ps_NonLocalProjectors_Delete ps_LocalPotential_Delete Subroutines ps_RootAttributes_Set ps_SetPSMLVersion ps_SetUUID ps_AddProvenanceRecord ps_Delete_NonlocalProjectors ps_Delete_LocalPotential Interfaces public interface ps_Provenance_Add public subroutine ps_AddProvenanceRecord (ps, creator, date, annotation) Arguments Type Intent Optional Attributes Name type( ps_t ), intent(inout) :: ps character(len=*), intent(in) :: creator character(len=*), intent(in) :: date type(ps_annotation_t), intent(in), target :: annotation public interface ps_NonLocalProjectors_Delete public subroutine ps_Delete_NonlocalProjectors (ps) Arguments Type Intent Optional Attributes Name type( ps_t ), intent(inout) :: ps public interface ps_LocalPotential_Delete public subroutine ps_Delete_LocalPotential (ps) Arguments Type Intent Optional Attributes Name type( ps_t ), intent(inout) :: ps Subroutines public subroutine ps_RootAttributes_Set (ps, version, uuid, namespace) Arguments Type Intent Optional Attributes Name type( ps_t ), intent(inout) :: ps character(len=*), intent(in), optional :: version character(len=*), intent(in), optional :: uuid character(len=*), intent(in), optional :: namespace public subroutine ps_SetPSMLVersion (ps, version) Arguments Type Intent Optional Attributes Name type( ps_t ), intent(inout) :: ps character(len=*), intent(in) :: version public subroutine ps_SetUUID (ps, id) Arguments Type Intent Optional Attributes Name type( ps_t ), intent(inout) :: ps character(len=36), intent(in) :: id public subroutine ps_AddProvenanceRecord (ps, creator, date, annotation) Arguments Type Intent Optional Attributes Name type( ps_t ), intent(inout) :: ps character(len=*), intent(in) :: creator character(len=*), intent(in) :: date type(ps_annotation_t), intent(in), target :: annotation public subroutine ps_Delete_NonlocalProjectors (ps) Arguments Type Intent Optional Attributes Name type( ps_t ), intent(inout) :: ps public subroutine ps_Delete_LocalPotential (ps) Arguments Type Intent Optional Attributes Name type( ps_t ), intent(inout) :: ps","tags":"","loc":"module/m_psml_ps_edit.html"},{"title":"m_psml_tables – libPSML","text":"Functions to handle PSML pseudopotential format structures\n @author Alberto Garcia Uses m_psml_core Contents Subroutines generate_table_sl generate_table_nl generate_table_wf ps_GenerateTables Subroutines private subroutine generate_table_sl (ps) Arguments Type Intent Optional Attributes Name type( ps_t ), intent(inout), target :: ps private subroutine generate_table_nl (ps) Arguments Type Intent Optional Attributes Name type( ps_t ), intent(inout), target :: ps private subroutine generate_table_wf (ps) Arguments Type Intent Optional Attributes Name type( ps_t ), intent(inout), target :: ps public subroutine ps_GenerateTables (ps) Arguments Type Intent Optional Attributes Name type( ps_t ), intent(inout), target :: ps","tags":"","loc":"module/m_psml_tables.html"},{"title":"test_assoc – libPSML","text":"Uses assoc_list Contents Variables a b k v val stat Source Code test_assoc Variables Type Attributes Name Initial type( assoc_list_t ) :: a type( assoc_list_t ) :: b character(len=100) :: k character(len=100) :: v character(len=100) :: val integer :: stat Source Code program test_assoc use assoc_list type ( assoc_list_t ) :: a , b character ( len = 100 ) :: k , v , val integer :: stat do i = 1 , 20 write ( k , \"(a,i0)\" ) \"key_\" , i write ( v , \"(a,i0)\" ) \"val_\" , i call assoc_list_insert ( a , k , v , stat ) end do call assoc_list_get_value ( a , 10 , val , stat ) b = a print * , trim ( val ) call assoc_list_get_value ( b , 20 , val , stat ) print * , trim ( val ) end program test_assoc","tags":"","loc":"program/test_assoc.html"},{"title":"Overview – libPSML","text":"Several well-known programs generate pseudopotentials in a variety of\nformats, tailored to the needs of electronic-structure codes. While\nsome generators are now able to output data in different bespoke\nformats, and some simulation codes are now able to read different\npseudopotential formats, the common historical pattern in the design\nof those formats has been that a generator produced data for a single\nparticular simulation code, most likely maintained by the same\ngroup. This implied that a number of implicit assumptions, shared by\ngenerator and user, have gone into the formats and fossilized there. This leads to practical problems, not only of programming, but of\ninteroperability and reproducibility, which depend on spelling out\nquite a number of details which are not well represented for all codes\nin existing formats. PSML (for PSeudopotential Markup Language) is a file format for\nnorm-conserving pseudopotential data which is designed to encapsulate\nas much as possible the abstract concepts in the domain's ontology,\nand to provide appropriate metadata and provenance information. The software library libPSML can be used by electronic structure codes\nto transparently extract the information in a PSML file and adapt it\nto their own data structures, or to create converters for other\nformats. A full description of PSML and its design principles has been published\nin: The psml format and library for norm-conserving pseudopotential\n  data curation and interoperability, by Alberto García, Matthieu J. Verstraete, Yann Pouillon, and Javier Junquera Comput. Phys. Comm., 227 (2018) 51–71 A preprint is also available in arXiv . PSML description libPSML user guide","tags":"","loc":"page//index.html"},{"title":"PSML description – libPSML","text":"PSML is a file format for norm-conserving\npseudopotential data which is designed to encapsulate as much as\npossible the concepts in the domain’s ontology. For example,\nthe format, together with its supporting processing library, offers a\nvery good approximation to an abstract mathematical function (an object\nwhich produces a value from its input). PSML also provides a rich\nset of metadata to document the provenance (i.e., the generation\nhistory) and the generation conditions and flavor of the\npseudopotential. The format is based on XML, and it is by\nnature extensible, offering a basic set of elements and a number of\nextra features that can be exploited for sophisticated uses or future\nimprovements. As first steps in the implementation of the PSML vision, we have modified two\ndifferent atomic pseudopotential generation codes to generate PSML\nfiles, and interfaced libPSML to two electronic-structure programs. Example PSML files can be found in the examples directory of the\nlibPSML distribution, and also in the databases of\npseudopotentials that support the format. Pseudopotential generators supporting PSML First-principles codes able to read PSML files Schema for PSML Databases of PSML files","tags":"","loc":"page/01_the_psml_format/index.html"},{"title":"Pseudopotential generators supporting PSML – libPSML","text":"ONCVPSP The first generator is the open-source ONCVPSP code implemented by D. Hamann to\ngenerate optimized multiple-projector norm-conserving\npseudopotentials. The projectors are directly stored in the PSML\nformat together with a choice for the local potential. In addition, a\nset of semi-local potentials, a by-product of the ONCVPSP algorithm,\nis also included in the PSML file. Versions of ONCVPSP able to produce\nPSML files are available in Gitlab . To ease the production\nof XML, a special library (wxml, part of the xmlf90\nproject maintained by one of the\nauthors (A.G.)) is used. ATOM The second generator enabled for PSML output is the ATOM code,\noriginally developed by S. Froyen, later modified by N. Troullier and\nJ. L. Martins, and currently maintained by one of us (A. G.)  within\nthe SIESTA project.  ATOM, freely\ndistributed to the academic community, generates norm-conserving\npseudopotentials in the semilocal form. In addition, we have developed a post-processing tool (PSOP, currently\navailable in a branch of SIESTA development) which takes as input the semilocal components\nand computes the local part of the pseudopotential and the KB\nprojector functions in the same way as it is done within the SIESTA\ncode. These new elements, together with a new provenance record, are\nincorporated in a new PSML file, which describes a well-defined,\nclient-code independent and unique operator. We have thus already two different generators of PSML files, their\nspecific idiosyncrasies being describable by a common standard. Our\nplans are to enable PSML output in other pseudopotential-generation\ncodes.","tags":"","loc":"page/01_the_psml_format/01_generators/index.html"},{"title":"First-principles codes able to read PSML files – libPSML","text":"On the client side, we have incorporated the libPSML library in SIESTA\nand ABINIT. PSML files can then be directly read and processed by these\ncodes, achieving pseudopotential interoperability. SIESTA The PSML functionality is implemented in the psml-support series of\ndevelopment, which will soon be merged into the main version. ABINIT The Abinit code has been able to process PSML files since Version 8.2.","tags":"","loc":"page/01_the_psml_format/02_clients/index.html"},{"title":"Databases of PSML files – libPSML","text":"The Pseudo-Dojo project maintains a\ndatabase of pseudopotentials generated\nwith the oncvpsp code, and provides extensive information on their\nperformance on several tests. One of the formats supported is PSML. More information about the project is available in a publication (also available\nin preprint form ).","tags":"","loc":"page/01_the_psml_format/databases.html"},{"title":"Schema for PSML – libPSML","text":"# # Schema for PSML format # RELAX-NG compact form. See: http://www.relaxng.org/compact-tutorial-20030326.htm # # This form can be processed by the jing/trang set of tools, available from #   https://github.com/relaxng/jing-trang # # The 'jing' validator can work directly with this .rnc file (RELAX-NG compact form), # and this is the preferred option. # # The 'trang' converter can be used to generate other schema forms, such as: # #     .rng (RELAX-NG xml form), .xsd (XML Schema) # # But note that some features of RELAX-NG cannot be completely represented by XML Schema # schema files. In particular, in this file, the 'arbitrary attribute' idiom in the # 'annotation' element is emulated. # default namespace = \"http://esl.cecam.org/PSML/ns/1.1\" start = PSML PSML = element psml { Root . Attributes , Provenance + # One or more provenance elements , PseudoAtomSpec , Grid ? # Optional top-level grid , ValenceCharge , CoreCharge ? # Optional pseudo-core charge , ( ( SemiLocalPotentials + , PSOperator ? ) | ( SemiLocalPotentials * , PSOperator ) ) , PseudoWaveFunctions * # Zero or more Pseudo Wavefunction groups } # # Definitions of the above grammar symbols follow # Root . Attributes = attribute energy_unit { \"hartree\" } , attribute length_unit { \"bohr\" } , attribute uuid { xsd : NMTOKEN } , attribute version { xsd : decimal } # ========= Provenance = element provenance { attribute record - number { xsd : positiveInteger } ? , attribute creator { xsd : string } , attribute date { xsd : string } , Annotation ? , InputFile * # zero or more input files } InputFile = element input - file { attribute name { xsd : NMTOKEN }, # No spaces or commas allowed text } # ========= PseudoAtomSpec = element pseudo - atom - spec { PseudoAtomSpec . Attributes , Annotation ? , ExchangeCorrelation , ValenceConfiguration , CoreConfiguration ? } # ========= PseudoAtomSpec . Attributes = attribute atomic - label { xsd : NMTOKEN }, attribute atomic - number { xsd : double }, attribute z - pseudo { xsd : double }, attribute core - corrections { \"yes\" | \"no\" }, attribute relativity { \"no\" | \"scalar\" | \"dirac\" }, attribute spin - dft { \"yes\" | \"no\" } ? , attribute flavor { xsd : string } ? # ========= ExchangeCorrelation = element exchange - correlation { Annotation ? , element libxc - info { attribute number - of - functionals { xsd : positiveInteger }, LibxcFunctional + } } LibxcFunctional = element functional { attribute id { xsd : positiveInteger }, attribute name { xsd : string }, attribute weight { xsd : double } ? , # allow canonical names and libxc-style symbols attribute type { \"exchange\" | \"correlation\" | \"exchange-correlation\" | \"XC_EXCHANGE\" | \"XC_CORRELATION\" | \"XC_EXCHANGE_CORRELATION\" } ? } # ========= ValenceConfiguration = element valence - configuration { attribute total - valence - charge { xsd : double }, Annotation ? , ValenceShell + } ValenceShell = Shell Shell = element shell { attribute_l , attribute_n , attribute occupation { xsd : double }, attribute occupation - up { xsd : double } ? , attribute occupation - down { xsd : double } ? } # ========= CoreConfiguration = element core - configuration { attribute total - core - charge { xsd : double }, Annotation ? , CoreShell + } CoreShell = Shell # ========= ValenceCharge = element valence - charge { attribute total - charge { xsd : double }, attribute is - unscreening - charge { \"yes\" | \"no\" } ? , attribute rescaled - to - z - pseudo { \"yes\" | \"no\" } ? , Annotation ? , Radfunc } # ========= CoreCharge = element pseudocore - charge { attribute matching - radius { xsd : double } ? , attribute number - of - continuous - derivatives { xsd : nonNegativeInteger } ? , Annotation ? , Radfunc } # ========= SemiLocalPotentials = element semilocal - potentials { attribute_set , attribute flavor { xsd : string } ? , Annotation ? , Grid ? , Potential + } Potential = element slps { attribute flavor { xsd : string } ? , attribute_l , attribute_j ? , attribute_n , attribute rc { xsd : double }, attribute eref { xsd : double } ? , Radfunc } # ========= PSOperator = ( LocalPotential # Local potential , NonLocalProjectors * ) # Zero or more fully nonlocal groups LocalPotential = element local - potential { attribute type { xsd : string }, Annotation ? , Grid ? , Radfunc , LocalCharge ? # Optional local-charge element } LocalCharge = element local - charge { Radfunc } # ========= NonLocalProjectors = element nonlocal - projectors { attribute_set , Annotation ? , Grid ? , Projector + } Projector = element proj { attribute ekb { xsd : double }, attribute eref { xsd : double } ? , attribute_l , attribute_j ? , attribute seq { xsd : positiveInteger }, attribute type { xsd : string }, Radfunc } + # ========= PseudoWaveFunctions = element pseudo - wave - functions { attribute_set , Annotation ? , Grid ? , PseudoWf + } PseudoWf = element pswf { attribute_l , attribute_j ? , attribute_n , attribute energy_level { xsd : double } ? , Radfunc } # ========= Grid = element grid { attribute npts { xsd : positiveInteger }, Annotation ? , element grid - data { list { xsd : double + } # One or more floating point numbers } } # ========= Radfunc = element radfunc { Grid ? , # Optional grid element element data { attribute npts { xsd : positiveInteger } ? , list { xsd : double + } # One or more floating point numbers } } # # This is the way to leave the annotations # as collections of one or more arbitrary attributes # # This RELAX NG idiom cannot be directly translated to W3C schema (xsd form), # but a similar result could be obtained with the <any> and <anyAttribute> xsd elements # any_attribute = attribute * { text } Annotation = element annotation { any_attribute + } # # Convenience enumeration definitions # attribute_l = attribute l { \"s\" | \"p\" | \"d\" | \"f\" | \"g\" } attribute_n = attribute n { \"1\" | \"2\" | \"3\" | \"4\" | \"5\" | \"6\" | \"7\" | \"8\" | \"9\" } attribute_j = attribute j { \"0.5\" | \"1.5\" | \"2.5\" | \"3.5\" | \"4.5\" } attribute_set = attribute set { \"non_relativistic\" | \"scalar_relativistic\" | \"spin_orbit\" | \"lj\" | \"up\" | \"down\" | \"spin_average\" | \"spin_difference\" | \"user_extension1\" | \"user_extension2\" }","tags":"","loc":"page/01_the_psml_format/schema.html"},{"title":"libPSML User Guide – libPSML","text":"We provide a companion library to the PSML format, libPSML, that\nprovides transparent parsing and data extraction from PSML files, as\nwell as basic editing and data conversion capabilities. The library is built around a data structure of type ps_t that maps the information in a PSML file. Instances of this\nstructure are populated by PSML parsers, processed by\nintermediate utility programs, and used as handles for information\nretrieval by client codes through accessor routines. The library\nprovides, in essence: A routine to parse a PSML file and produce a ps object of type ps_t . A routine to dump the information in a ps object to a\n  PSML file. Accessor routines to extract information from ps objects. Some setter routines to insert specific blocks of information\n  into ps objects. These might be used by intermediate\n  processors or by high-level parsers. The library is written in modern Fortran and provides a\nhigh-level Fortran interface. A C/C++ interface is in preparation. The basic modus operandi is to parse a PSML file, storing the information\nin an abstract handle ps_t , and then to query the handle to\nextract the relevant data. use m_psml type ( psml_t ) :: ps call psml_reader ( \"input.psml\" , ps , debug = . false .) ... ! Set up a grid of our own choosing npts = 400 ; delta = 0.01 allocate ( r ( npts )) do ir = 1 , npts r ( ir ) = ( ir - 1 ) * delta enddo ! Query existing potentials and get values call ps_Potential_Filter ( ps , set = SET_SREL , indexes = idx , number = npots ) do i = 1 , npots call ps_Potential_Get ( ps , idx ( i ), l = l , n = n , rc = rc ) ... do ir = 1 , npts val = ps_Potential_Value ( ps , idx ( i ), r ( ir )) ... enddo enddo ... call ps_destroy ( ps )","tags":"","loc":"page/02_library_user_guide/index.html"},{"title":"Installation – libPSML","text":"Pre-requisites The libPSML library itself. The xmlf90 library Follow the instructions in the package to compile it. Installation of libPSML ./configure --prefix=/path/to/installation --with-xmlf90=/path/to/xmlf90 make make check make install Test programs Go into the subdirectory examples . In it you can find, among others: normalize :  A program to parse a PSML file and dump the resulting ps object. show_psml : A program to parse a PSML file and extract\n  various kinds of information, with optional evaluation of radial\n  functions on a linear grid for later plotting. Compiling user programs After installation, the appropriate modules and library files should\nalready be in $PREFIX/include and $PREFIX/lib , respectively. The basic idiom is to provide the basic Fortran building rules, and\nto insert the paths to the libpsml (and xmlf90) modules and libraries.","tags":"","loc":"page/02_library_user_guide/01_installation.html"},{"title":"libPSML API – libPSML","text":"The API for libPSML follows very closely the structure of the schema. Exported types Parsing Library identification Data accessors Root attributes and namespace Provenance data Pseudo-atom specification attributes and annotation Valence configuration Exchange and correlation Valence and Core Charges Local Potential and Local Charge Density Semilocal potentials Nonlocal Projectors Pseudo Wavefunctions Radial function and grid information The evaluation engine Predicate routines for contents Editing of ps structures Dump of ps structures Annotation API Exported types The library exports the opaque types: ps_t : Main handle for all the libPSML routines. It contains data\n  structures resulting from parsing ps_annotation_t : A handle to deal with the content of <annotation> elements in the PSML file. More information on\n  annotations can be found here . ps_radfunc_t : A handle for the data structures implementing the\n  functionality of radial functions, in particular their evaluation. More information about the associated implementations can be found in\nthe developer notes . In addition, the library exports the integer parameter ps_real_kind that represents the kind of the real numbers accepted and returned by\nthe library. Parsing The routine psml_reader ( filename, ps, debug ) parses the PSML file filename and populates the data structures in the handle ps . An optional debug argument determines whether the\nlibrary issues debugging messages while parsing. ps_destroy ( ps ) is a low-level routine provided for\ncompleteness in cases where a pristine ps is needed for further\nuse. Library identification The function ps_GetLibPSMLVersion returns the version as\n    an integer (for example: 1106) instead of the typical dot form\n    (1.1.6). Data accessors The API follows closely the element structure of the PSML format. Each\nsection in the high-level document structure of the schema is mapped to a group of\nroutines in the API. Within each, there are routines to query any\ninternal structure (attributes, existence, number, or selection of\nchild elements) and routines to obtain specific data items\n(attributes, content of child elements). Root attributes and namespace The namespace and the attributes of the root element default namespace = \"http://esl.cecam.org/PSML/ns/1.1\" Root . Attributes = attribute energy_unit { \"hartree\" } , attribute length_unit { \"bohr\" } , attribute uuid { xsd : NMTOKEN } , attribute version { xsd : decimal } are read by the routine ps_RootAttributes_Get ( ps,uuid,version,namespace ).  As in all the routines that follow, the\nhandle ps is mandatory. All other arguments are optional, with intent(out) , and of type character(len=*) . The\nargument version returns the PSML version of the file being\nprocessed. A given version of the library is able to process files\nwith lower version numbers, up to a limit. Provenance data Provenance = element provenance { attribute record - number { xsd : positiveInteger } ? , attribute creator { xsd : string } , attribute date { xsd : string } , Annotation ? , InputFile * # zero or more input files } InputFile = element input - file { attribute name { xsd : NMTOKEN }, # No spaces or commas allowed text } As there can be several <provenance> elements, the API provides a\nfunction to enquire about their number (depth of provenance\ninformation), and a routine to get the information from a given level: ps_Provenance_Depth ( ps )  result( depth ) ps_Provenance_Get ( ps,level,creator,date,annotation,number_of_input_files ) The integer argument level selects the provenance depth level (1\n  is the deepest, or older, so to get the latest record the routine\n  should be called with level=depth as returned from the previous\n  routine). All other arguments are optional with\n  intent(out). creator and date are strings. Here and in what\n  follows, annotation arguments are of the\n  opaque type ps_annotation_t .  If there is no annotation, an empty\n  structure is returned. Pseudo-atom specification attributes and annotation PseudoAtomSpec . Attributes = attribute atomic - label { xsd : NMTOKEN }, attribute atomic - number { xsd : double }, attribute z - pseudo { xsd : double }, attribute core - corrections { \"yes\" | \"no\" }, attribute relativity { \"no\" | \"scalar\" | \"dirac\" }, attribute spin - dft { \"yes\" | \"no\" } ? , attribute flavor { xsd : string } ? ps_PseudoAtomSpec_Get ( ps, atomic_symbol,\n  atomic_label, atomic_number, z_pseudo,\n  pseudo_flavor, relativity, spin_dft, core_corrections, annotation ) The arguments spin_dft and core_corrections are boolean,\n  and the routine returns an empty string in flavor if the\n  attribute is not present (recall that flavor is a cascading\n  attribute that can be set at multiple levels). Valence configuration ValenceConfiguration = element valence - configuration { attribute total - valence - charge { xsd : double }, Annotation ? , ValenceShell + } ValenceShell = Shell Shell = element shell { attribute_l , attribute_n , attribute occupation { xsd : double }, attribute occupation - up { xsd : double } ? , attribute occupation - down { xsd : double } ? } attribute_l = attribute l { \"s\" | \"p\" | \"d\" | \"f\" | \"g\" } attribute_n = attribute n { \"1\" | \"2\" | \"3\" | \"4\" | \"5\" | \"6\" | \"7\" | \"8\" | \"9\" } ps_ValenceConfiguration_Get ( ps,nshells,charge,annotation ) This routine returns (as always, in optional arguments), the\n  values of the top-level attributes, any annotation, and the number of Shell elements, which serves as upper limit for the index i in the following routine, which extracts shell information: ps_ValenceShell_Get ( ps,i,n,l,occupation,occ_up,occ_down ) The n and l quantum number arguments are integers\n  (despite the use of spectroscopic symbols for the angular momentum\n  in the format), and the occupations real. Exchange and correlation ExchangeCorrelation = element exchange - correlation { Annotation ? , element libxc - info { attribute number - of - functionals { xsd : positiveInteger }, LibxcFunctional + } } LibxcFunctional = element functional { attribute id { xsd : positiveInteger }, attribute name { xsd : string }, attribute weight { xsd : double } ? , # allow canonical names and libxc-style symbols attribute type { \"exchange\" | \"correlation\" | \"exchange-correlation\" | \"XC_EXCHANGE\" | \"XC_CORRELATION\" | \"XC_EXCHANGE_CORRELATION\" } ? } The routines follow the same structure as those in the previous section. ps_ExchangeCorrelation_Get ( ps,annotation,n_libxc_functionals ) ps_LibxcFunctional_Get ( ps,i,name,code,type,weight ) Valence and Core Charges ValenceCharge = element valence - charge { attribute total - charge { xsd : double }, attribute is - unscreening - charge { \"yes\" | \"no\" } ? , attribute rescaled - to - z - pseudo { \"yes\" | \"no\" } ? , Annotation ? , Radfunc } # ========= CoreCharge = element pseudocore - charge { attribute matching - radius { xsd : double }, attribute number - of - continuous - derivatives { xsd : nonNegativeInteger }, Annotation ? , Radfunc } These are radial functions with some metadata in the form of\nattributes, an optional annotation, and a Radfunc child. The accessors\nhave the extra optional argument func that returns a handle to\na ps_radfunc_t object, which can later be used to get extra\ninformation. ps_ValenceCharge_Get ( ps,total_charge,\n                      is_unscreening_charge, rescaled_to_z_pseudo,\n                      annotation,func ) The routine returns an emtpy string in is_unscreening_charge and rescaled_to_z_pseudo if the attributes are not present in the\n  PSML file. ps_CoreCharge_Get ( ps,rc,nderivs,annotation,func ) rc corresponds to the matching radius and nderivs to the\n  continuity information. Negative values are returned if the\n  corresponding attributes are not present in the file. The func object can be used to evaluate the radial functions at\na particular point r : function ps_GetValue ( func,r ) result( val ) but the API offers some convenience functions function ps_ValenceCharge_Value ( ps,r ) result( val ) function ps_CoreCharge_Value ( ps,r ) result( val ) Local Potential and Local Charge Density LocalPotential = element local - potential { attribute type { xsd : string }, Annotation ? , Grid ? , Radfunc , LocalCharge ? # Optional local-charge element } LocalCharge = element local - charge { Radfunc } ps_LocalPotential_Get ( ps,type,annotation,func,has_local_charge,func_local_charge ) In this version of the API, the optional <local-charge> element is\nnot given a first-class status. To evaluate it (if the boolean\nargument has_local_charge is .true. ), the func_local_charge argument has to be used in the ps_GetValue routine above. The local potential can be\nevaluated via the func object or with the convenience function function ps_LocalPotential_Value ( ps,r ) result( val ) Semilocal potentials SemiLocalPotentials = element semilocal - potentials { attribute_set , attribute flavor { xsd : string } ? , Annotation ? , Grid ? , Potential + } Potential = element slps { attribute flavor { xsd : string } ? , attribute_l , attribute_j ? , attribute_n , attribute rc { xsd : double }, attribute eref { xsd : double } ? , Radfunc } As explained here there can be several <semilocal-potentials> elements corresponding to different\nsets. Internally, the data is built up in linked lists during the\nparsing stage and later all the data for the <slps> child elements\nare re-arranged into flat tables, which can be queried like a simple\ndatabase. The table indexes for the potentials with\nspecific quantum numbers, or set membership, can be obtained with\nthe routine ps_SemilocalPotentials_Filter ( ps,indexes_in,l,j,n,set,indexes,number ) indexes_in : (Optional, in) Initial set of indexes on which to\n perform the filtering operation. If not present, the full table is used. l,j,n,set : (Optional, in) Values for filtering criteria. indexes : (Optional, out) Set of indexes which satisfy the criteria. number : (Optional, out) Number of items which satisfy the criteria. The set argument has to be given using special integer symbols exported\nby the API, as explained here . The appropriate indexes can then be fed into the following routines to\nget specific information: ps_Potential_Get ( ps,i,l,j,n,rc,eref,set,flavor,annotation,func ) All arguments except ps and i are optional. The value\n  returned in set is an integer which can be converted to a\n  mnemonic string through the str_of_set convenience function.\n  The annotation returned corresponds to the optional <annotation> element of the parent block of the <slps> element. The routine returns a very large positive value in eref if the\n  corresponding attribute is not present in the file. function ps_Potential_Value ( ps,i,r ) result( val ) Nonlocal Projectors NonLocalProjectors = element nonlocal - projectors { attribute_set , Annotation ? , Grid ? , Projector + } Projector = element proj { attribute ekb { xsd : double }, attribute eref { xsd : double } ? , attribute_l , attribute_j ? , attribute seq { xsd : positiveInteger }, attribute type { xsd : string }, Radfunc } + The ideas are exactly the same as for the semilocal potentials. The\nrelevant routines are: ps_NonlocalProjectors_Filter ( ps,indexes_in,l,j,seq,set,indexes,number ) ps_Projector_Get ( ps,i,l,j,seq,set,ekb,eref,type,annotation,func ) The routine returns a very large positive value in eref if the\n  corresponding attribute is not present in the file. function ps_Projector_Value ( ps,i,r ) result( val ) Pseudo Wavefunctions PseudoWaveFunctions = element pseudo - wave - functions { attribute_set , Annotation ? , Grid ? , PseudoWf + } PseudoWf = element pswf { attribute_l , attribute_j ? , attribute_n , attribute energy_level { xsd : double } ? , Radfunc } Again, the same strategy: ps_PseudoWaveFunctions_Filter ( ps,indexes_in,l,j,set,indexes,number ) ps_PseudoWf_Get ( ps,i,l,j,n,set,energy_level,annotation,func ) The routine returns a very large positive value in energy_level if the\n  corresponding attribute is not present in the file. function ps_PseudoWf_Value ( ps,i,r ) result( val ) Radial function and grid information Radfunc = element radfunc { Grid ? , # Optional grid element element data { list { xsd : double + } # One or more floating point numbers } } Grid = element grid { attribute npts { xsd : positiveInteger }, Annotation ? , element grid - data { list { xsd : double + } # One or more floating point numbers } } In keeping with the PSML philosophy of being grid-agnostic, the basic\nAPI does not provide any direct means of accessing the data used in\nthe tabulation of the radial functions. The values of the functions at\na particular point r can be generally obtained through the ps_XXXX_Value interfaces, or through the ps_GetValue interface using func objects of type ps_radfunc_t . It is nevertheless possible to get annotation data for the grid of a\nparticular radial function, or for the top-level grid, through the\nfunction function ps_GridAnnotation ( ps,func }) result( annotation ) If a radial function handle func is given, the annotation for\n  that radial function's grid is returned. Otherwise, the return value\n  is the annotation for the top-level grid. The evaluation engine In the current version of the library the evaluation of tabulated\nfunctions is performed by default with polynomial interpolation, using\na slightly modified version of an algorithm borrowed (with permission)\nfrom the oncvpsp program by\nD.R. Hamann.  By default seventh-order interpolation, as in oncvpsp ,\nis used.  If the library is compiled with the appropriate\npre-processor symbols, the interpolator and/or its order can be chosen\nat runtime, but we note that this should be considered a debugging\nfeature. Reproducibility of results would be hampered if client codes\nchange the interpolation parameters at will. Generator codes should\ninstead strive to produce data tabulations that will guarantee a given\nlevel of precision when interpolated with the default scheme, using\nappropriate output grids on which to sample their internal data\nsets. For example, our own work on enabling PSML output in oncvpsp (see below) includes diagnostic tools to check the interpolation\naccuracy. Most codes use internally a non-uniform grid (e.g. logarithmic). We\nhave found that a good choice of output grid is a subset of the\nproducer's working grid points that leaves out most of the very close\npoints near the origin but maintains the rest. This can be achieved by\nimposing a minimum inter-point separation $\\delta$. This parameter\n$\\delta$ can be smaller than the typical linear-grid step used\ncurrently by most codes, and still lead to smaller grids (in terms of\nnumber of points) that preserve the accuracy of the output. High-order interpolation can lead to ringing effects\n(oscillations of the interpolating polynomial between points), notably\nnear edge regions when the shape of the function changes\nabruptly. This is the case, for example, if the function drops to zero\nwithin the interpolation range as a result of cutting off a tail. The\nactual interpolated values will typically be very small, but might cause\nundesirable effects in the client code. To avoid this problem, the\nlibPSML evaluator works internally with an effective end-of-range\nthat is determined by analyzing the data values after parsing. If needed for debugging purposes, the evaluator engine can be\nconfigured by the routine: ps_SetEvaluatorOptions ( quality_level,debug,\n  use_effective_range,\n  custom_interpolator ) All arguments are optional, and apply globally to the operation of\n  the library. The custom_interpolator argument is not allowed\n  if the underlying Fortran compiler does not support procedure\n  pointers. quality_level (an integer) is by default and will\n  typically be the interpolation order, but its meaning can change\n  with the interpolator in use. The evaluator uses an effective range\n  by default, as discussed above, but this feature can be turned off\n  by setting use_effective_range to .false. . The debug argument will turn on any extra printing configured in\n  the evaluator. By default, no extra printing is produced. Finally, in case it is necessary to look at the raw tabular data for debugging \npurposes, the library also provides a low-level routine: ps_GetRawData ( func,rg,data ) If a radial function handle func is given, the grid points\n  and the actual tabulated data are returned in rg and data , which must be passed as allocatable arrays. Predicate routines for contents The following convenience functions return a logical value. For semi-local\npotentials, non-local projectors, and pseudo-wave-functions, the test\nis done on the union of all possible sets. ps_HasSemilocalPotentials ps_HasPSOperator ps_HasLocalPotential ps_HasProjectors Editing of ps structures The PSML library has currently limited support for editing the content\nof ps_t objects from user programs. For example, such an\nediting might be done by a KB-projector generator to insert a new\nprovenance record (and KB and local-potential data) in the ps object, prior to dumping to a new PSML file. ps_RootAttributes_Set ( ps,version,uuid,namespace ) ps_Provenance_Add ( ps,creator,date,annotation ) Annotations can be created using routines exported by the PSML API\n  (see below) ps_NonLocalProjectors_Delete ( ps ) ps_LocalPotential_Delete ( ps ) Dump of ps structures The contents of a (possibly edited) ps_t object can be dumped\nto a PSML file using the routine ps_DumpToPSMLFile ( ps,fname,indent ) Here fname is the output file name, and indent is a\n  logical variable that determines whether automatic indenting of\n  elements is turned on (by default it is not). Annotation API To support the annotation functionality, the library contains a module\nimplementing a basic instance of an association list (a data structure\nholding key-value pairs), and exports the ps_annotation_t type, the empty annotation object EMPTY_ANNOTATION and the following routines: (The names of these routines are aliases of the originals in the assoc_list module.) reset_annotation ( annotation ) Cleans the contents of the ps_annotation_t object annotation so that it can be reused. insert_annotation_pair (annotation,key,value,stat) Inserts the key, value pair of string variables in the ps_annotation_t object annotation . Internally, annotation can\n  grow as much as needed. function nitems_annotation ( annotation ) result( nitems ) Returns the number of key-value pairs in the annotation object get_annotation_value ( annotation,key,value,stat ) get_annotation_value ( annotation,i,value,stat ) This routine has two interfaces. The first gets the value associated to the key , and the second gets the value associated to the i 'th entry in the annotation object. get_annotation_key ( annotation,i,key,stat ) Gets the key of the i 'th entry in the annotation object. Together with the second form of get_annotation_value ,\n  this routine can be used to scan the complete annotation object. The\n  first form of get_annotation_value is appropriate if the\n  key(s) are known. In all the above routines a non-zero stat signals an error condition.","tags":"","loc":"page/02_library_user_guide/02_api/index.html"},{"title":"Annotations – libPSML","text":"XML provides for built-in extensibility and client programs can use as\nmuch or as little information as needed. For the actual mapping of a\ndomain ontology to a XML-based format, however, clients and producers\nhave to agree on the terms used. What has been described in the above\nsections is a minimal form of such a mapping, containing the basic\nconcepts and functions needed. The extension of the format with new\nfixed-meaning elements and attributes would involve an updated schema\nand re-coding of parsers and other programs. A more light-weight\nsolution to the extensibility issue is provided by the use of annotations , which have the morphology of XML empty elements\n(containing only attributes) but can appear in various places and\ncontain arbitrary key-value pairs. Annotations provide immediate\ninformation to human readers of the PSML files, and can be\nexploited informally by client programs to extract additional\ninformation. For the latter use, it is clear that some degree of\npermanence and agreed meaning should be given to annotations, but this\ntask falls not on some central authority, but on specific codes. As an example, the following snippet of a PSML file shows an annotation in the pseudo-atom-spec element: <pseudo-atom-spec atomic-label= \"La\" atomic-number= \"57\" z-pseudo= \"11\" flavor= \"Hamann&apos;s oncvpsp\" relativity= \"scalar\" spin-dft= \"no\" core-corrections= \"no\" > <annotation pseudo-energy= \"-31.7585823482\" cutoff_hint_low= \"38\" cutoff_hint_normal= \"39\" cutoff_hint_high= \"47\" /> <exchange-correlation> <annotation oncvpsp-xc-code= \"3\" oncvpsp-xc-type= \"LDA -- Ceperley-Alder Perdew-Zunger\" /> <libxc-info number-of-functionals= \"2\" > <functional name= \"Slater exchange (LDA)\" type= \"exchange\" id= \"1\" /> <functional name= \"Perdew &amp; Zunger (LDA)\" type= \"correlation\" id= \"9\" /> </libxc-info> </exchange-correlation> <valence-configuration total-valence-charge= \"11\" > <shell n= \"5\" l= \"s\" occupation= \"2\" /> <shell n= \"5\" l= \"p\" occupation= \"6\" /> <shell n= \"5\" l= \"d\" occupation= \"2\" /> <shell n= \"6\" l= \"s\" occupation= \"1\" /> </valence-configuration> </pseudo-atom-spec> Plane-wave codes might want to exploit the energy cutoff hints given\nin the annotation, perhaps using a plugin routine that identifies\nthe generator program and its version and extracts the hints in the\nappropriate manner. These plugin routines might be stored (and\nproperly maintained) in a repository to which both the owners of the\ngenerator programs and the owners of the client programs can\ncontribute. Some chosen plugins might also be distributed with the\nlibPSML library itself, to serve as examples and templates. Annotations are currently allowed within the following elements: provenance pseudo-atom-spec exchange-correlation valence-configuration core-configuration semilocal-potentials local-potential nonlocal-projectors pseudo-wave-functions valence-charge core-charge grid Top-level annotations are not allowed. They properly\nbelong in the provenance elements.","tags":"","loc":"page/02_library_user_guide/02_api/annotations.html"},{"title":"Sets of potentials, projectors, and pseudo-wave-functions – libPSML","text":"A given pseudopotential-generator code might offer several possible\nlevels of theory, and output different sets of magnitudes accordingly. The set attribute in several API routines allows the handling of\nvarious sets of semilocal pseudopotentials, projectors, and\npseudo-wave-functions. Its value is normalized as follows, depending\non the type of calculation generating the pseudopotential and the way\nin which the code chooses to present the results. (First, the symbolic\nname used in the API is given, followed by the value of the attribute in\nthe PSML file) ( SET_NONREL , non_relativistic ) for the non-relativistic, non-spin-DFT\ncase. ( SET_SREL , scalar_relativistic ) if the calculation is\nscalar-relativistic, or if it is fully relativistic and an set of lj potentials averaged over j is provided. ( SET_SO , spin_orbit ) if a\nfully relativistic code provides this combination of lj potentials. ( SET_LJ , lj ) for a fully relativistic calculation with straight output\nof the $lj$ channels. ( SET_UP , up )  and ( SET_DOWN , down ), for a spin-DFT\ncalculation with straight output of the spin channels. ( SET_SPINAVE , spin_average ) for the spin-DFT case when the generation code\noutputs a population-averaged pseudopotential. ( SET_SPINDIFF , spin_difference ) for the spin-DFT case when the generation code\noutputs this (rare) combination. Note that a given code might choose to output its semilocal-potential\ninformation in two different forms (say, as scalar-relativistic and\nspin-orbit combinations plus the lj form). The format allows this,\nalthough in this particular case the information can easily be\nconverted from the lj form to the other by client programs. For extensibility, the format allows two more values for the set attribute, ( SET_USER1 , user_extension1 ) and ( SET_USER2 , user_extension2 ), which can in principle be used to store custom\ninformation while maintaining structural and operative compatibility\nwith the format. The wildcard specification SET_ALL can be used to represent the\nunion of all possible sets.","tags":"","loc":"page/02_library_user_guide/02_api/sets.html"},{"title":"Developer Notes – libPSML","text":"Abstract types The main type of the library is ps_t . The ps_annotation_t type is actually an alias for assoc_list_t . The ps_radfunc_t type is actually an alias for radfunc_t","tags":"","loc":"page/03_library_developer_notes/index.html"}]}