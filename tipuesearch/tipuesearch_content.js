var tipuesearch = {"pages":[{"text":"libPSML The library provides an API for parsing PSML files, including\naccessors for the relevant data pieces, as well as a set of routines\nfor generating well-formed PSML. This is work in progress, linked to the efforts to reach a final PSML\nspecification.  Most of the API is stable, although there might be\nsome last-minute cosmetic changes.  Contributions are welcome, notably\nin documentation and testing. For more information, check out the Overview . Developer Info Alberto Garcia","tags":"","loc":"index.html","title":" libPSML "},{"text":"Modules assoc_list Source Code assoc_list.f90 Source Code module assoc_list ! First version, with fixed (initial) length, ! and fixed-length fields. ! Alberto Garcia, Sept 2014 ! !----------------------------------------------------------- type , public :: assoc_list_t private integer :: nslots = 0 integer :: nitems = 0 character ( len = 50 ), allocatable :: key (:) character ( len = 120 ), allocatable :: value (:) end type assoc_list_t type ( assoc_list_t ), public , save :: EMPTY_ASSOC_LIST public :: assoc_list_init public :: assoc_list_reset public :: assoc_list_insert public :: assoc_list_nitems public :: assoc_list_get_key public :: assoc_list_get_value interface assoc_list_get_value module procedure assoc_list_get_value_by_index module procedure assoc_list_get_value_of_key end interface CONTAINS subroutine assoc_list_init ( a , n , stat ) type ( assoc_list_t ), intent ( inout ) :: a integer , intent ( in ) :: n integer , intent ( out ) :: stat if ( allocated ( a % key )) then deallocate ( a % key ) endif if ( allocated ( a % value )) then deallocate ( a % value ) endif a % nslots = n a % nitems = 0 allocate ( a % key ( n ), a % value ( n ), stat = stat ) end subroutine assoc_list_init subroutine assoc_list_reset ( a ) type ( assoc_list_t ), intent ( inout ) :: a if ( allocated ( a % key )) then deallocate ( a % key ) endif if ( allocated ( a % value )) then deallocate ( a % value ) endif a % nslots = 0 a % nitems = 0 end subroutine assoc_list_reset subroutine assoc_list_insert ( a , key , value , stat ) type ( assoc_list_t ), intent ( inout ) :: a character ( len =* ), intent ( in ) :: key , value integer , intent ( out ) :: stat integer :: i ! Replace if key exists already do i = 1 , a % nitems if ( a % key ( i ) == key ) then a % value ( i ) = value stat = 0 return endif enddo ! ! Add at the end a % nitems = a % nitems + 1 if ( a % nitems > a % nslots ) then stat = - 1 return endif i = a % nitems a % key ( i ) = key a % value ( i ) = value stat = 0 end subroutine assoc_list_insert function assoc_list_nitems ( a ) result ( n ) type ( assoc_list_t ), intent ( in ) :: a integer :: n n = a % nitems end function assoc_list_nitems subroutine assoc_list_get_key ( a , i , key , stat ) type ( assoc_list_t ), intent ( in ) :: a integer , intent ( in ) :: i character ( len =* ), intent ( out ) :: key integer , intent ( out ) :: stat if ( i > a % nitems ) then stat = - 1 return endif key = a % key ( i ) stat = 0 end subroutine assoc_list_get_key subroutine assoc_list_get_value_of_key ( a , key , value , stat ) type ( assoc_list_t ), intent ( in ) :: a character ( len =* ), intent ( in ) :: key character ( len =* ), intent ( out ) :: value integer , intent ( out ) :: stat integer :: i do i = 1 , a % nitems if ( a % key ( i ) == key ) then value = a % value ( i ) stat = 0 return endif enddo stat = - 1 end subroutine assoc_list_get_value_of_key subroutine assoc_list_get_value_by_index ( a , i , value , stat ) type ( assoc_list_t ), intent ( in ) :: a integer , intent ( in ) :: i character ( len =* ), intent ( out ) :: value integer , intent ( out ) :: stat if ( i <= a % nitems ) then value = a % value ( i ) stat = 0 else stat = - 1 value = \"\" endif end subroutine assoc_list_get_value_by_index end module assoc_list","tags":"","loc":"sourcefile/assoc_list.f90.html","title":"assoc_list.f90 – libPSML"},{"text":"Modules class_Grid Source Code class_grid.F90 Source Code module class_Grid use assoc_list , only : ps_annotation_t => assoc_list_t use assoc_list , only : ps_clean_annotation => assoc_list_reset implicit none character ( len =* ), parameter :: mod_name = \"Grid\" integer , parameter :: dp = selected_real_kind ( 10 , 100 ) ! type Grid_ integer :: refCount = 0 character ( len = 36 ) :: id = \"null_id\" !---------------------- character ( len = 256 ) :: name = \"null Grid\" integer :: npts = 0 real ( dp ), pointer :: grid_data (:) => null () type ( ps_annotation_t ) :: annotation end type Grid_ type Grid type ( Grid_ ), pointer :: data => null () end type Grid public :: newGrid , print_type , valGrid , annotationGrid , sizeGrid interface print_type module procedure printGrid end interface !======================== #define TYPE_NAME Grid #include \"basic_type.inc\" !======================== subroutine delete_Data ( gd ) type ( Grid_ ) :: gd if ( associated ( gd % grid_data )) then deallocate ( gd % grid_data ) gd % grid_data => null () endif call ps_clean_annotation ( gd % annotation ) end subroutine delete_Data subroutine newGrid ( this , n , name ) type ( Grid ), intent ( inout ) :: this integer , intent ( in ) :: n character ( len =* ), intent ( in ), optional :: name integer :: stat ! We release the previous incarnation ! This means that we relinquish access to the previous ! memory location. It will be deallocated when nobody ! else is using it. call init ( this ) if ( present ( name )) then this % data % name = trim ( name ) else this % data % name = \"(Grid from n)\" endif allocate ( this % data % grid_data ( n )) call tag_new_object ( this ) end subroutine newGrid function valGrid ( this ) result ( p ) type ( Grid ), intent ( in ) :: this real ( dp ), pointer :: p (:) nullify ( p ) p => this % data % grid_data end function valGrid function annotationGrid ( this ) result ( p ) type ( Grid ), intent ( in ) :: this type ( ps_annotation_t ) , pointer :: p nullify ( p ) p => this % data % annotation end function annotationGrid function sizeGrid ( this ) result ( n ) type ( Grid ), intent ( in ) :: this integer :: n if (. not . initialized ( this )) then n = 0 else n = size ( this % data % grid_data ) endif end function sizeGrid subroutine printGrid ( this ) type ( Grid ), intent ( in ) :: this integer :: n , m if (. not . associated ( this % data )) then print \"(a)\" , \"Grid Not Associated\" RETURN endif n = size ( this % data % grid_data ) print \"(a,i0,a,i0,a,i0,a)\" , \"  <grid:\" // trim ( this % data % name ) // & \" n=\" , n , & \", refcount: \" , refcount ( this ), \">\" end subroutine printGrid end module class_Grid","tags":"","loc":"sourcefile/class_grid.f90.html","title":"class_grid.F90 – libPSML"},{"text":"Modules external_interfaces Source Code external_interfaces.f90 Source Code module external_interfaces ! ! The user must provide external subroutines ! with these interfaces ! public :: psml_die interface ! Called to terminate the program, printing a message subroutine psml_die ( str ) character ( len =* ), intent ( in ) :: str end subroutine psml_die end interface end module external_interfaces","tags":"","loc":"sourcefile/external_interfaces.f90.html","title":"external_interfaces.f90 – libPSML"},{"text":"Modules m_interp Source Code m_interp.F90 Source Code module m_interp ! Default quality parameter for interpolator integer , public , save :: nq = 7 #ifdef __NO_PROC_POINTERS__ ! Use a hard-wired interpolator interface interpolator module procedure dpnint1 end interface public :: interpolator private :: dpnint1 CONTAINS #else ! This is the interface that the interpolators ! must have interface subroutine interpolate ( nquality , x , y , npts , r , val , debug ) integer , parameter :: dp = selected_real_kind ( 10 , 100 ) integer , intent ( in ) :: nquality ! Quality parameter real ( dp ), intent ( in ) :: x ( * ), y ( * ) integer , intent ( in ) :: npts ! Size of x, y arrays real ( dp ), intent ( in ) :: r real ( dp ), intent ( out ) :: val logical , intent ( in ) :: debug end subroutine interpolate end interface ! procedure ( interpolate ), pointer , public :: & interpolator => null () ! ! Note that initialization of procedure pointers at declaration ! is a f2008 feature not yet supported by some compilers... !                       interpolator => dpnint1 public :: set_interpolator , set_default_interpolator private :: dpnint1 CONTAINS subroutine set_interpolator ( func , nquality ) ! Parameter for interpolator's quality ! It might mean different things for different ! interpolators integer , intent ( in ) :: nquality ! We should not need to repeat this... interface subroutine func ( nquality , x , y , npts , r , val , debug ) integer , parameter :: dp = selected_real_kind ( 10 , 100 ) integer , intent ( in ) :: nquality ! Quality parameter real ( dp ), intent ( in ) :: x ( * ), y ( * ) integer , intent ( in ) :: npts ! Size of x, y arrays real ( dp ), intent ( in ) :: r real ( dp ), intent ( out ) :: val logical , intent ( in ) :: debug end subroutine func end interface interpolator => func nq = nquality end subroutine set_interpolator ! ! This routine is needed to work around f2008 issue above ! subroutine set_default_interpolator () ! Default interpolator and quality parameter ! DRH's dpnint modified by AG, at 7th order ! (Included in this module with permission) ! call set_interpolator ( dpnint1 , 7 ) end subroutine set_default_interpolator #endif    /* For systems without procedure pointers */ ! ! Copyright (c) 1989-2014 by D. R. Hamann, Mat-Sim Research LLC and Rutgers ! University ! ! Modified by Alberto Garcia, March 2015 ! This routine is included in this module with permission from D.R. Hamann. ! subroutine dpnint1 ( npoly , xx , yy , nn , r , val , debug ) ! Modified by Alberto Garcia, March 2015 from routine ! dpnint by D.R. Hamann. ! Changes: !   -- A single value is returned !   -- It can extrapolate, instead of stopping, !      when called with an abscissa outside the !      data range. !   -- If the number of data points is less than !      npoly+1, npoly is implicitly reduced, without !      error, and without warning. !   -- Debug interface ! ! local polynomial interpolation of data yy on nn points xx ! giving value val on point r ! npoly sets order of polynomial ! xx must be ordered in ascending order ! output interpolated value val on point r implicit none integer , parameter :: dp = kind ( 1.0 d0 ) !Input variables real ( dp ), intent ( in ) :: xx ( * ), yy ( * ) real ( dp ), intent ( in ) :: r real ( dp ), intent ( out ) :: val integer , intent ( in ) :: nn , npoly logical , intent ( in ) :: debug !Local variables real ( dp ) :: sum , term , zz integer ii , imin , imax , iprod , iy , istart , kk , iend ! interval halving search for xx(ii) points bracketing r imin = 1 imax = nn do kk = 1 , nn ii = ( imin + imax ) / 2 if ( r > xx ( ii )) then imin = ii else imax = ii end if if ( imax - imin . eq . 1 ) then exit end if end do zz = r !   if (debug) print *, \"imin, imax: \", imin, imax if ( mod ( npoly , 2 ) == 1 ) then istart = imin - npoly / 2 else if ( zz - xx ( imin ) < xx ( imax ) - zz ) then istart = imin - npoly / 2 else istart = imax - npoly / 2 end if istart = min ( istart , nn - npoly ) istart = max ( istart , 1 ) iend = min ( istart + npoly , nn ) !  if (debug) print *, \"istart, iend: \", istart, iend sum = 0.0 d0 do iy = istart , iend if ( yy ( iy ) == 0.0 d0 ) cycle term = yy ( iy ) do iprod = istart , iend if ( iprod == iy ) cycle term = term * ( zz - xx ( iprod )) / ( xx ( iy ) - xx ( iprod )) end do sum = sum + term end do val = sum end subroutine dpnint1 end module m_interp","tags":"","loc":"sourcefile/m_interp.f90.html","title":"m_interp.F90 – libPSML"},{"text":"Modules m_psml Source Code m_psml.F90 Source Code module m_psml ! use m_psml_reader , only : psml_reader use m_psml_core , only : ps_t , ps_destroy use m_psml_core , only : str_of_set use m_psml_core , only : SET_SREL , & SET_NONREL , & SET_SO , & SET_LJ , & SET_UP , & SET_DOWN , & SET_SPINAVE , & SET_SPINDIFF , & SET_USER1 , & SET_USER2 , & SET_ALL use m_psml_api use m_psml_dump use m_psml_ps_edit use assoc_list , only : ps_annotation_t => assoc_list_t use assoc_list , only : nitems_annotation => assoc_list_nitems use assoc_list , only : get_annotation_key => assoc_list_get_key use assoc_list , only : get_annotation_value => assoc_list_get_value use assoc_list , only : insert_annotation_pair => assoc_list_insert use assoc_list , only : init_annotation => assoc_list_init use assoc_list , only : reset_annotation => assoc_list_reset public end module m_psml","tags":"","loc":"sourcefile/m_psml.f90.html","title":"m_psml.F90 – libPSML"},{"text":"libPSML API implementation Modules m_psml_api Source Code m_psml_api.F90 Source Code !+ libPSML API implementation module m_psml_api !+ graph: false !+ Procedures to handle the PSML pseudopotential format. use m_psml_core ! For basic structures use assoc_list , only : ps_annotation_t => assoc_list_t use assoc_list , only : EMPTY_ANNOTATION => EMPTY_ASSOC_LIST use external_interfaces , only : die => psml_die use class_Grid implicit none integer , parameter :: dp = selected_real_kind ( 14 ) logical :: global_debug = . false . character ( len = 1 ), dimension ( 0 : 4 ) :: sym = ( / \"s\" , \"p\" , \"d\" , \"f\" , \"g\" / ) public :: ps_GetLibPSMLVersion public :: ps_SetDebug #ifndef  __NO_PROC_POINTERS__ public :: ps_SetInterpolator #endif public :: ps_SetInterpolatorQuality ! ! Accessor list ! public :: ps_AtomicSymbol public :: ps_AtomicLabel public :: ps_AtomicNumber public :: ps_ZPseudo public :: ps_GenerationZval public :: ps_PseudoFlavor public :: ps_GetUUID public :: ps_GetPSMLVersion public :: ps_Creator public :: ps_Date public :: ps_GetAnnotation public :: ps_NLibxcFunctionals public :: ps_LibxcName public :: ps_LibxcId public :: ps_LibxcWeight public :: ps_ValidLibxc public :: ps_XCAnnotation public :: ps_Relativity public :: ps_IsSpinPolarized public :: ps_HasCoreCorrections public :: ps_NValenceShells public :: ps_ValenceShellL public :: ps_ValenceShellN public :: ps_ValenceShellOccupation ! ! Semilocal potentials ! public :: ps_HasSemilocalPotentials public :: ps_Get_Potential_Indexes public :: ps_Number_Of_Potentials public :: ps_Potential_L public :: ps_Potential_J public :: ps_Potential_N public :: ps_Potential_Rc public :: ps_Potential_Set public :: ps_Potential_Value public :: ps_Potential_GetRawData ! public :: ps_HasPsOperator ! ! Vlocal ! public :: ps_HasLocalPotential public :: ps_LocalPotential_Value public :: ps_LocalPotential_Type public :: ps_LocalPotential_GetRawData ! ! Local Charge ! public :: ps_HasLocalCharge public :: ps_LocalCharge_Value ! ! Projectors ! public :: ps_HasProjectors public :: ps_Number_Of_Projectors public :: ps_Get_Projector_Indexes public :: ps_Get_Projector_Indexes_byL public :: ps_Projector_L public :: ps_Projector_J public :: ps_Projector_Seq public :: ps_Projector_Ekb public :: ps_Projector_Type public :: ps_Projector_Set public :: ps_Projector_Value public :: ps_Projector_GetRawData ! ! Pseudo-wave-functions ! public :: ps_Number_Of_PseudoWfs public :: ps_Get_PseudoWf_Indexes public :: ps_PseudoWf_L public :: ps_PseudoWf_J public :: ps_PseudoWf_N public :: ps_PseudoWf_Set public :: ps_PseudoWf_Value public :: ps_PseudoWf_GetRawData ! public :: ps_ValenceCharge_Value public :: ps_ValenceCharge_GetRawData ! public :: ps_CoreCharge_Value public :: ps_CoreCharge_GetRawData public :: ps_CoreCharge_MatchingRadius public :: ps_CoreCharge_NumberOfKeptDerivatives ! private CONTAINS !=============================================== !>  Returns the library version in integer format function ps_GetLibPSMLVersion () result ( v ) integer :: v v = PSML_LIBRARY_VERSION end function ps_GetLibPSMLVersion !>  Sets the global debug flag !> @param debug:logical subroutine ps_SetDebug ( debug ) logical , intent ( in ) :: debug global_debug = debug end subroutine ps_SetDebug #ifndef __NO_PROC_POINTERS__ !> Sets the default interpolator and !> its quality parameter subroutine ps_SetInterpolator ( func , nquality ) use m_interp , only : interpolator , nq ! Parameter for interpolator's quality ! It might mean different things for different ! interpolators integer , intent ( in ) :: nquality interface subroutine func ( nquality , x , y , npts , r , val , debug ) integer , parameter :: dp = selected_real_kind ( 10 , 100 ) integer , intent ( in ) :: nquality ! Quality parameter real ( dp ), intent ( in ) :: x ( * ), y ( * ) integer , intent ( in ) :: npts ! Size of x, y arrays real ( dp ), intent ( in ) :: r real ( dp ), intent ( out ) :: val logical , intent ( in ) :: debug end subroutine func end interface interpolator => func nq = nquality end subroutine ps_SetInterpolator #endif !> Sets the quality parameter of the current !> default interpolator. Useful when we do !> not care about the type of evaluator, but !> want to compare different qualities subroutine ps_SetInterpolatorQuality ( nquality ) use m_interp , only : nq ! Parameter for interpolator's quality ! It might mean different things for different ! interpolators integer , intent ( in ) :: nquality nq = nquality end subroutine ps_SetInterpolatorQuality !> Returns the number of non-empty valence shells !> in the ps generation configuration !> @param ps is a handle to the psml information function ps_NValenceShells ( ps ) result ( nshells ) type ( ps_t ), intent ( in ) :: ps integer :: nshells nshells = ps % config_val % nshells end function ps_NValenceShells !> Returns the angular momentum of the i'th valence shell !> in the ps generation configuration !> @param ps is a handle to the psml information !> @param i is the index of the shell !> @note i should be within range function ps_ValenceShellL ( ps , i ) result ( l ) type ( ps_t ), intent ( in ) :: ps integer , intent ( in ) :: i integer :: l character ( len = 1 ) :: str call check_index ( i , ps % config_val % nshells , \"valence shell\" ) l = l_of_sym ( ps % config_val % l ( i ), \"valence shell\" ) end function ps_ValenceShellL !>  Returns the principal quantum number of the i'th valence shell !> in the ps generation configuration !> @author Alberto Garcia !> @date 2014 !> @param ps is a handle to the psml information !> @param i is the index of the shell !> @note i should be within range function ps_ValenceShellN ( ps , i ) result ( n ) type ( ps_t ), intent ( in ) :: ps integer , intent ( in ) :: i integer :: n call check_index ( i , ps % config_val % nshells , \"valence shell\" ) n = ps % config_val % n ( i ) end function ps_ValenceShellN !>  Returns the occupation of the i'th valence shell !> in the ps generation configuration !> @author Alberto Garcia !> @date 2014 !> @param ps is a handle to the psml information !> @param i is the index of the shell !> @param channel is an optional parameter for spin-polarized !> calculations (\"u\" or \"d\"). !> @note i should be within range !> @note If \"channel\" is present, the occupation returned !> corresponds to the given channel function ps_ValenceShellOccupation ( ps , i , channel ) result ( occ ) type ( ps_t ), intent ( in ) :: ps integer , intent ( in ) :: i character ( len = 1 ), intent ( in ), optional :: channel real ( dp ) :: occ call check_index ( i , ps % config_val % nshells , \"valence shell\" ) if ( present ( channel )) then if ( ps_IsSpinPolarized ( ps )) then if ( channel == \"u\" ) then occ = ps % config_val % occ_up ( i ) else if ( channel == \"d\" ) then occ = ps % config_val % occ_down ( i ) else call die ( \"Wrong channel in ValShellOccupation\" ) endif else call die ( \"Cannot speficy channel in ValShellOccupation\" ) endif else occ = ps % config_val % occ ( i ) endif end function ps_ValenceShellOccupation ! !------------------------------------------------------- !>  Computes the value of the valence charge at r !> @param ps is a handle to the psml information !> @param r is the radius !> It returns the valence charge density integrated over !> solid angle, so that Q_val = int{ val*r*r } !> function ps_ValenceCharge_Value ( ps , r ) result ( val ) type ( ps_t ), intent ( in ) :: ps real ( dp ), intent ( in ) :: r real ( dp ) :: val if ( r > max_range ( ps % valence_charge % rho_val )) then val = 0.0_dp else val = eval_radfunc ( ps % valence_charge % rho_val , r , debug = global_debug ) endif end function ps_ValenceCharge_Value subroutine ps_ValenceCharge_GetRawData ( ps , raw_r , raw_data ) type ( ps_t ), intent ( in ) :: ps real ( dp ), allocatable , intent ( out ) :: raw_r (:), raw_data (:) call get_raw_radfunc ( ps % valence_charge % rho_val , raw_r , raw_data ) end subroutine ps_ValenceCharge_GetRawData !>  Computes the value of the pseudo-core charge at r !> @param ps is a handle to the psml information !> @param r is the radius !> It returns the pseudo-core charge density integrated over !> solid angle, so that Q_core = int{ val*r*r } !> function ps_CoreCharge_Value ( ps , r ) result ( val ) type ( ps_t ), intent ( in ) :: ps real ( dp ), intent ( in ) :: r real ( dp ) :: val if ( r > max_range ( ps % core_charge % rho_core )) then val = 0.0_dp else val = eval_radfunc ( ps % core_charge % rho_core , r , debug = global_debug ) endif end function ps_CoreCharge_Value subroutine ps_CoreCharge_GetRawData ( ps , raw_r , raw_data ) type ( ps_t ), intent ( in ) :: ps real ( dp ), allocatable , intent ( out ) :: raw_r (:), raw_data (:) call get_raw_radfunc ( ps % core_charge % rho_core , raw_r , raw_data ) end subroutine ps_CoreCharge_GetRawData !>  Returns the matching radius used in the fit of the !>  pseudo-core charge !> @param ps is a handle to the psml information !> It returns -1.0 if the information is not provided in the file function ps_CoreCharge_MatchingRadius ( ps ) result ( rmatch ) type ( ps_t ), intent ( in ) :: ps real ( dp ) :: rmatch rmatch = ps % core_charge % rcore end function ps_CoreCharge_MatchingRadius !>  Returns the number of derivatives kept in the fit of the !>  pseudo-core charge !> @param ps is a handle to the psml information !> It returns -1 if the information is not provided in the file function ps_CoreCharge_NumberOfKeptDerivatives ( ps ) result ( n ) type ( ps_t ), intent ( in ) :: ps integer :: n n = ps % core_charge % n_cont_derivs end function ps_CoreCharge_NumberOfKeptDerivatives !>  Returns the atomic symbol !> @param ps is a handle to the psml information ! function ps_AtomicSymbol ( ps ) result ( name ) type ( ps_t ), intent ( in ) :: ps character ( len = 2 ) :: name name = ps % header % atomic_label ( 1 : 2 ) end function ps_AtomicSymbol ! !>  Returns the atomic label !> @param ps is a handle to the psml information !> The label is more general than the atomic symbol !> function ps_AtomicLabel ( ps ) result ( name ) type ( ps_t ), intent ( in ) :: ps character ( len = len_trim ( ps % header % atomic_label )) :: name name = trim ( ps % header % atomic_label ) end function ps_AtomicLabel ! !>  Returns the atomic number !> @param ps is a handle to the psml information !> function ps_AtomicNumber ( ps ) result ( z ) type ( ps_t ), intent ( in ) :: ps real ( dp ) :: z z = ps % header % z end function ps_AtomicNumber ! !>  Returns the PSML version used in the file ! function ps_GetPSMLVersion ( ps ) result ( version ) type ( ps_t ), intent ( in ) :: ps character ( len = 10 ) :: version version = ps % version end function ps_GetPSMLVersion ! !>  Returns the unique uuid of the PSML file ! function ps_GetUUID ( ps ) result ( name ) type ( ps_t ), intent ( in ) :: ps character ( len = 36 ) :: name name = ps % uuid end function ps_GetUUID ! !>  Returns the creator of the PSML file, as !> written in the provenance element. !> @param ps is a handle to the psml information !> The format is arbitrary ! function ps_Creator ( ps ) result ( name ) type ( ps_t ), intent ( in ) :: ps character ( len = len_trim ( ps % provenance % creator )) :: name name = trim ( ps % provenance % creator ) end function ps_Creator ! !>  Returns the date appearing in the provenance element. !> @param ps is a handle to the psml information !> The format is arbitrary ! function ps_Date ( ps ) result ( str ) type ( ps_t ), intent ( in ) :: ps character ( len = len_trim ( ps % provenance % date )) :: str str = trim ( ps % provenance % date ) end function ps_Date ! ! **AG** !> ! function ps_PseudoFlavor ( ps ) result ( str ) !+ category: needs_work !+  Returns the pseudization flavor appearing in the header element. !*### NOTE ! Generalize to accept an index argument for potential ! In principle, different flavors for different channels are ! possible in the PSML file, but there is not support in the API for it. type ( ps_t ), intent ( in ) :: ps !+ Handle for PSML information character ( len = len_trim ( ps % header % flavor )) :: str str = trim ( ps % header % flavor ) end function ps_PseudoFlavor function ps_ZPseudo ( ps ) result ( zpseudo ) !*  Returns the effective valence of the pseudo-atom, ! i.e., the atomic number minus the number of \"core\" electrons. type ( ps_t ), intent ( in ) :: ps !+ Handle for PSML information real ( dp ) :: zpseudo zpseudo = ps % header % zpseudo end function ps_ZPseudo !>  Returns the total valence charge density in the !> atomic configuration used to generate the pseudopotential. !> !> @param ps is a handle to the psml information !> function ps_GenerationZval ( ps ) result ( zval ) type ( ps_t ), intent ( in ) :: ps real ( dp ) :: zval zval = ps % config_val % total_charge end function ps_GenerationZval ! !>  Returns the number of libxc functionals that !> would correspond to the exchange-correlation scheme !> used in the generation code. !> @param ps is a handle to the psml information !> function ps_NLibxcFunctionals ( ps ) result ( xc_n ) type ( ps_t ), intent ( in ) :: ps integer :: xc_n xc_n = ps % xc_info % n_functs_libxc end function ps_NLibxcFunctionals ! function ps_LibxcName ( ps , i ) result ( xc_name ) type ( ps_t ), intent ( in ) :: ps integer , intent ( in ) :: i character ( len = 50 ) :: xc_name call check_index ( i , ps % xc_info % n_functs_libxc , \"libxc functional\" ) xc_name = ps % xc_info % libxc_name ( i ) end function ps_LibxcName ! function ps_LibxcId ( ps , i ) result ( xc_id ) type ( ps_t ), intent ( in ) :: ps integer , intent ( in ) :: i integer :: xc_id call check_index ( i , ps % xc_info % n_functs_libxc , \"libxc functional\" ) xc_id = ps % xc_info % libxc_id ( i ) end function ps_LibxcId ! function ps_LibxcWeight ( ps , i ) result ( xc_weight ) type ( ps_t ), intent ( in ) :: ps integer , intent ( in ) :: i real ( dp ) :: xc_weight call check_index ( i , ps % xc_info % n_functs_libxc , \"libxc functional\" ) xc_weight = ps % xc_info % libxc_weight ( i ) end function ps_LibxcWeight ! function ps_LibxcIdArray ( ps ) result ( xc_id_array ) type ( ps_t ), intent ( in ) :: ps integer :: xc_id_array ( 2 ) xc_id_array (:) = ps % xc_info % libxc_id (:) end function ps_LibxcIdArray ! function ps_ValidLibxc ( ps ) result ( libxc_ok ) type ( ps_t ), intent ( in ), target :: ps logical :: libxc_ok integer , pointer :: xc_id_array (:) xc_id_array => ps % xc_info % libxc_id (:) libxc_ok = . true . if ( any ( xc_id_array (:) <= 0 )) then libxc_ok = . false . endif end function ps_ValidLibxc ! !================================================= !>  Returns the annotation associated to a !> given element. For grids, if a radial function !> handle is given, the annotation for that !> radial function's grid is returned. Otherwise, !> the return value is the annotation for the global grid. !> If there is no appropriate annotation, an empty !> structure is returned. !> @note Support for radfunc handles is not yet implemented !> @param ps is a handle to the psml information !> @param name is the element name or a common alias !> @param radfunc is a handle to a radial function structure !> function ps_GetAnnotation ( ps , name ) result ( annotation ) !! ,radfunc)  To be implemented type ( ps_t ), intent ( in ) :: ps character ( len =* ), intent ( in ) :: name !!  type(radfunc_t), intent(in), optional  :: radfunc type ( ps_annotation_t ) :: annotation type ( ps_annotation_t ), pointer :: annotation_p select case ( name ) case ( \"psml\" , \"PSML\" , \"top-level\" , \"global\" ) annotation = ps % annotation case ( \"provenance\" ) annotation = ps % provenance % annotation case ( \"exchange-correlation\" , \"xc\" , \"XC\" ) annotation = ps % xc_info % annotation case ( \"valence-configuration\" ) annotation = ps % config_val % annotation case ( \"grid\" ) !!$      if (present(radfunc)) then !!$         ! We are told to get the grid annotation !!$         ! for a specific radial function !!$ !!$         if (.not. associated(radfunc%grid)) then !!$            call die(\"get_annotation: Invalid radial function\") !!$         endif !!$         annotation = radfunc%grid%annotation !!$ !!$      else ! This is the global grid annotation if (. not . initialized ( ps % global_grid )) then annotation = EMPTY_ANNOTATION else annotation_p => annotationGrid ( ps % global_grid ) annotation = annotation_p endif !!$      endif case ( \"semilocal-potentials\" ) annotation = ps % semilocal % annotation case ( \"nonlocal-projectors\" ) annotation = ps % nonlocal % annotation case ( \"local-potential\" ) annotation = ps % local % annotation case ( \"pseudo-wavefunctions\" ) annotation = ps % pswfs % annotation case ( \"valence-charge\" ) annotation = ps % valence_charge % annotation case ( \"core-charge\" ) annotation = ps % core_charge % annotation case default call die ( \"Unrecognized annotation name: \" // trim ( name )) end select end function ps_GetAnnotation ! ! The following two functions are retained for ! backwards compatibility ! function ps_XCAnnotation ( ps ) result ( xc_annotation ) type ( ps_t ), intent ( in ) :: ps type ( ps_annotation_t ) :: xc_annotation xc_annotation = ps % xc_info % annotation end function ps_XCAnnotation ! !================================================= function ps_Relativity ( ps ) result ( rel ) type ( ps_t ), intent ( in ) :: ps character ( len = 6 ) :: rel rel = ps % header % relativity end function ps_Relativity ! function ps_IsSpinPolarized ( ps ) result ( pol ) type ( ps_t ), intent ( in ) :: ps logical :: pol pol = ps % header % polarized end function ps_IsSpinPolarized ! function ps_HasCoreCorrections ( ps ) result ( cc ) type ( ps_t ), intent ( in ) :: ps logical :: cc cc = ( ps % header % core_corrections == \"yes\" ) end function ps_HasCoreCorrections !================================================= ! !----- Convenience set handling routines ! subroutine ps_Get_Potential_Indexes ( ps , set , indexes ) type ( ps_t ), intent ( in ) :: ps integer , intent ( in ) :: set integer , allocatable , intent ( inout ) :: indexes (:) integer :: i , n n = 0 do i = 1 , size ( ps % sl_table ) if ( iand ( ps % sl_table ( i )% p % set , set ) /= 0 ) n = n + 1 enddo if ( allocated ( indexes )) deallocate ( indexes ) allocate ( indexes ( n )) n = 0 do i = 1 , size ( ps % sl_table ) if ( iand ( ps % sl_table ( i )% p % set , set ) /= 0 ) then n = n + 1 indexes ( n ) = i end if enddo end subroutine ps_Get_Potential_Indexes subroutine ps_Get_Projector_Indexes ( ps , set , indexes ) type ( ps_t ), intent ( in ) :: ps integer , intent ( in ) :: set integer , allocatable , intent ( inout ) :: indexes (:) integer :: i , n n = 0 do i = 1 , size ( ps % nl_table ) if ( iand ( ps % nl_table ( i )% p % set , set ) /= 0 ) n = n + 1 enddo if ( allocated ( indexes )) deallocate ( indexes ) allocate ( indexes ( n )) n = 0 do i = 1 , size ( ps % nl_table ) if ( iand ( ps % nl_table ( i )% p % set , set ) /= 0 ) then n = n + 1 indexes ( n ) = i end if enddo end subroutine ps_Get_Projector_Indexes subroutine ps_Get_PseudoWf_Indexes ( ps , set , indexes ) type ( ps_t ), intent ( in ) :: ps integer , intent ( in ) :: set integer , allocatable , intent ( inout ) :: indexes (:) call GetSetIndexes ( ps % pswfs % npswfs , ps % pswfs % set , set , indexes ) end subroutine ps_Get_PseudoWf_Indexes function ps_Number_Of_Potentials ( ps , set ) result ( n ) type ( ps_t ), intent ( in ) :: ps integer , intent ( in ) :: set integer :: n integer , allocatable :: idx (:) call ps_Get_Potential_Indexes ( ps , set , idx ) n = size ( idx ) deallocate ( idx ) end function ps_Number_Of_Potentials function ps_Number_Of_Projectors ( ps , set ) result ( n ) type ( ps_t ), intent ( in ) :: ps integer , intent ( in ) :: set integer :: n integer , allocatable :: idx (:) call ps_Get_Projector_Indexes ( ps , set , idx ) n = size ( idx ) deallocate ( idx ) end function ps_Number_Of_Projectors function ps_Number_Of_PseudoWfs ( ps , set ) result ( n ) type ( ps_t ), intent ( in ) :: ps integer , intent ( in ) :: set integer :: n integer , allocatable :: idx (:) call ps_Get_PseudoWf_Indexes ( ps , set , idx ) n = size ( idx ) deallocate ( idx ) end function ps_Number_Of_PseudoWfs ! !==================================================== ! Semilocal potentials ! function ps_Potential_Set ( ps , i ) result ( set ) type ( ps_t ), intent ( in ) :: ps integer , intent ( in ) :: i integer :: set call check_index ( i , size ( ps % sl_table ), \"SL pot\" ) set = ps % sl_table ( i )% p % set ! end function ps_Potential_Set ! function ps_Potential_L ( ps , i ) result ( l ) type ( ps_t ), intent ( in ) :: ps integer , intent ( in ) :: i integer :: l call check_index ( i , size ( ps % sl_table ), \"SL pot\" ) l = l_of_sym ( ps % sl_table ( i )% p % l , \"SL pot\" ) end function ps_Potential_L ! function ps_Potential_J ( ps , i ) result ( j ) type ( ps_t ), intent ( in ) :: ps integer , intent ( in ) :: i real ( dp ) :: j call check_index ( i , size ( ps % sl_table ), \"SL pot\" ) if ( iand ( ps % sl_table ( i )% p % set , & SET_LJ + SET_USER1 + SET_USER2 ) & == 0 ) then call die ( \"Attempt to get j from wrong set\" ) endif j = ps % sl_table ( i )% p % j end function ps_Potential_J ! function ps_Potential_Rc ( ps , i ) result ( rc ) type ( ps_t ), intent ( in ) :: ps integer , intent ( in ) :: i real ( dp ) :: rc call check_index ( i , size ( ps % sl_table ), \"SL pot\" ) rc = ps % sl_table ( i )% p % rc end function ps_Potential_Rc ! function ps_Potential_N ( ps , i ) result ( n ) type ( ps_t ), intent ( in ) :: ps integer , intent ( in ) :: i integer :: n call check_index ( i , size ( ps % sl_table ), \"SL pot\" ) n = ps % sl_table ( i )% p % n end function ps_Potential_N ! !> Evaluator by storage index function ps_Potential_Value ( ps , i , r ) result ( val ) type ( ps_t ), intent ( in ) :: ps integer , intent ( in ) :: i real ( dp ), intent ( in ) :: r real ( dp ) :: val logical :: coulomb_tail call check_index ( i , size ( ps % sl_table ), \"SL pot\" ) select case ( ps % sl_table ( i )% p % set ) case ( SET_SO , SET_SPINDIFF ) coulomb_tail = . false . case default coulomb_tail = . true . end select if ( r > max_range ( ps % sl_table ( i )% p % V )) then if ( coulomb_tail ) then val = - ps_ZPseudo ( ps ) / r else val = 0.0_dp endif else val = eval_radfunc ( ps % sl_table ( i )% p % V , r , debug = global_debug ) endif end function ps_Potential_Value subroutine ps_Potential_GetRawData ( ps , i , raw_r , raw_data ) type ( ps_t ), intent ( in ) :: ps integer , intent ( in ) :: i real ( dp ), allocatable , intent ( out ) :: raw_r (:), raw_data (:) call get_raw_radfunc ( ps % sl_table ( i )% p % V , raw_r , raw_data ) end subroutine ps_Potential_GetRawData ! !==================================================== ! PseudoWavefunctions ! ! Basic accessors ! function ps_PseudoWf_L ( ps , i ) result ( l ) type ( ps_t ), intent ( in ) :: ps integer , intent ( in ) :: i integer :: l call check_index ( i , ps % pswfs % npswfs , \"pswf\" ) l = l_of_sym ( ps % pswfs % l ( i ), \"pswf\" ) end function ps_PseudoWf_L ! function ps_PseudoWf_J ( ps , i ) result ( j ) type ( ps_t ), intent ( in ) :: ps integer , intent ( in ) :: i real ( dp ) :: j call check_index ( i , ps % pswfs % npswfs , \"pswf\" ) if ( iand ( ps % pswfs % set ( i ), & SET_LJ + SET_USER1 + SET_USER2 ) & == 0 ) then call die ( \"Attempt to get j from wrong set\" ) endif j = ps % pswfs % j ( i ) end function ps_PseudoWf_J ! function ps_PseudoWf_N ( ps , i ) result ( n ) type ( ps_t ), intent ( in ) :: ps integer , intent ( in ) :: i integer :: n call check_index ( i , ps % pswfs % npswfs , \"pswf\" ) n = ps % pswfs % n ( i ) end function ps_PseudoWf_N ! function ps_PseudoWf_Set ( ps , i ) result ( set ) type ( ps_t ), intent ( in ) :: ps integer , intent ( in ) :: i integer :: set call check_index ( i , ps % pswfs % npswfs , \"pswf\" ) set = ps % pswfs % set ( i ) ! end function ps_PseudoWf_Set ! ! function ps_PseudoWf_Value ( ps , i , r ) result ( val ) type ( ps_t ), intent ( in ) :: ps integer , intent ( in ) :: i real ( dp ), intent ( in ) :: r real ( dp ) :: val call check_index ( i , ps % pswfs % npswfs , \"pswf\" ) if ( r > max_range ( ps % pswfs % Phi ( i ))) then val = 0.0_dp else val = eval_radfunc ( ps % pswfs % Phi ( i ), r , debug = global_debug ) endif end function ps_PseudoWf_Value ! ! subroutine ps_PseudoWf_GetRawData ( ps , i , raw_r , raw_data ) type ( ps_t ), intent ( in ) :: ps integer , intent ( in ) :: i real ( dp ), allocatable , intent ( out ) :: raw_r (:), raw_data (:) call get_raw_radfunc ( ps % pswfs % Phi ( i ), raw_r , raw_data ) end subroutine ps_PseudoWf_GetRawData ! !==================================================== ! Pseudopotential operator (Vlocal, LocalCharge, projectors) ! ! Basic accessors ! function ps_HasProjectors ( ps ) result ( p ) type ( ps_t ), intent ( in ) :: ps logical :: p ! p = ( size ( ps % nl_table ) > 0 ) end function ps_HasProjectors function ps_HasLocalPotential ( ps ) result ( p ) type ( ps_t ), intent ( in ) :: ps logical :: p ! p = ( initialized ( ps % local % Vlocal % grid )) end function ps_HasLocalPotential function ps_HasLocalCharge ( ps ) result ( p ) type ( ps_t ), intent ( in ) :: ps logical :: p ! p = ( initialized ( ps % local % chlocal % grid )) end function ps_HasLocalCharge function ps_HasPSOperator ( ps ) result ( psop ) type ( ps_t ), intent ( in ) :: ps logical :: psop ! psop = ( ps_HasProjectors ( ps ) . and . ps_HasLocalPotential ( ps )) end function ps_HasPSOperator ! function ps_HasSemilocalPotentials ( ps ) result ( p ) type ( ps_t ), intent ( in ) :: ps logical :: p ! p = ( associated ( ps % semilocal )) end function ps_HasSemilocalPotentials ! function ps_LocalPotential_Value ( ps , r ) result ( val ) type ( ps_t ), intent ( in ) :: ps real ( dp ), intent ( in ) :: r real ( dp ) :: val if ( r > max_range ( ps % local % vlocal )) then ! There should be a sanity check upon parsing ! to guarantee that the coulomb behavior has ! been reached at the end of the grid range val = - ps_ZPseudo ( ps ) / r else val = eval_radfunc ( ps % local % vlocal , r , debug = global_debug ) endif end function ps_LocalPotential_Value function ps_LocalCharge_Value ( ps , r ) result ( val ) type ( ps_t ), intent ( in ) :: ps real ( dp ), intent ( in ) :: r real ( dp ) :: val if ( r > max_range ( ps % local % chlocal )) then ! There should be a sanity check upon parsing ! to guarantee that the coulomb behavior has ! been reached at the end of the grid range val = 0.0_dp else val = eval_radfunc ( ps % local % chlocal , r , debug = global_debug ) endif end function ps_LocalCharge_Value ! function ps_LocalPotential_Type ( ps ) result ( type ) type ( ps_t ), intent ( in ) :: ps character ( len = 40 ) :: type type = ps % local % vlocal_type ! end function ps_LocalPotential_Type ! subroutine ps_LocalPotential_GetRawData ( ps , raw_r , raw_data ) type ( ps_t ), intent ( in ) :: ps real ( dp ), allocatable , intent ( out ) :: raw_r (:), raw_data (:) call get_raw_radfunc ( ps % local % vlocal , raw_r , raw_data ) end subroutine ps_LocalPotential_GetRawData function ps_Projector_L ( ps , i ) result ( l ) type ( ps_t ), intent ( in ) :: ps integer , intent ( in ) :: i integer :: l call check_index ( i , size ( ps % nl_table ), \"proj\" ) l = l_of_sym ( ps % nl_table ( i )% p % l , \"proj\" ) end function ps_Projector_L ! function ps_Projector_J ( ps , i ) result ( j ) type ( ps_t ), intent ( in ) :: ps integer , intent ( in ) :: i real ( dp ) :: j call check_index ( i , size ( ps % nl_table ), \"proj\" ) if ( iand ( ps % nl_table ( i )% p % set , & SET_LJ + SET_USER1 + SET_USER2 ) & == 0 ) then call die ( \"Attempt to get j from wrong set\" ) endif j = ps % nl_table ( i )% p % j end function ps_Projector_J ! function ps_Projector_Ekb ( ps , i ) result ( ekb ) type ( ps_t ), intent ( in ) :: ps integer , intent ( in ) :: i real ( dp ) :: ekb call check_index ( i , size ( ps % nl_table ), \"proj\" ) ekb = ps % nl_table ( i )% p % ekb end function ps_Projector_Ekb ! function ps_Projector_Seq ( ps , i ) result ( seq ) type ( ps_t ), intent ( in ) :: ps integer , intent ( in ) :: i integer :: seq call check_index ( i , size ( ps % nl_table ), \"proj\" ) seq = ps % nl_table ( i )% p % seq end function ps_Projector_Seq ! function ps_Projector_Set ( ps , i ) result ( set ) type ( ps_t ), intent ( in ) :: ps integer , intent ( in ) :: i integer :: set call check_index ( i , size ( ps % nl_table ), \"proj\" ) set = ps % nl_table ( i )% p % set ! end function ps_Projector_Set ! function ps_Projector_Type ( ps , i ) result ( type ) type ( ps_t ), intent ( in ) :: ps integer , intent ( in ) :: i character ( len = 40 ) :: type call check_index ( i , size ( ps % nl_table ), \"proj\" ) type = ps % nl_table ( i )% p % type ! end function ps_Projector_Type function ps_Projector_Value ( ps , i , r ) result ( val ) !+ display: private type ( ps_t ), intent ( in ) :: ps integer , intent ( in ) :: i real ( dp ), intent ( in ) :: r real ( dp ) :: val call check_index ( i , size ( ps % nl_table ), \"proj\" ) if ( r > max_range ( ps % nl_table ( i )% p % proj )) then val = 0.0_dp else val = eval_radfunc ( ps % nl_table ( i )% p % proj , r , debug = global_debug ) endif end function ps_Projector_Value subroutine ps_Projector_GetRawData ( ps , i , raw_r , raw_data ) !+ deprecated: true type ( ps_t ), intent ( in ) :: ps integer , intent ( in ) :: i real ( dp ), allocatable , intent ( out ) :: raw_r (:), raw_data (:) call get_raw_radfunc ( ps % nl_table ( i )% p % proj , raw_r , raw_data ) end subroutine ps_Projector_GetRawData ! subroutine ps_Get_Projector_Indexes_byL ( ps , l , idxset , idxl ) !* Subset of projectors with given l ! Note that this function takes an array of indexes ! and returns another array of indexes ! There is currently no way to check that the idxset ! really corresponds to projectors... type ( ps_t ), intent ( in ) :: ps integer , intent ( in ) :: l integer , intent ( in ) :: idxset (:) integer , allocatable , intent ( inout ) :: idxl (:) integer :: n integer :: n_in_set , i , l_i n_in_set = size ( idxset ) n = 0 do i = 1 , n_in_set l_i = ps_Projector_L ( ps , idxset ( i )) if ( l_i == l ) n = n + 1 enddo if ( allocated ( idxl )) deallocate ( idxl ) allocate ( idxl ( n )) n = 0 do i = 1 , n_in_set l_i = ps_Projector_L ( ps , idxset ( i )) if ( l_i == l ) then n = n + 1 idxl ( n ) = idxset ( i ) endif enddo end subroutine ps_Get_Projector_Indexes_byL ! !==================================================== ! Low-level routines ! ! subroutine GetSetIndexes ( nitems , setarray , set , indexes ) integer , intent ( in ) :: nitems integer , intent ( in ) :: setarray (:) integer , intent ( in ) :: set integer , allocatable , intent ( inout ) :: indexes (:) integer :: n , i n = 0 do i = 1 , nitems if ( iand ( setarray ( i ), set ) /= 0 ) n = n + 1 enddo if ( allocated ( indexes )) deallocate ( indexes ) allocate ( indexes ( n )) n = 0 do i = 1 , nitems if ( iand ( setarray ( i ), set ) /= 0 ) then n = n + 1 indexes ( n ) = i end if enddo end subroutine GetSetIndexes ! subroutine check_index ( i , n , str ) integer , intent ( in ) :: i , n character ( len =* ), intent ( in ) :: str call assert ( ( i <= n ), \"Index overflow in \" // trim ( str )) call assert ( ( i > 0 ), \"Non-positive index in \" // trim ( str )) end subroutine check_index ! function l_of_sym ( str , name ) result ( l ) character ( len =* ), intent ( in ) :: str , name integer :: l ! ! This routine will disappear once we store ! l as integer in the data structure ! do l = 0 , 4 if ( str == sym ( l )) RETURN enddo call die ( \"Wrong l symbol in \" // trim ( name )) end function l_of_sym !>  Returns the maximum radius in a radfunc's grid function max_range ( f ) result ( range ) type ( radfunc_t ), intent ( in ) :: f real ( dp ) :: range real ( dp ), pointer :: a (:) integer :: npts npts = sizeGrid ( f % grid ) a => valGrid ( f % grid ) range = a ( npts ) end function max_range !---------- function eval_radfunc ( f , r , debug ) result ( val ) use m_interp , only : interpolator , nq type ( radfunc_t ), intent ( in ) :: f real ( dp ), intent ( in ) :: r real ( dp ) :: val logical , intent ( in ) :: debug real ( dp ), pointer :: x (:) => null (), y (:) => null () x => valGrid ( f % grid ) y => f % data (:) call interpolator ( nq , x , y , size ( x ), r , val , debug ) end function eval_radfunc subroutine get_raw_radfunc ( f , raw_r , raw_data ) ! type ( radfunc_t ), intent ( in ) :: f real ( dp ), intent ( out ), allocatable :: raw_r (:) real ( dp ), intent ( out ), allocatable :: raw_data (:) integer npts real ( dp ), pointer :: a (:) npts = sizeGrid ( f % grid ) allocate ( raw_r ( npts ), raw_data ( npts )) a => valGrid ( f % grid ) raw_r (:) = a (:) raw_data (:) = f % data (:) end subroutine get_raw_radfunc ! FUNCTION atomic_number ( SYMBOL ) result ( z ) ! Given the atomic symbol, it returns the atomic number ! Based on code by J. Soler character ( len = 2 ), intent ( in ) :: SYMBOL ! Atomic symbol integer :: Z ! Atomic number integer , parameter :: NZ = 103 character ( len = 2 ), parameter :: NAME ( NZ ) = & ( / 'H ' , 'He' , 'Li' , 'Be' , 'B ' , 'C ' , 'N ' , 'O ' , 'F ' , 'Ne' , & 'Na' , 'Mg' , 'Al' , 'Si' , 'P ' , 'S ' , 'Cl' , 'Ar' , 'K ' , 'Ca' , & 'Sc' , 'Ti' , 'V ' , 'Cr' , 'Mn' , 'Fe' , 'Co' , 'Ni' , 'Cu' , 'Zn' , & 'Ga' , 'Ge' , 'As' , 'Se' , 'Br' , 'Kr' , 'Rb' , 'Sr' , 'Y ' , 'Zr' , & 'Nb' , 'Mo' , 'Tc' , 'Ru' , 'Rh' , 'Pd' , 'Ag' , 'Cd' , 'In' , 'Sn' , & 'Sb' , 'Te' , 'I ' , 'Xe' , 'Cs' , 'Ba' , 'La' , 'Ce' , 'Pr' , 'Nd' , & 'Pm' , 'Sm' , 'Eu' , 'Gd' , 'Tb' , 'Dy' , 'Ho' , 'Er' , 'Tm' , 'Yb' , & 'Lu' , 'Hf' , 'Ta' , 'W ' , 'Re' , 'Os' , 'Ir' , 'Pt' , 'Au' , 'Hg' , & 'Tl' , 'Pb' , 'Bi' , 'Po' , 'At' , 'Rn' , 'Fr' , 'Ra' , 'Ac' , 'Th' , & 'Pa' , 'U ' , 'Np' , 'Pu' , 'Am' , 'Cm' , 'Bk' , 'Cf' , 'Es' , 'Fm' , & 'Md' , 'No' , 'Lr' / ) do z = 1 , NZ if ( SYMBOL == NAME ( Z )) then RETURN endif enddo call die ( \"Cannot find atomic number for \" // symbol ) end FUNCTION atomic_number subroutine assert ( cond , message ) logical , intent ( in ) :: cond character ( len =* ) message if (. not . cond ) call die ( message ) end subroutine assert end module m_psml_api","tags":"","loc":"sourcefile/m_psml_api.f90.html","title":"m_psml_api.F90 – libPSML"},{"text":"Data structures to handle the PSML pseudopotential format. Modules m_psml_core Source Code m_psml_core.f90 Source Code !+ graph: false !+ author: Alberto Garcia !+ Data structures to handle the PSML pseudopotential format. module m_psml_core use iso_varying_string , only : varying_string , var_str use assoc_list , only : ps_annotation_t => assoc_list_t use assoc_list , only : ps_clean_annotation => assoc_list_reset use class_Grid use external_interfaces , only : die => psml_die implicit none private ! !  Simple sanity checks while the format evolves !  This version is able to read v1.0 PSML files ! !  Note that the version is really given by the generators. ! ! Update this. Up to 99... integer , parameter :: PATCH_LEVEL = 3 ! ! Only update 1000 when changing major/minor version integer , parameter , public :: PSML_LIBRARY_VERSION = 1000 + PATCH_LEVEL ! ! These are PSML file format versions. Minor cosmetic (i.e., ! extra optional attributes) can be handled, but obviously ! not structural or semantic changes. Use versions of the ! form 1.00XXX ! ! The \"hi\" value is intended to auto-revoke the library, but ! it is neither completely foolproof nor flexible enough. ! real , parameter , public :: PSML_TARGET_VERSION_LO = 1.00 real , parameter , public :: PSML_TARGET_VERSION_HI = 1.01 !---------------------------------------------------------------- ! Hardwired parameters (to be made dynamical in a later version) ! Maximum number of valence shells (including semicore): integer , parameter , private :: MAXN_SHELLS = 20 ! Maximum number of pseudo-wavefunctions: integer , parameter , private :: MAXN_WFNS = 20 !---------------------------------------------------------------- integer , parameter , private :: dp = selected_real_kind ( 14 ) ! !----------------------------------------------------------- type , public :: input_file_t character ( len = 40 ) :: name = \"-----\" type ( varying_string ) :: buffer end type input_file_t !------ type , public :: provenance_t type ( provenance_t ), pointer :: prev => null () character ( len = 40 ) :: creator = \"-----\" character ( len = 30 ) :: date = \"-----\" type ( input_file_t ) :: input_file type ( ps_annotation_t ) :: annotation type ( provenance_t ), pointer :: next => null () end type provenance_t !------ type , public :: header_t character ( len = 30 ) :: atomic_label !! generalized symbol real ( kind = dp ) :: z !! atomic number (might be non-integer) real ( kind = dp ) :: zpseudo !! Z - ncore-electrons character ( len = 50 ) :: flavor !! pseudization method character ( len = 6 ) :: relativity !! \"no|scalar|dirac\" logical :: polarized !! is spin_polarized? ! character ( len = 3 ) :: core_corrections !! are there NLCC's? end type header_t !------ type , public :: config_val_t integer :: nshells real ( kind = dp ) :: total_charge integer , dimension ( MAXN_SHELLS ) :: n character ( len = 1 ), dimension ( MAXN_SHELLS ) :: l real ( dp ), dimension ( MAXN_SHELLS ) :: occ real ( dp ), dimension ( MAXN_SHELLS ) :: occ_up real ( dp ), dimension ( MAXN_SHELLS ) :: occ_down ! type ( ps_annotation_t ) :: annotation end type config_val_t !------ type , public :: xc_t integer :: n_functs_libxc = 0 character ( len = 50 ), allocatable :: libxc_name (:) character ( len = 50 ), allocatable :: libxc_type (:) integer , allocatable :: libxc_id (:) real ( dp ), allocatable :: libxc_weight (:) type ( ps_annotation_t ) :: annotation end type xc_t !------ type , public :: radfunc_t type ( Grid ) :: grid real ( kind = dp ), dimension (:), pointer :: data => null () end type radfunc_t ! !=============================================== type , public :: slps_t integer :: n character ( len = 1 ) :: l real ( dp ) :: j integer :: set character ( len = 40 ) :: flavor real ( dp ) :: rc type ( radfunc_t ) :: V type ( semilocal_t ), pointer :: parent_group => null () type ( slps_t ), pointer :: next => null () end type slps_t type , public :: sl_table_t type ( slps_t ), pointer :: p => null () end type sl_table_t type , public :: semilocal_t type ( slps_t ), pointer :: pot => null () integer :: set ! ! Optional private grid ! type ( Grid ) :: grid type ( ps_annotation_t ) :: annotation ! type ( semilocal_t ), pointer :: next => null () end type semilocal_t !=============================================== type , public :: local_t ! type ( ps_annotation_t ) :: annotation ! Optional private grid ! type ( Grid ) :: grid type ( radfunc_t ) :: Vlocal character ( len = 40 ) :: vlocal_type type ( radfunc_t ) :: Chlocal end type local_t !=============================================== type , public :: nlpj_t integer :: seq character ( len = 1 ) :: l real ( dp ) :: j integer :: set character ( len = 40 ) :: type real ( dp ) :: ekb type ( radfunc_t ) :: proj type ( nonlocal_t ), pointer :: parent_group => null () type ( nlpj_t ), pointer :: next => null () end type nlpj_t type , public :: nl_table_t type ( nlpj_t ), pointer :: p => null () end type nl_table_t type , public :: nonlocal_t type ( nlpj_t ), pointer :: proj => null () integer :: set ! ! Optional private grid ! type ( Grid ) :: grid type ( ps_annotation_t ) :: annotation ! type ( nonlocal_t ), pointer :: next => null () end type nonlocal_t !=============================================== type , public :: pswfs_t integer :: npswfs = 0 integer , dimension ( MAXN_WFNS ) :: n character ( len = 1 ), dimension ( MAXN_WFNS ) :: l real ( dp ), dimension ( MAXN_WFNS ) :: j integer , dimension ( MAXN_WFNS ) :: set type ( radfunc_t ), dimension ( MAXN_WFNS ) :: Phi ! ! Optional private grid ! type ( Grid ) :: grid type ( ps_annotation_t ) :: annotation end type pswfs_t type , public :: valence_charge_t real ( dp ) :: total_charge type ( radfunc_t ) :: rho_val type ( ps_annotation_t ) :: annotation end type valence_charge_t type , public :: core_charge_t integer :: n_cont_derivs real ( dp ) :: rcore type ( radfunc_t ) :: rho_core type ( ps_annotation_t ) :: annotation end type core_charge_t type , public :: ps_t !! Main derived type to hold the PSML information character ( len = 10 ) :: version = \"\" character ( len = 10 ) :: energy_unit = \"\" character ( len = 10 ) :: length_unit = \"\" character ( len = 36 ) :: uuid = \"\" type ( ps_annotation_t ) :: annotation type ( provenance_t ), pointer :: provenance => null () type ( header_t ) :: header type ( config_val_t ) :: config_val type ( xc_t ) :: xc_info type ( Grid ) :: global_grid type ( local_t ) :: local type ( semilocal_t ), pointer :: semilocal => null () type ( nonlocal_t ), pointer :: nonlocal => null () type ( pswfs_t ) :: pswfs ! type ( valence_charge_t ) :: valence_charge type ( core_charge_t ) :: core_charge ! ! index tables ! type ( sl_table_t ), allocatable :: sl_table (:) type ( nl_table_t ), allocatable :: nl_table (:) end type ps_t integer , parameter , public & :: SET_NULL = 0 , & SET_SREL = 1 , & SET_NONREL = 2 , & SET_SO = 4 , & SET_LJ = 8 , & SET_UP = 16 , & SET_DOWN = 32 , & SET_SPINAVE = 64 , & SET_SPINDIFF = 128 , & ! 2&#94;7 SET_USER1 = 256 , & ! 2&#94;8 SET_USER2 = 512 ! 2&#94;9 integer , parameter , public :: SET_ALL = 2 ** 10 - 1 public :: ps_destroy public :: str_of_set public :: setcode_of_string ! utility function, not for client normal use public :: destroy_local public :: destroy_nonlocal CONTAINS subroutine ps_destroy ( ps ) !! Cleans the ps object type ( ps_t ), intent ( inout ) :: ps integer :: i call ps_clean_annotation ( ps % annotation ) call destroy_provenance ( ps % provenance ) call ps_clean_annotation ( ps % config_val % annotation ) call destroy_xc ( ps % xc_info ) ! ! Note that freshly declared objects must have ! npots = 0 and npswfs = 0 ! ! call destroy_semilocal ( ps % semilocal ) call destroy_nonlocal ( ps % nonlocal ) ! call destroy_local ( ps % local ) ! do i = 1 , ps % pswfs % npswfs call destroy_radfunc ( ps % pswfs % Phi ( i )) enddo call delete ( ps % pswfs % grid ) call ps_clean_annotation ( ps % pswfs % annotation ) ! call destroy_radfunc ( ps % valence_charge % rho_val ) call ps_clean_annotation ( ps % valence_charge % annotation ) ! call destroy_radfunc ( ps % core_charge % rho_core ) call ps_clean_annotation ( ps % core_charge % annotation ) ! call delete ( ps % global_grid ) end subroutine ps_destroy subroutine destroy_provenance ( p ) type ( provenance_t ), pointer :: p type ( provenance_t ), pointer :: q do while ( associated ( p )) call ps_clean_annotation ( p % annotation ) ! clean buffers for input files? q => p % next deallocate ( p ) p => q enddo end subroutine destroy_provenance !================================================== subroutine destroy_semilocal ( p ) type ( semilocal_t ), pointer :: p type ( semilocal_t ), pointer :: q do while ( associated ( p )) call ps_clean_annotation ( p % annotation ) call destroy_slps ( p % pot ) call delete ( p % grid ) q => p % next deallocate ( p ) p => q enddo end subroutine destroy_semilocal ! subroutine destroy_slps ( p ) type ( slps_t ), pointer :: p type ( slps_t ), pointer :: q do while ( associated ( p )) call destroy_radfunc ( p % V ) q => p % next deallocate ( p ) p => q enddo end subroutine destroy_slps !================================================== subroutine destroy_local ( p ) type ( local_t ) :: p call ps_clean_annotation ( p % annotation ) call delete ( p % grid ) call destroy_radfunc ( p % vlocal ) call destroy_radfunc ( p % chlocal ) end subroutine destroy_local !================================================== subroutine destroy_nonlocal ( p ) type ( nonlocal_t ), pointer :: p type ( nonlocal_t ), pointer :: q do while ( associated ( p )) call ps_clean_annotation ( p % annotation ) call destroy_nlpj ( p % proj ) call delete ( p % grid ) q => p % next deallocate ( p ) p => q enddo end subroutine destroy_nonlocal ! subroutine destroy_nlpj ( p ) type ( nlpj_t ), pointer :: p type ( nlpj_t ), pointer :: q do while ( associated ( p )) call destroy_radfunc ( p % proj ) q => p % next deallocate ( p ) p => q enddo end subroutine destroy_nlpj ! !================================================== subroutine destroy_radfunc ( rp ) type ( radfunc_t ) :: rp call delete ( rp % grid ) if ( associated ( rp % data )) then deallocate ( rp % data ) rp % data => null () endif end subroutine destroy_radfunc ! subroutine destroy_xc ( xp ) type ( xc_t ), intent ( inout ) :: xp if ( allocated ( xp % libxc_name )) deallocate ( xp % libxc_name ) if ( allocated ( xp % libxc_type )) deallocate ( xp % libxc_type ) if ( allocated ( xp % libxc_id )) deallocate ( xp % libxc_id ) if ( allocated ( xp % libxc_weight )) deallocate ( xp % libxc_weight ) call ps_clean_annotation ( xp % annotation ) end subroutine destroy_xc function setcode_of_string ( str ) result ( code ) character ( len =* ), intent ( in ) :: str integer :: code select case ( trim ( str )) case ( \"non_relativistic\" ) code = SET_NONREL case ( \"scalar_relativistic\" ) code = SET_SREL case ( \"spin_orbit\" ) code = SET_SO case ( \"lj\" ) code = SET_LJ case ( \"spin_up\" ) code = SET_UP case ( \"spin_down\" ) code = SET_DOWN case ( \"spin_average\" ) code = SET_SPINAVE case ( \"spin_difference\" ) code = SET_SPINDIFF case ( \"user_extension1\" ) code = SET_USER1 case ( \"user_extension2\" ) code = SET_USER2 case ( \"all\" , \"any\" ) code = SET_ALL case ( \"invalid\" , \"INVALID\" ) code = SET_NULL case default call die ( \"Wrong set string: \" // trim ( str )) end select end function setcode_of_string function str_of_set ( code ) result ( str ) integer , intent ( in ) :: code character ( len = 20 ) :: str character ( len = 100 ) :: msg select case ( code ) case ( SET_NONREL ) str = \"non_relativistic\" case ( SET_SREL ) str = \"scalar_relativistic\" case ( SET_SO ) str = \"spin_orbit\" case ( SET_LJ ) str = \"lj\" case ( SET_UP ) str = \"spin_up\" case ( SET_DOWN ) str = \"spin_down\" case ( SET_SPINAVE ) str = \"spin_average\" case ( SET_SPINDIFF ) str = \"spin_difference\" case ( SET_USER1 ) str = \"user_extension1\" case ( SET_USER2 ) str = \"user_extension2\" case ( SET_ALL ) str = \"all\" case ( SET_NULL ) str = \"invalid\" case default write ( msg , \"(a,i4)\" ) \"Wrong set code: \" , code call die ( msg ) end select end function str_of_set end module m_psml_core","tags":"","loc":"sourcefile/m_psml_core.f90.html","title":"m_psml_core.f90 – libPSML"},{"text":"Modules m_psml_dump Source Code m_psml_dump.F90 Source Code !> Functions to handle PSML pseudopotential format structures !! !! (Dumpers) !> @author Alberto Garcia ! module m_psml_dump use m_psml_core ! For basic structures use assoc_list , only : ps_annotation_t => assoc_list_t !use assoc_list, only: EMPTY_ANNOTATION => EMPTY_ASSOC_LIST use class_grid , Grid_t => Grid use external_interfaces , only : die => psml_die implicit none integer , parameter :: dp = selected_real_kind ( 14 ) logical :: global_debug = . false . character ( len = 1 ), dimension ( 0 : 4 ) :: sym = ( / \"s\" , \"p\" , \"d\" , \"f\" , \"g\" / ) public :: ps_DumpToPSMLFile private CONTAINS !=============================================== subroutine ps_DumpToPSMLFile ( ps , fname , indent ) use xmlf90_wxml type ( ps_t ), intent ( in ) :: ps character ( len =* ), intent ( in ) :: fname logical , intent ( in ), optional :: indent type ( xmlf_t ) :: xf call xml_OpenFile ( trim ( fname ), xf , indent ) call xml_AddXMLDeclaration ( xf , \"UTF-8\" ) call xml_NewElement ( xf , \"psml\" ) call my_add_attribute ( xf , \"version\" , trim ( ps % version )) call my_add_attribute ( xf , \"energy_unit\" , trim ( ps % energy_unit )) call my_add_attribute ( xf , \"length_unit\" , trim ( ps % length_unit )) call my_add_attribute ( xf , \"uuid\" , ps % uuid ) call dump_annotation ( xf , ps % annotation ) call dump_provenance ( xf , ps % provenance ) call dump_header ( xf , ps ) if ( initialized ( ps % global_grid )) then call dump_grid ( xf , ps % global_grid ) endif call dump_semilocal_potentials ( xf , ps ) call dump_valence_charge ( xf , ps % valence_charge , ps % global_grid ) call dump_local_potential ( xf , ps ) call dump_nonlocal_projectors ( xf , ps ) call dump_pseudo_wavefunctions ( xf , ps ) if ( trim ( ps % header % core_corrections ) == \"yes\" ) then call dump_core_charge ( xf , ps % core_charge , ps % global_grid ) endif call xml_EndElement ( xf , \"psml\" ) call xml_Close ( xf ) end subroutine ps_DumpToPSMLFile subroutine dump_provenance ( xf , p ) use xmlf90_wxml use iso_varying_string , only : put , len , char type ( xmlf_t ), intent ( inout ) :: xf type ( provenance_t ), pointer :: p do while ( associated ( p )) call xml_NewElement ( xf , \"provenance\" ) call my_add_attribute ( xf , \"creator\" , trim ( p % creator )) call my_add_attribute ( xf , \"date\" , trim ( p % date )) if ( len ( p % input_file % buffer ) > 0 ) then call xml_NewElement ( xf , \"input-file\" ) call my_add_attribute ( xf , \"name\" , trim ( p % input_file % name )) call xml_AddCDataSection ( xf , char ( p % input_file % buffer ), & line_feed = . true .) call xml_EndElement ( xf , \"input-file\" ) endif call dump_annotation ( xf , p % annotation ) call xml_EndElement ( xf , \"provenance\" ) p => p % next end do end subroutine dump_provenance subroutine dump_xc_info ( xf , p ) use xmlf90_wxml type ( xmlf_t ), intent ( inout ) :: xf type ( xc_t ), intent ( in ) :: p integer :: i call xml_NewElement ( xf , \"exchange-correlation\" ) call dump_annotation ( xf , p % annotation ) call xml_NewElement ( xf , \"libxc-info\" ) call my_add_attribute ( xf , \"number-of-functionals\" , str ( p % n_functs_libxc )) do i = 1 , p % n_functs_libxc call xml_NewElement ( xf , \"functional\" ) call my_add_attribute ( xf , \"name\" , trim ( p % libxc_name ( i ))) if ( trim ( p % libxc_type ( i )) /= \"UNKNOWN\" ) then call my_add_attribute ( xf , \"type\" , trim ( p % libxc_type ( i ))) endif call my_add_attribute ( xf , \"id\" , str ( p % libxc_id ( i ))) if ( p % libxc_weight ( i ) /= 1.0_dp ) then call my_add_attribute ( xf , \"weight\" , str ( p % libxc_weight ( i ))) endif call xml_EndElement ( xf , \"functional\" ) enddo call xml_EndElement ( xf , \"libxc-info\" ) call xml_EndElement ( xf , \"exchange-correlation\" ) end subroutine dump_xc_info subroutine dump_config_val ( xf , p ) use xmlf90_wxml type ( xmlf_t ), intent ( inout ) :: xf type ( config_val_t ), intent ( in ) :: p integer :: i call xml_NewElement ( xf , \"valence-configuration\" ) call my_add_attribute ( xf , \"total-valence-charge\" , str ( p % total_charge )) do i = 1 , p % nshells call xml_NewElement ( xf , \"shell\" ) call my_add_attribute ( xf , \"n\" , str ( p % n ( i ))) call my_add_attribute ( xf , \"l\" , p % l ( i )) call my_add_attribute ( xf , \"occupation\" , str ( p % occ ( i ))) if (( p % occ_up ( i ) + p % occ_down ( i )) /= 0.0_dp ) then call my_add_attribute ( xf , \"occupation-down\" , str ( p % occ_down ( i ))) call my_add_attribute ( xf , \"occupation-up\" , str ( p % occ_up ( i ))) endif call xml_EndElement ( xf , \"shell\" ) enddo call dump_annotation ( xf , p % annotation ) call xml_EndElement ( xf , \"valence-configuration\" ) end subroutine dump_config_val subroutine dump_header ( xf , ps ) use xmlf90_wxml type ( xmlf_t ), intent ( inout ) :: xf type ( ps_t ), intent ( in ), target :: ps type ( header_t ), pointer :: h h => ps % header call xml_NewElement ( xf , \"header\" ) call my_add_attribute ( xf , \"atomic-label\" , trim ( h % atomic_label )) call my_add_attribute ( xf , \"z-pseudo\" , str ( h % zpseudo )) call my_add_attribute ( xf , \"atomic-number\" , str ( h % z )) call my_add_attribute ( xf , \"flavor\" , trim ( h % flavor )) call my_add_attribute ( xf , \"relativity\" , trim ( h % relativity )) if ( h % polarized ) then call my_add_attribute ( xf , \"polarized\" , \"yes\" ) else call my_add_attribute ( xf , \"polarized\" , \"no\" ) endif call my_add_attribute ( xf , \"core-corrections\" , trim ( h % core_corrections )) call dump_xc_info ( xf , ps % xc_info ) call dump_config_val ( xf , ps % config_val ) call xml_EndElement ( xf , \"header\" ) end subroutine dump_header subroutine dump_radfunc ( xf , rf , parent_grid ) use xmlf90_wxml type ( xmlf_t ), intent ( inout ) :: xf type ( radfunc_t ), intent ( in ) :: rf type ( Grid_t ) :: parent_grid ! Only one level for now if (. not . initialized ( rf % grid )) return call xml_NewElement ( xf , \"radfunc\" ) if ( same ( rf % grid , parent_grid )) then ! do nothing else call dump_grid ( xf , rf % grid ) endif call xml_NewElement ( xf , \"data\" ) call xml_AddArray ( xf , rf % data (:)) call xml_EndElement ( xf , \"data\" ) call xml_EndElement ( xf , \"radfunc\" ) end subroutine dump_radfunc subroutine dump_valence_charge ( xf , val , parent_grid ) use xmlf90_wxml type ( xmlf_t ), intent ( inout ) :: xf type ( valence_charge_t ), intent ( in ) :: val type ( Grid_t ) :: parent_grid call xml_NewElement ( xf , \"valence-charge\" ) call my_add_attribute ( xf , \"total-charge\" , str ( val % total_charge )) call dump_annotation ( xf , val % annotation ) call dump_radfunc ( xf , val % rho_val , parent_grid ) call xml_EndElement ( xf , \"valence-charge\" ) end subroutine dump_valence_charge subroutine dump_core_charge ( xf , core , parent_grid ) use xmlf90_wxml type ( xmlf_t ), intent ( inout ) :: xf type ( core_charge_t ), intent ( in ) :: core type ( Grid_t ) :: parent_grid call xml_NewElement ( xf , \"pseudocore-charge\" ) call my_add_attribute ( xf , \"matching-radius\" , str ( core % rcore )) call my_add_attribute ( xf , \"number-of-continuous-derivatives\" , str ( core % n_cont_derivs )) call dump_annotation ( xf , core % annotation ) call dump_radfunc ( xf , core % rho_core , parent_grid ) call xml_EndElement ( xf , \"pseudocore-charge\" ) end subroutine dump_core_charge ! subroutine dump_semilocal_potentials ( xf , ps ) use xmlf90_wxml type ( xmlf_t ), intent ( inout ) :: xf type ( ps_t ), intent ( in ), target :: ps type ( semilocal_t ), pointer :: slp type ( slps_t ), pointer :: slvp type ( Grid_t ) :: parent_grid integer :: i , j , set slp => ps % semilocal do while ( associated ( slp )) set = slp % set call xml_NewElement ( xf , \"semilocal-potentials\" ) if ( set /= SET_NULL ) then ! Group set was specified call my_add_attribute ( xf , \"set\" , str_of_set ( set )) endif call dump_annotation ( xf , slp % annotation ) if ( initialized ( slp % grid )) then parent_grid = slp % grid call dump_grid ( xf , slp % grid ) else parent_grid = ps % global_grid endif slvp => slp % pot do while ( associated ( slvp )) call xml_NewElement ( xf , \"slps\" ) call my_add_attribute ( xf , \"n\" , str ( slvp % n )) call my_add_attribute ( xf , \"l\" , slvp % l ) call my_add_attribute ( xf , \"rc\" , str ( slvp % rc )) call my_add_attribute ( xf , \"flavor\" , slvp % flavor ) if ( set == SET_LJ ) then call my_add_attribute ( xf , \"j\" , str ( slvp % j )) endif ! Group set was not specified if ( set == SET_NULL ) then call my_add_attribute ( xf , \"set\" , str_of_set ( slvp % set )) endif call dump_radfunc ( xf , slvp % V , parent_grid ) call xml_EndElement ( xf , \"slps\" ) slvp => slvp % next enddo call xml_EndElement ( xf , \"semilocal-potentials\" ) slp => slp % next enddo call delete ( parent_grid ) end subroutine dump_semilocal_potentials subroutine dump_local_potential ( xf , ps ) use xmlf90_wxml type ( xmlf_t ), intent ( inout ) :: xf type ( ps_t ), intent ( in ), target :: ps type ( local_t ), pointer :: lop logical :: has_vlocal lop => ps % local has_vlocal = associated ( lop % Vlocal % data ) if ( has_vlocal ) then call xml_NewElement ( xf , \"local-potential\" ) call my_add_attribute ( xf , \"type\" , lop % vlocal_type ) ! No processing of grids here call dump_radfunc ( xf , lop % Vlocal , ps % global_grid ) call dump_radfunc ( xf , lop % chlocal , ps % global_grid ) call xml_EndElement ( xf , \"local-potential\" ) endif end subroutine dump_local_potential !---------------------------------------------------------- subroutine dump_nonlocal_projectors ( xf , ps ) use xmlf90_wxml type ( xmlf_t ), intent ( inout ) :: xf type ( ps_t ), intent ( in ), target :: ps type ( nonlocal_t ), pointer :: nlp type ( nlpj_t ), pointer :: nlpp type ( Grid_t ) :: parent_grid integer :: set nlp => ps % nonlocal do while ( associated ( nlp )) set = nlp % set call xml_NewElement ( xf , \"nonlocal-projectors\" ) if ( set /= SET_NULL ) then ! Group set was specified call my_add_attribute ( xf , \"set\" , str_of_set ( set )) endif call dump_annotation ( xf , nlp % annotation ) if ( initialized ( nlp % grid )) then parent_grid = nlp % grid call dump_grid ( xf , nlp % grid ) else parent_grid = ps % global_grid endif nlpp => nlp % proj do while ( associated ( nlpp )) call xml_NewElement ( xf , \"proj\" ) call my_add_attribute ( xf , \"l\" , nlpp % l ) if ( set == SET_LJ ) then call my_add_attribute ( xf , \"j\" , str ( nlpp % j )) endif call my_add_attribute ( xf , \"seq\" , str ( nlpp % seq )) call my_add_attribute ( xf , \"ekb\" , str ( nlpp % ekb )) call my_add_attribute ( xf , \"type\" , nlpp % type ) ! Group set was not specified if ( set == SET_NULL ) then call my_add_attribute ( xf , \"set\" , str_of_set ( nlpp % set )) endif call dump_radfunc ( xf , nlpp % proj , parent_grid ) call xml_EndElement ( xf , \"proj\" ) nlpp => nlpp % next enddo call xml_EndElement ( xf , \"nonlocal-projectors\" ) nlp => nlp % next enddo call delete ( parent_grid ) end subroutine dump_nonlocal_projectors !---------------------------------------------------------- subroutine dump_pseudo_wavefunctions ( xf , ps ) use xmlf90_wxml use sets_m type ( xmlf_t ), intent ( inout ) :: xf type ( ps_t ), intent ( in ), target :: ps type ( pswfs_t ), pointer :: wfp type ( Grid_t ) :: parent_grid type ( set_info_t ) :: set_info integer :: i , j , set , n_grid integer , allocatable :: idx (:) wfp => ps % pswfs call sort_sets ( wfp % npswfs , wfp % set , set_info ) do j = 1 , nsets ( set_info ) call set_indexes ( set_info , j , idx ) set = set_id ( set_info , j ) call xml_NewElement ( xf , \"pseudo-wave-functions\" ) call my_add_attribute ( xf , \"set\" , str_of_set ( set )) ! ! Check grids and decide whether to include a <grid> element ! First, check whether any wfn is not using the global grid. ! If all the wfns are in that case, assume that a mid-level grid was ! specified, dump a grid in a new <grid> element, and pass it ! to the radfunc dumper. In the worst case scenario, we will ! have chosen a truly \"radfunc-private\" grid and there would be ! some replication of data. To avoid this, one would need to ! classify the grids. Maybe in a new version. ! parent_grid = ps % global_grid n_grid = 0 do i = 1 , size ( idx ) if (. not . same ( wfp % Phi ( idx ( i ))% grid , ps % global_grid )) then n_grid = n_grid + 1 endif enddo if ( n_grid == size ( idx )) then call dump_grid ( xf , wfp % Phi ( idx ( 1 ))% grid ) parent_grid = wfp % Phi ( idx ( 1 ))% grid endif do i = 1 , size ( idx ) call xml_NewElement ( xf , \"pswf\" ) call my_add_attribute ( xf , \"n\" , str ( wfp % n ( idx ( i )))) call my_add_attribute ( xf , \"l\" , wfp % l ( idx ( i ))) if ( set == SET_LJ ) then call my_add_attribute ( xf , \"j\" , str ( wfp % j ( idx ( i )))) endif call dump_radfunc ( xf , wfp % Phi ( idx ( i )), parent_grid ) call xml_EndElement ( xf , \"pswf\" ) enddo call xml_EndElement ( xf , \"pseudo-wave-functions\" ) enddo call delete ( parent_grid ) end subroutine dump_pseudo_wavefunctions subroutine dump_grid ( xf , agrid ) use xmlf90_wxml type ( xmlf_t ), intent ( inout ) :: xf type ( Grid_t ), intent ( in ) :: agrid if (. not . initialized ( agrid )) return call xml_NewElement ( xf , \"grid\" ) call my_add_attribute ( xf , \"npts\" , str ( sizeGrid ( agrid ))) call dump_annotation ( xf , annotationGrid ( agrid )) call xml_NewElement ( xf , \"grid-data\" ) call xml_AddArray ( xf , valGrid ( agrid )) call xml_EndElement ( xf , \"grid-data\" ) call xml_EndElement ( xf , \"grid\" ) end subroutine dump_grid subroutine dump_annotation ( xf , annotation ) use xmlf90_wxml use assoc_list , only : ps_annotation_t => assoc_list_t use assoc_list , only : nitems_annotation => assoc_list_nitems use assoc_list , only : get_annotation_key => assoc_list_get_key use assoc_list , only : get_annotation_value => assoc_list_get_value type ( xmlf_t ), intent ( inout ) :: xf type ( ps_annotation_t ), intent ( in ) :: annotation integer :: n_items , i , stat character ( len = 256 ) :: key , val n_items = nitems_annotation ( annotation ) if ( n_items > 0 ) then call xml_NewElement ( xf , \"annotation\" ) do i = 1 , n_items call get_annotation_key ( annotation , i , key , stat ) call get_annotation_value ( annotation , i , val , stat ) call my_add_attribute ( xf , trim ( key ), trim ( val )) enddo call xml_EndElement ( xf , \"annotation\" ) endif end subroutine dump_annotation subroutine my_add_attribute ( xf , name , value ) use xmlf90_wxml type ( xmlf_t ), intent ( inout ) :: xf character ( len =* ), intent ( in ) :: name character ( len =* ), intent ( in ) :: value call xml_AddAttribute ( xf , name , trim ( value )) end subroutine my_add_attribute end module m_psml_dump","tags":"","loc":"sourcefile/m_psml_dump.f90.html","title":"m_psml_dump.F90 – libPSML"},{"text":"Modules m_psml_parsing_helpers Source Code m_psml_parsing_helpers.F90 Source Code module m_psml_parsing_helpers ! !  This module reads a pseudopotential file written in the PSML format !  A full example of the building up of a data structure using !  the SAX paradigm. ! use m_psml_core ! For data types and basic utilities use external_interfaces , only : die => psml_die use class_Grid use assoc_list , only : ps_annotation_t => assoc_list_t implicit none private ! ! It defines the routines that are called from xml_parser in response ! to particular events. ! public :: begin_element , end_element , pcdata_chunk public :: cdata_section_chunk ! ! The data will be stored in this public variable ! There are some design issues to decide: ! -- Should this be a pointer, associated by the client !    program to its own variable? In that case, the !    client should make sure that the variable is \"clean\" !    before calling this routine, as some fields will be !    allocated here. ! -- Perhaps it should be a pointer allocated here (and !    then destroyed when done by the client). It should be !    allocated at the beginning of processing, maybe detected !    with a (default) \"begin_Document\" handler, or by !    \"begin_Element\" after checking for association. !    This is the cleanest option, as the caller might want !    to keep several instances alive at the same time... !    (... but this should be handled by the user) ! -- If \"pseudo\" here is a normal variable, it should also !    be \"cleaned\" before the next use. The current usage !    in Abinit falls in this category: psxml is a pointer !    associated to \"pseudo\", and cleaned after use. ! !    We implement the first option now type ( ps_t ), pointer , public , save :: pseudo => null () logical , public , save :: debug_parsing = . false . logical , private , save :: in_psml = . false . logical , private , save :: in_slps = . false . , in_radfunc = . false . logical , private , save :: in_semilocal = . false . , in_header = . false . logical , private , save :: in_coreCharge = . false . , in_data = . false . logical , private , save :: in_grid_data = . false . , in_grid = . false . logical , private , save :: in_valenceCharge = . false . logical , private , save :: in_provenance = . false ., in_input_file = . false . logical , private , save :: in_valence_config = . false . logical , private , save :: in_xc = . false ., in_libxc_info = . false . logical , private , save :: in_pseudowavefun = . false . , in_pswf = . false . logical , private , save :: in_chlocal = . false ., in_nonlocal = . false . logical , private , save :: in_proj = . false . , in_local_potential = . false . logical , private , save :: got_explicit_grid_data integer , private , save :: ndata , ndata_grid integer , private , save :: n_funct character ( len = 20 ), private , save :: current_wf_set character ( len = 20 ), private , save :: current_sl_set character ( len = 20 ), private , save :: current_proj_set character ( len = 40 ), private , save :: top_flavor integer , parameter , private :: dp = selected_real_kind ( 14 ) real ( dp ), private , save :: zval_generation type ( Grid ), private , save :: tmp_grid real ( dp ), private , save , pointer :: gdata (:) => null () type ( ps_annotation_t ), private , save , pointer :: gannot => null () ! ! Pointers to make it easier to manage the data ! type ( provenance_t ), private , pointer :: pp => null () type ( provenance_t ), private , pointer :: qp => null () type ( input_file_t ), private , pointer :: ifp => null () type ( header_t ), private , pointer :: hp => null () type ( config_val_t ), private , pointer :: cp => null () type ( xc_t ), private , pointer :: xp => null () type ( pswfs_t ), private , pointer :: wfp => null () type ( semilocal_t ), private , pointer :: slp => null () type ( semilocal_t ), private , pointer :: qslp => null () type ( slps_t ), private , pointer :: slvp => null () type ( slps_t ), private , pointer :: qslvp => null () type ( local_t ), private , pointer :: lop => null () type ( nonlocal_t ), private , pointer :: nlp => null () type ( nonlocal_t ), private , pointer :: qnlp => null () type ( nlpj_t ), private , pointer :: nlpp => null () type ( nlpj_t ), private , pointer :: qnlpp => null () type ( valence_charge_t ), private , pointer :: valp => null () type ( core_charge_t ), private , pointer :: corep => null () type ( radfunc_t ), private , pointer :: rp => null () character ( len = 100 ), private , save :: parent_element = \"\" CONTAINS !=========================================================== !---------------------------------------------------------------------- #ifndef PSML_USE_FOX subroutine begin_element ( name , attributes ) use xmlf90_sax , only : dictionary_t , get_value #else subroutine begin_element ( namespaceURI , localName , name , attributes ) use Fox_sax , only : dictionary_t use fox_extra , only : get_value => get_value_by_key character ( len =* ), intent ( in ) :: namespaceURI character ( len =* ), intent ( in ) :: localName #endif character ( len =* ), intent ( in ) :: name type ( dictionary_t ), intent ( in ) :: attributes character ( len = 100 ) :: value , msg real :: version_number integer :: status integer :: i , npts if ( debug_parsing ) print * , \"Element: \" , trim ( name ) select case ( name ) case ( \"psml\" ) in_psml = . true . ! Make sure that pseudo is pointing to something if (. not . associated ( pseudo )) then call die ( \"ps_t object not initialized by client\" ) endif call get_value ( attributes , \"version\" , value , status ) if ( status /= 0 ) call die ( \"No psml version\" ) read ( value , fmt =* ) version_number if ( ( version_number < PSML_TARGET_VERSION_LO ) . or . & ( version_number > PSML_TARGET_VERSION_HI )) then write ( msg , \"('[',f4.2,',',f4.2,']')\" ) & PSML_TARGET_VERSION_LO , & PSML_TARGET_VERSION_HI call die ( \"This version of the library can \" // & \"process PSML files with version in \" // trim ( msg )) endif pseudo % version = value call get_value ( attributes , \"energy_unit\" , pseudo % energy_unit , status ) if ( status /= 0 ) call die ( \"No energy unit\" ) call get_value ( attributes , \"length_unit\" , pseudo % length_unit , status ) if ( status /= 0 ) call die ( \"No length unit\" ) call get_value ( attributes , \"uuid\" , pseudo % uuid , status ) if ( status /= 0 ) pseudo % uuid = \"no-uuid-specified\" ! Initialize counters pseudo % pswfs % npswfs = 0 case ( \"provenance\" ) in_provenance = . true . ! This will gather all element provenances at the top level allocate ( pp ) if ( associated ( pseudo % provenance )) then qp => pseudo % provenance do while ( associated ( qp % next )) qp => qp % next enddo qp % next => pp else pseudo % provenance => pp endif call get_value ( attributes , \"creator\" , pp % creator , status ) if ( status /= 0 ) pp % creator = \"unknown\" call get_value ( attributes , \"date\" , pp % date , status ) if ( status /= 0 ) pp % date = \"unknown\" case ( \"input-file\" ) if (. not . in_provenance ) call die ( \"<input-file> outside <provenance>\" ) in_input_file = . true . ifp => pp % input_file call get_value ( attributes , \"name\" , ifp % name , status ) if ( status /= 0 ) ifp % name = \"unknown\" case ( \"header\" ) in_header = . true . hp => pseudo % header call get_value ( attributes , \"atomic-label\" , hp % atomic_label , status ) if ( status /= 0 ) call die ( \"Cannot determine atomic-label\" ) call get_value ( attributes , \"z-pseudo\" , value , status ) if ( status /= 0 ) call die ( \"Cannot determine z-pseudo\" ) read ( unit = value , fmt =* ) hp % zpseudo call get_value ( attributes , \"atomic-number\" , value , status ) if ( status /= 0 ) call die ( \"Cannot determine atomic number\" ) read ( unit = value , fmt =* ) hp % z call get_value ( attributes , \"flavor\" , hp % flavor , status ) if ( status /= 0 ) hp % flavor = \"not-unique\" call get_value ( attributes , \"relativity\" , hp % relativity , status ) if ( status /= 0 ) call die ( \"Cannot determine relativity scheme\" ) call get_value ( attributes , \"polarized\" , value , status ) if ( status /= 0 ) value = \"no\" hp % polarized = ( value == \"yes\" ) if ( hp % polarized . and . trim ( hp % relativity ) == \"dirac\" ) then call die ( \"Cannot be polarized and fully relativistic at the same time\" ) endif call get_value ( attributes , \"core-corrections\" , & hp % core_corrections , status ) if ( status /= 0 ) hp % core_corrections = \"no\" case ( \"exchange-correlation\" ) in_xc = . true . xp => pseudo % xc_info case ( \"libxc-info\" ) if (. not . in_xc ) call die ( \"Orphan <libxc-info>\" ) in_libxc_info = . true . call get_value ( attributes , \"number-of-functionals\" , & value , status ) if ( status /= 0 ) call die ( \"Error reading number of libxc functs\" ) read ( unit = value , fmt =* ) xp % n_functs_libxc n_funct = xp % n_functs_libxc allocate ( xp % libxc_name ( n_funct ), xp % libxc_id ( n_funct )) allocate ( xp % libxc_weight ( n_funct ), xp % libxc_type ( n_funct )) xp % libxc_weight ( 1 : n_funct ) = 1.0_dp xp % libxc_type ( 1 : n_funct ) = \"UNKNOWN\" n_funct = 0 ! for checking the counting on the fly case ( \"functional\" ) if (. not . in_libxc_info ) call die ( \"Orphan <functional>\" ) n_funct = n_funct + 1 if ( n_funct > xp % n_functs_libxc ) & call die ( \"Too many <functional> elements in <libxc-info>\" ) call get_value ( attributes , \"name\" , & xp % libxc_name ( n_funct ), status ) if ( status /= 0 ) call die ( \"Error reading libxc name\" ) call get_value ( attributes , \"id\" , value , status ) if ( status /= 0 ) call die ( \"Error reading libxc id\" ) read ( unit = value , fmt =* ) xp % libxc_id ( n_funct ) ! optional attribute(s) call get_value ( attributes , \"weight\" , value , status ) if ( status == 0 ) then read ( unit = value , fmt =* ) xp % libxc_weight ( n_funct ) endif call get_value ( attributes , \"type\" , value , status ) if ( status == 0 ) then xp % libxc_type ( n_funct ) = trim ( value ) endif case ( \"valence-configuration\" ) in_valence_config = . true . pseudo % config_val % nshells = 0 pseudo % config_val % occ_up (:) = 0.0_dp pseudo % config_val % occ_down (:) = 0.0_dp pseudo % config_val % occ (:) = 0.0_dp call get_value ( attributes , \"total-valence-charge\" , value , status ) if ( status /= 0 ) call die ( \"Cannot determine total-valence-charge\" ) read ( unit = value , fmt =* ) pseudo % config_val % total_charge case ( \"shell\" ) if ( in_valence_config ) then cp => pseudo % config_val !         else if (in_core_config) then !            cp => pseudo%config_core else call die ( \"Orphan <shell> element\" ) endif cp % nshells = cp % nshells + 1 call get_value ( attributes , \"l\" , cp % l ( cp % nshells ), status ) if ( status /= 0 ) call die ( \"Cannot determine l for shell\" ) call get_value ( attributes , \"n\" , value , status ) if ( status /= 0 ) call die ( \"Cannot determine n for shell\" ) read ( unit = value , fmt =* ) cp % n ( cp % nshells ) call get_value ( attributes , \"occupation\" , value , status ) if ( status /= 0 ) call die ( \"Cannot determine occupation for shell\" ) read ( unit = value , fmt =* ) cp % occ ( cp % nshells ) call get_value ( attributes , \"occupation-up\" , value , status ) if ( status == 0 ) then read ( unit = value , fmt =* ) cp % occ_up ( cp % nshells ) endif call get_value ( attributes , \"occupation-down\" , value , status ) if ( status == 0 ) then read ( unit = value , fmt =* ) cp % occ_down ( cp % nshells ) endif case ( \"slps\" ) in_slps = . true . if (. not . in_semilocal ) call die ( \"Orphan <slps> element\" ) allocate ( slvp ) ! Append to end of list  !! call append(slp%pot,slvp) if ( associated ( slp % pot )) then qslvp => slp % pot do while ( associated ( qslvp % next )) qslvp => qslvp % next enddo qslvp % next => slvp else !First link slp % pot => slvp endif rp => slvp % V slvp % parent_group => slp ! current semilocal-potentials element call get_value ( attributes , \"set\" , value , status ) if ( status /= 0 ) then value = current_sl_set endif slvp % set = setcode_of_string ( value ) call get_value ( attributes , \"l\" , slvp % l , status ) if ( status /= 0 ) call die ( \"Cannot determine l for SL potential\" ) call get_value ( attributes , \"n\" , value , status ) if ( status /= 0 ) call die ( \"Cannot determine n for SL potential\" ) read ( unit = value , fmt =* ) slvp % n call get_value ( attributes , \"rc\" , value , status ) if ( status /= 0 ) call die ( \"Cannot determine rc for SL potential\" ) read ( unit = value , fmt =* ) slvp % rc call get_value ( attributes , \"j\" , value , status ) if ( status /= 0 ) then if ( slvp % set == SET_LJ ) & call die ( \"Cannot determine j for SLPS in set \" // str_of_set ( SET_LJ )) else read ( unit = value , fmt =* ) slvp % j endif call get_value ( attributes , \"flavor\" , slvp % flavor , status ) if ( status /= 0 ) then slvp % flavor = top_flavor endif case ( \"proj\" ) in_proj = . true . if (. not . in_nonlocal ) call die ( \"Orphan <proj> element\" ) allocate ( nlpp ) ! Append to end of list  !! call append(nlp%proj,nlpp) if ( associated ( nlp % proj )) then qnlpp => nlp % proj do while ( associated ( qnlpp % next )) qnlpp => qnlpp % next enddo qnlpp % next => nlpp else !First link nlp % proj => nlpp endif rp => nlpp % proj nlpp % parent_group => nlp ! current nonlocal-projectors element call get_value ( attributes , \"set\" , value , status ) if ( status /= 0 ) then value = current_proj_set endif nlpp % set = setcode_of_string ( value ) call get_value ( attributes , \"l\" , nlpp % l , status ) if ( status /= 0 ) call die ( \"Cannot determine l for proj\" ) call get_value ( attributes , \"seq\" , value , status ) if ( status /= 0 ) call die ( \"Cannot determine seq number for proj\" ) read ( unit = value , fmt =* ) nlpp % seq call get_value ( attributes , \"ekb\" , value , status ) if ( status /= 0 ) call die ( \"Cannot determine Ekb for proj\" ) read ( unit = value , fmt =* ) nlpp % ekb call get_value ( attributes , \"j\" , value , status ) if ( status /= 0 ) then if ( nlpp % set == SET_LJ ) & call die ( \"Cannot determine j for Proj in set \" // str_of_set ( SET_LJ )) else read ( unit = value , fmt =* ) nlpp % j endif call get_value ( attributes , \"type\" , nlpp % type , status ) if ( status /= 0 ) call die ( \"Cannot determine type of proj\" ) case ( \"pswf\" ) if (. not . in_pseudowavefun ) call die ( \"Orphan <pswf> element\" ) in_pswf = . true . wfp => pseudo % pswfs wfp % npswfs = wfp % npswfs + 1 i = wfp % npswfs rp => wfp % Phi ( i ) call get_value ( attributes , \"set\" , value , status ) if ( status /= 0 ) then value = current_wf_set endif wfp % set ( i ) = setcode_of_string ( value ) call get_value ( attributes , \"l\" , wfp % l ( i ), status ) if ( status /= 0 ) call die ( \"Cannot determine l for PSwf\" ) call get_value ( attributes , \"n\" , value , status ) if ( status /= 0 ) call die ( \"Cannot determine n for PSwf\" ) read ( unit = value , fmt =* ) wfp % n ( i ) call get_value ( attributes , \"j\" , value , status ) if ( status /= 0 ) then if ( wfp % set ( i ) == SET_LJ ) & call die ( \"Cannot determine j for PSwf in set \" // str_of_set ( SET_LJ )) else read ( unit = value , fmt =* ) wfp % j ( i ) endif case ( \"grid\" ) in_grid = . true . got_explicit_grid_data = . false . ! This attribute is mandatory call get_value ( attributes , \"npts\" , value , status ) if ( status /= 0 ) call die ( \"Cannot determine grid npts\" ) read ( unit = value , fmt =* ) npts if ( npts == 0 ) call die ( \"Grid size not specified correctly\" ) ! Create working object and associate inner sections ! while the parsing is active call newGrid ( tmp_grid , npts ) gdata => valGrid ( tmp_grid ) gannot => annotationGrid ( tmp_grid ) ! ! In this way we allow for a private grid for each radfunc, ! or for a global grid specification ! if ( in_radfunc ) then if ( debug_parsing ) print * , \"Found grid in radfunc\" if ( initialized ( rp % grid )) then call die ( \"psml: Two grids specified for a radfunc\" ) endif rp % grid = tmp_grid ! We check whether we are at the top level, ! or at an intermediate grouping level that allows a grid else if ( in_nonlocal ) then if ( initialized ( nlp % grid )) then call die ( \"psml: Two grids in same nonlocal block\" ) endif if ( debug_parsing ) print * , \"Found nonlocal grid\" nlp % grid = tmp_grid else if ( in_local_potential ) then if ( initialized ( lop % grid )) then call die ( \"psml: Two grids in same local block\" ) endif if ( debug_parsing ) print * , \"Found local grid\" lop % grid = tmp_grid else if ( in_semilocal ) then if ( initialized ( slp % grid )) then call die ( \"psml: Two grids in same semilocal block\" ) endif if ( debug_parsing ) print * , \"Found semilocal grid\" slp % grid = tmp_grid else if ( in_pseudowavefun ) then if ( initialized ( wfp % grid )) then !call die(\"psml: Two pseudo-wavefunction grids specified\") endif if ( debug_parsing ) print * , \"Found pseudo-wavefunction grid\" wfp % grid = tmp_grid else ! We are at the top level if ( debug_parsing ) print * , \"Found grid at the top level\" if ( initialized ( pseudo % global_grid )) then ! Maybe allow this in the future call die ( \"psml: Two global grids specified\" ) endif pseudo % global_grid = tmp_grid endif case ( \"data\" ) if (. not . in_radfunc ) then call die ( \"<data> element outside <rad_func> element\" ) endif in_data = . true . ! The following blocks are a bit more verbose than needed since ! the Intel compiler seems to be trying to evaluate all the ! clauses joined by an .and. operator, instead of stopping if ! the first clause is .false. if (. not . initialized ( rp % grid )) then ! Try regional grids first if ( in_nonlocal ) then if ( initialized ( nlp % grid )) then rp % grid = nlp % grid if ( debug_parsing ) print * , \"Associated proj grid with nl parent grid\" endif else if ( in_local_potential ) then if ( initialized ( lop % grid )) then rp % grid = lop % grid if ( debug_parsing ) print * , \"Associated grid with vlocal parent grid\" endif else if ( in_semilocal ) then if ( initialized ( slp % grid )) then rp % grid = slp % grid if ( debug_parsing ) print * , \"Associated slps grid with sl parent grid\" endif else if ( in_pseudowavefun ) then if ( initialized ( wfp % grid )) then rp % grid = wfp % grid endif endif endif ! If the parent block does not include a grid, try the global grid if (. not . initialized ( rp % grid )) then if ( initialized ( pseudo % global_grid )) then rp % grid = pseudo % global_grid if ( debug_parsing ) print * , \"Associated grid with global grid\" endif endif ! Now give up if (. not . initialized ( rp % grid )) call die ( \"Cannot find grid data for radfunc\" ) allocate ( rp % data ( sizeGrid ( rp % grid ))) ndata = 0 ! To start the build up case ( \"grid-data\" ) if (. not . in_grid ) call die ( \"Grid_data element outside grid element\" ) in_grid_data = . true . got_explicit_grid_data = . true . if ( size ( gdata ) == 0 ) call die ( \"Grid npts attribute faulty\" ) ndata_grid = 0 ! To start the build up case ( \"radfunc\" ) ! We need to make sure that a radfunc is allowed at this level ! ! For example, if an old-style file with <vps> is used, the finding ! of a <vps> element will not increase npots, and there will be a ! segmentation fault when trying to store the data in the rp pointer, ! which would be non-associated if the vps section is the first ! case of radfuncs in the file ! ! Actually, it gets worse: if there is a <core-charge> element ! before the old-style <vps> section, the rp pointer used for ! core-charge will be reused and assigned the data for the first ! and subsequent vps elements. ! if ( in_slps . or . in_coreCharge . or . in_valenceCharge & . or . in_pswf . or . in_proj . or . in_local_potential & . or . in_chlocal ) then in_radfunc = . true . else call die ( \"<radfunc> element found under unallowed <\" // & trim ( parent_element ) // \">\" ) endif case ( \"pseudocore-charge\" ) in_coreCharge = . true . corep => pseudo % core_charge rp => corep % rho_core call get_value ( attributes , \"matching-radius\" , value , status ) if ( status == 0 ) then read ( unit = value , fmt =* ) corep % rcore else corep % rcore = - 1.0_dp endif call get_value ( attributes , \"number-of-continuous-derivatives\" , & value , status ) if ( status == 0 ) then read ( unit = value , fmt =* ) corep % n_cont_derivs else corep % n_cont_derivs = - 1 endif case ( \"valence-charge\" ) in_valenceCharge = . true . valp => pseudo % valence_charge rp => valp % rho_val call get_value ( attributes , \"total-charge\" , value , status ) if ( status /= 0 ) call die ( \"Cannot determine total valence charge\" ) read ( unit = value , fmt =* ) valp % total_charge case ( \"semilocal-potentials\" ) in_semilocal = . true . allocate ( slp ) if ( associated ( pseudo % semilocal )) then qslp => pseudo % semilocal do while ( associated ( qslp % next )) qslp => qslp % next enddo qslp % next => slp else pseudo % semilocal => slp endif current_sl_set = \"invalid\" slp % set = SET_NULL call get_value ( attributes , \"set\" , value , status ) if ( status == 0 ) then current_sl_set = value slp % set = setcode_of_string ( value ) endif if ( debug_parsing ) print * , \"Found semilocal-potentials set: \" , trim ( current_sl_set ) top_flavor = pseudo % header % flavor call get_value ( attributes , \"flavor\" , value , status ) if ( status == 0 ) then top_flavor = value endif case ( \"nonlocal-projectors\" ) in_nonlocal = . true . ! Allocate new node and add to the end of the linked list allocate ( nlp ) if ( associated ( pseudo % nonlocal )) then qnlp => pseudo % nonlocal do while ( associated ( qnlp % next )) qnlp => qnlp % next enddo qnlp % next => nlp else pseudo % nonlocal => nlp endif current_proj_set = \"invalid\" nlp % set = SET_NULL call get_value ( attributes , \"set\" , value , status ) if ( status == 0 ) then current_proj_set = value nlp % set = setcode_of_string ( value ) endif if ( debug_parsing ) print * , \"Found nonlocal-projectors set: \" , trim ( current_proj_set ) nlp % set = setcode_of_string ( value ) case ( \"local-potential\" ) in_local_potential = . true . lop => pseudo % local rp => lop % vlocal call get_value ( attributes , \"type\" , lop % vlocal_type , status ) if ( status /= 0 ) call die ( \"Cannot determine type of local potential\" ) case ( \"local-charge\" ) if (. not . in_local_potential ) call die ( \"<local-charge> outside <local-potential>\" ) in_chlocal = . true . lop => pseudo % local rp => lop % chlocal ! Future expansion: chlocal attributes case ( \"pseudo-wave-functions\" ) in_pseudowavefun = . true . wfp => pseudo % pswfs current_wf_set = \"invalid\" wfp % set = SET_NULL call get_value ( attributes , \"set\" , value , status ) if ( status == 0 ) then current_wf_set = value wfp % set = setcode_of_string ( value ) endif if ( debug_parsing ) print * , \"Found pseudo-wavefunction set: \" , trim ( current_wf_set ) case ( \"annotation\" ) if ( in_provenance ) then call save_annotation ( attributes , pp % annotation ) else if ( in_grid ) then call save_annotation ( attributes , gannot ) else if ( in_xc ) then call save_annotation ( attributes , xp % annotation ) else if ( in_valence_config ) then call save_annotation ( attributes , cp % annotation ) else if ( in_semilocal ) then call save_annotation ( attributes , slp % annotation ) else if ( in_nonlocal ) then call save_annotation ( attributes , nlp % annotation ) else if ( in_local_potential ) then call save_annotation ( attributes , lop % annotation ) else if ( in_pseudowavefun ) then call save_annotation ( attributes , wfp % annotation ) else if ( in_valenceCharge ) then call save_annotation ( attributes , valp % annotation ) else if ( in_coreCharge ) then call save_annotation ( attributes , corep % annotation ) else if ( in_psml ) then ! It must be at the top level call save_annotation ( attributes , pseudo % annotation ) else ! Do nothing instead of dying ! call die(\"Misplaced <annotation> element\") endif end select parent_element = name end subroutine begin_element !---------------------------------------------------------------------- #ifndef PSML_USE_FOX subroutine end_element ( name ) #else subroutine end_element ( namespaceURI , localName , name ) character ( len =* ), intent ( in ) :: namespaceURI character ( len =* ), intent ( in ) :: localName #endif character ( len =* ), intent ( in ) :: name integer :: i if ( debug_parsing ) print * , \"-- end Element: \" , trim ( name ) select case ( name ) case ( \"radfunc\" ) in_radfunc = . false . if (. not . associated ( rp % data )) then call die ( \"No data for radfunc!\" ) endif case ( \"grid\" ) in_grid = . false . ! if (. not . got_explicit_grid_data ) then call die ( \"Need explicit grid data!\" ) endif call delete ( tmp_grid ) case ( \"data\" ) ! ! We are done filling up the radfunc data ! Check that we got the advertised number of items ! in_data = . false . if ( ndata /= size ( rp % data )) then call die ( \"npts mismatch in radfunc data\" ) endif case ( \"grid-data\" ) ! ! We are done filling up the grid data ! Check that we got the advertised number of items ! in_grid_data = . false . if ( ndata_grid /= size ( gdata )) then call die ( \"npts mismatch in grid\" ) endif if ( debug_parsing ) print * , \"Got grid data: \" , got_explicit_grid_data case ( \"pseudocore-charge\" ) in_coreCharge = . false . case ( \"valence-charge\" ) in_valenceCharge = . false . case ( \"semilocal-potentials\" ) in_semilocal = . false . slp => null () case ( \"nonlocal-projectors\" ) in_nonlocal = . false . nlp => null () case ( \"slps\" ) in_slps = . false . case ( \"proj\" ) in_proj = . false . case ( \"local-potential\" ) in_local_potential = . false . lop => null () case ( \"local-charge\" ) in_chlocal = . false . case ( \"pseudo-wave-functions\" ) in_pseudowavefun = . false . case ( \"pswf\" ) in_pswf = . false . case ( \"valence-configuration\" ) in_valence_config = . false . case ( \"exchange-correlation\" ) in_xc = . false . case ( \"libxc-info\" ) in_libxc_info = . false . if ( n_funct /= xp % n_functs_libxc ) & call die ( \"Too few <functional> elements in <libxc-info>\" ) case ( \"provenance\" ) in_provenance = . false . case ( \"input-file\" ) in_input_file = . false . case ( \"header\" ) in_header = . false . case ( \"psml\" ) in_psml = . false . !         call dump_pseudo(pseudo) end select end subroutine end_element !---------------------------------------------------------------------- subroutine pcdata_chunk ( chunk ) #ifdef PSML_USE_FOX use fox_extra , only : build_data_array #else use xmlf90_sax , only : build_data_array #endif use iso_varying_string , only : operator ( // ) character ( len =* ), intent ( in ) :: chunk if ( len_trim ( chunk ) == 0 ) RETURN ! skip empty chunk if ( in_data ) then ! ! Note that we know where we need to put it through the pointer rp... ! call build_data_array ( chunk , rp % data , ndata ) else if ( in_grid_data ) then ! !     Fill the explicit grid data pointer call build_data_array ( chunk , gdata , ndata_grid ) else if ( in_input_file ) then ifp % buffer = ifp % buffer // chunk else if ( in_header ) then ! ! There should not be any pcdata in header in this version... !      print *, \"Header data:\" !      print *, trim(chunk) endif end subroutine pcdata_chunk ! subroutine cdata_section_chunk ( chunk ) use iso_varying_string , only : operator ( // ) character ( len =* ), intent ( in ) :: chunk if ( len_trim ( chunk ) == 0 ) RETURN ! skip empty chunk if ( in_input_file ) then ifp % buffer = ifp % buffer // chunk endif end subroutine cdata_section_chunk !---------------------------------------------------------------------- ! Annotations are encoded as an association list ! in a couple of arrays ! ( (key \"value\") (key \"value\") ...) ! subroutine save_annotation ( atts , annotation ) use assoc_list , ps_annotation_t => assoc_list_t #ifdef PSML_USE_FOX use Fox_common , only : dictionary_t , len => getLength use fox_extra , only : get_value => get_value_by_index , get_key #else use xmlf90_sax , only : dictionary_t , get_value , get_key , len #endif type ( dictionary_t ), intent ( in ) :: atts type ( ps_annotation_t ), intent ( out ) :: annotation integer :: n , i , status character ( len = 300 ) :: key , value n = len ( atts ) call assoc_list_init ( annotation , n , status ) if ( status /= 0 ) call die ( \"Failed to init annotation object\" ) do i = 1 , n call get_key ( atts , i , key , status ) if ( status /= 0 ) call die ( \"cannot get key in atts dict\" ) call get_value ( atts , i , value , status ) if ( status /= 0 ) call die ( \"cannot get value in atts dict\" ) call assoc_list_insert ( annotation , key , value , status ) if ( status /= 0 ) call die ( \"Failed to insert annotation pair\" ) enddo end subroutine save_annotation end module m_psml_parsing_helpers","tags":"","loc":"sourcefile/m_psml_parsing_helpers.f90.html","title":"m_psml_parsing_helpers.F90 – libPSML"},{"text":"Modules m_psml_ps_edit Source Code m_psml_ps_edit.F90 Source Code !> Functions to edit the PSML ps_t structure !! !> @author Alberto Garcia ! module m_psml_ps_edit use m_psml_core ! For basic structures use external_interfaces , only : die => psml_die use assoc_list , ps_annotation_t => assoc_list_t implicit none public :: ps_SetUUID public :: ps_SetPSMLVersion public :: ps_AddProvenanceRecord public :: ps_Delete_LocalPotential public :: ps_Delete_NonLocalProjectors !public :: ps_AddSLBlock private CONTAINS !=============================================== subroutine ps_SetPSMLVersion ( ps , version ) type ( ps_t ), intent ( inout ) :: ps character ( len =* ), intent ( in ) :: version ps % version = version end subroutine ps_SetPSMLVersion subroutine ps_SetUUID ( ps , id ) type ( ps_t ), intent ( inout ) :: ps character ( len = 36 ), intent ( in ) :: id ps % uuid = id end subroutine ps_SetUUID subroutine ps_AddProvenanceRecord ( ps , creator , date , annotation ) type ( ps_t ), intent ( inout ) :: ps character ( len =* ), intent ( in ) :: creator character ( len =* ), intent ( in ) :: date type ( ps_annotation_t ), intent ( in ), target :: annotation type ( provenance_t ), pointer :: p type ( provenance_t ), pointer :: q allocate ( p ) q => ps % provenance if ( associated ( q )) then p % next => q q % prev => p endif ps % provenance => p p % creator = trim ( creator ) p % date = trim ( date ) p % annotation = annotation end subroutine ps_AddProvenanceRecord ! subroutine ps_Delete_NonlocalProjectors ( ps ) type ( ps_t ), intent ( inout ) :: ps call destroy_nonlocal ( ps % nonlocal ) end subroutine ps_Delete_NonlocalProjectors subroutine ps_Delete_LocalPotential ( ps ) type ( ps_t ), intent ( inout ) :: ps call destroy_local ( ps % local ) end subroutine ps_Delete_LocalPotential end module m_psml_ps_edit","tags":"","loc":"sourcefile/m_psml_ps_edit.f90.html","title":"m_psml_ps_edit.F90 – libPSML"},{"text":"Modules m_psml_reader Source Code m_psml_reader.F90 Source Code module m_psml_reader public :: psml_reader CONTAINS subroutine psml_reader ( fname , ps , debug ) use m_psml_core , only : ps_t , ps_destroy use m_psml_tables , only : ps_GenerateTables use m_psml_parsing_helpers , only : begin_element , end_element , pcdata_chunk use m_psml_parsing_helpers , only : cdata_section_chunk use m_psml_parsing_helpers , only : pseudo , debug_parsing use external_interfaces , only : die => psml_die #ifndef __NO_PROC_POINTERS__ use m_interp , only : set_default_interpolator #endif #ifdef PSML_USE_FOX use FoX_sax , only : xml_t , open_xml_file , close_xml_t , parse #else use xmlf90_sax , only : xml_t , open_xmlfile , xml_parse , close_xmlfile #endif implicit none character ( len =* ), intent ( in ) :: fname type ( ps_t ), intent ( inout ), target :: ps logical , intent ( in ), optional :: debug type ( xml_t ) :: fxml integer :: iostat ! Clean the object's internal data ! Note that the inout intent allow us ! to do this, and avoid having ps being ! reset by the compiler call ps_destroy ( ps ) ! Associate module pointer, so that the parsed data ! is written to ps pseudo => ps if ( present ( debug )) then debug_parsing = debug else debug_parsing = . false . endif ! Allocate internal structures here... #ifdef PSML_USE_FOX call open_xml_file ( fxml , fname , iostat ) if ( iostat /= 0 ) call die ( \"Cannot open XML file\" ) !! ** CDATA handler missing call parse ( fxml , startElement_handler = begin_element , & endElement_handler = end_element , & characters_handler = pcdata_chunk ) call close_xml_t ( fxml ) #else call open_xmlfile ( fname , fxml , iostat ) if ( iostat /= 0 ) call die ( \"Cannot open PSML file: \" // trim ( fname )) call xml_parse ( fxml , begin_element , end_element , pcdata_chunk , & cdata_section_handler = cdata_section_chunk , verbose = . false .) call close_xmlfile ( fxml ) #endif ! Clean up association of module pointer pseudo => null () call ps_GenerateTables ( ps ) #ifndef __NO_PROC_POINTERS__ ! ! Set default interpolator ! call set_default_interpolator () #endif end subroutine psml_reader end module m_psml_reader","tags":"","loc":"sourcefile/m_psml_reader.f90.html","title":"m_psml_reader.F90 – libPSML"},{"text":"Modules m_psml_tables Source Code m_psml_tables.F90 Source Code !> Functions to handle PSML pseudopotential format structures !! !! (Table generators) !> @author Alberto Garcia ! module m_psml_tables use m_psml_core ! For basic structures implicit none public :: ps_GenerateTables private CONTAINS !=============================================== !------------------------------------- subroutine generate_table_sl ( ps ) type ( ps_t ), intent ( inout ), target :: ps type ( semilocal_t ), pointer :: slp type ( slps_t ), pointer :: slvp integer :: npots if ( allocated ( ps % sl_table )) then deallocate ( ps % sl_table ) endif npots = 0 slp => ps % semilocal do while ( associated ( slp )) slvp => slp % pot do while ( associated ( slvp )) npots = npots + 1 slvp => slvp % next enddo slp => slp % next enddo allocate ( ps % sl_table ( npots )) npots = 0 slp => ps % semilocal do while ( associated ( slp )) slvp => slp % pot do while ( associated ( slvp )) npots = npots + 1 ps % sl_table ( npots )% p => slvp slvp => slvp % next enddo slp => slp % next enddo end subroutine generate_table_sl !------------------------------------- subroutine generate_table_nl ( ps ) type ( ps_t ), intent ( inout ), target :: ps type ( nonlocal_t ), pointer :: nlp type ( nlpj_t ), pointer :: nlpp integer :: nprojs if ( allocated ( ps % nl_table )) then deallocate ( ps % nl_table ) endif nprojs = 0 nlp => ps % nonlocal do while ( associated ( nlp )) nlpp => nlp % proj do while ( associated ( nlpp )) nprojs = nprojs + 1 nlpp => nlpp % next enddo nlp => nlp % next enddo allocate ( ps % nl_table ( nprojs )) nprojs = 0 nlp => ps % nonlocal do while ( associated ( nlp )) nlpp => nlp % proj do while ( associated ( nlpp )) nprojs = nprojs + 1 ps % nl_table ( nprojs )% p => nlpp nlpp => nlpp % next enddo nlp => nlp % next enddo end subroutine generate_table_nl subroutine ps_GenerateTables ( ps ) type ( ps_t ), intent ( inout ), target :: ps call generate_table_sl ( ps ) call generate_table_nl ( ps ) end subroutine ps_GenerateTables end module m_psml_tables","tags":"","loc":"sourcefile/m_psml_tables.f90.html","title":"m_psml_tables.F90 – libPSML"},{"text":"Modules sets_m Source Code sets_m.F90 Source Code module sets_m ! ! Utilities to handle set information in arrays ! implicit none private integer , parameter :: MAX_NSETS = 10 type alloc_t integer , allocatable :: ind (:) end type alloc_t type , public :: set_info_t private integer :: nsets integer :: set ( MAX_NSETS ) integer :: nels ( MAX_NSETS ) type ( alloc_t ) :: indexes ( MAX_NSETS ) end type set_info_t public :: sort_sets , display public :: nsets , set_id , set_indexes CONTAINS subroutine clear ( set_info ) type ( set_info_t ), intent ( inout ) :: set_info integer :: j set_info % set (:) = 0 set_info % nels (:) = 0 do j = 1 , MAX_NSETS if ( allocated ( set_info % indexes ( j )% ind )) then deallocate ( set_info % indexes ( j )% ind ) endif enddo set_info % nsets = 0 end subroutine clear subroutine display ( set_info ) type ( set_info_t ), intent ( in ) :: set_info integer :: j , i do j = 1 , set_info % nsets print * , \"Set: \" , set_info % set ( j ) do i = 1 , size ( set_info % indexes ( j )% ind ) print * , \"index: \" , set_info % indexes ( j )% ind ( i ) enddo enddo end subroutine display ! ! subroutine sort_sets ( n , a , set_info ) integer , intent ( in ) :: n integer , intent ( in ) :: a (:) type ( set_info_t ), intent ( inout ) :: set_info integer :: i , j , dim , nsets , current_set , set call clear ( set_info ) ! First pass. Assumes bunched sets current_set = 0 nsets = 0 do i = 1 , n set = a ( i ) if ( set /= current_set ) then nsets = nsets + 1 set_info % set ( nsets ) = set set_info % nels ( nsets ) = 1 current_set = set else set_info % nels ( nsets ) = set_info % nels ( nsets ) + 1 endif enddo set_info % nsets = nsets ! Allocate do j = 1 , nsets dim = set_info % nels ( j ) allocate ( set_info % indexes ( j )% ind ( dim )) enddo ! Second pass. current_set = 0 nsets = 0 do i = 1 , n set = a ( i ) if ( set /= current_set ) then nsets = nsets + 1 if ( nsets > MAX_NSETS ) stop \"set overflow\" set_info % nels ( nsets ) = 1 set_info % indexes ( nsets )% ind ( 1 ) = i current_set = set else set_info % nels ( nsets ) = set_info % nels ( nsets ) + 1 set_info % indexes ( nsets )% ind ( set_info % nels ( nsets )) = i endif enddo end subroutine sort_sets function nsets ( set_info ) result ( n ) type ( set_info_t ), intent ( in ) :: set_info integer :: n n = set_info % nsets end function nsets subroutine set_indexes ( set_info , j , idx ) type ( set_info_t ), intent ( in ) :: set_info integer , intent ( in ) :: j integer , allocatable , intent ( inout ) :: idx (:) integer :: n if ( j > set_info % nsets ) then n = 0 else n = set_info % nels ( j ) endif if ( allocated ( idx )) deallocate ( idx ) allocate ( idx ( n )) idx (:) = set_info % indexes ( j )% ind (:) end subroutine set_indexes function set_id ( set_info , j ) type ( set_info_t ), intent ( in ) :: set_info integer , intent ( in ) :: j integer :: set_id if ( j > set_info % nsets ) then set_id = 0 else set_id = set_info % set ( j ) endif end function set_id end module sets_m #ifdef __TEST__ program ts use sets_m type ( set_info_t ) :: set_info integer :: a ( 20 ) integer :: n print * , \"Enter n\" read * , n print * , \"enter a\" read * , a ( 1 : n ) call sort_sets ( n , a , set_info ) call display ( set_info ) end program ts #endif","tags":"","loc":"sourcefile/sets_m.f90.html","title":"sets_m.F90 – libPSML"},{"text":"Source Code basic_type.inc Source Code ! -------------------------------------------------------------- ! ! Basic functionality for reference - counted data structures ! ! This file has to be included after the global declarations ! for extra functionality , just where a \"contains\" statement ! would go ! ! Parameter : \"TYPE_NAME\" has to be set to the name of the type ! -------------------------------------------------------------- ! Acknowledgements of inspiration from the community : ! ! Basic templating via include files as in the FLIBS project ! by Arjen Markus ! ! Implementation of the classic reference - counting paradigm ! in the PyF95 project . ! ! ================================================================= #define OBJ_ERR_HANDLER psml_die ! ================================================================= PRIVATE public :: TYPE_NAME public :: init , delete , assignment ( = ), refcount , id public :: name public :: same ! same % data address ( i . e . if : this1 = this2 ) public :: initialized ! is allocated interface assignment ( = ) module procedure assign_ end interface interface init module procedure init_ end interface interface delete module procedure delete_ end interface interface refcount module procedure refcount_ end interface interface id module procedure id_ end interface interface name module procedure name_ end interface interface initialized module procedure initialized_ end interface interface same module procedure same_ end interface #ifdef OBJ_ERR_HANDLER ! Stand - alone routine which must be provided interface subroutine OBJ_ERR_HANDLER ( str ) character ( len =* ), intent ( in ) :: str end subroutine OBJ_ERR_HANDLER end interface # endif CONTAINS ! -- Main structural features ! subroutine init_ ( this ) ! Initializes new storage type ( TYPE_NAME ), intent ( inout ) :: this integer :: error ! First , remove the current reference call delete ( this ) ! Allocate fresh storage allocate ( this % data , stat = error ) if ( error /= 0 ) then #ifdef OBJ_ERR_HANDLER call OBJ_ERR_HANDLER ( \"Error allocating data structure\" ) #else ! Our default behavior STOP \"Error allocating data structure\" # endif endif ! Set the initial reference count this % data % refCount = 1 end subroutine init_ subroutine delete_ ( this ) ! Removes the current reference , possibly ! deallocating storage type ( TYPE_NAME ), intent ( inout ) :: this integer :: error ! logical , external :: print_debug_object_info if ( . not . initialized ( this ) ) return this % data % refCount = this % data % refCount - 1 if ( this % data % refCount == 0 ) then ! Safe to delete the data now ! Use the routine provided for this specific ! type to clean up any internal structure call delete_Data ( this % data ) ! if ( print_debug_object_info ()) then ! print * , \"--> deallocated \" // id(this) // \" \" // trim(this%data%name) ! endif ! Deallocate the currently referenced storage deallocate ( this % data , stat = error ) if ( error /= 0 ) then #ifdef OBJ_ERR_HANDLER call OBJ_ERR_HANDLER ( \"Error in deallocation\" ) #else ! Our default behavior STOP \"Error in deallocation\" # endif endif endif ! This is important to use the correct initialized functions nullify ( this % data ) end subroutine delete_ subroutine assign_ ( this , other ) ! Make \"this\" reference the same data as \"other\" . ! No copying of data is involved , simply an increment of the ! reference counter . ! IMPORTANT NOTE : Assignment must take the form of a subroutine , and ! not of a function , since the \"inout\" intent is essential . One has ! to clean up \"this\" before making it point to the same place as ! \"other\" . In a function , the intrinsic \"out\" intent for \"this\" ! will destroy any prior information . type ( TYPE_NAME ), intent ( inout ) :: this type ( TYPE_NAME ), intent ( in ) :: other if ( . not . initialized ( other ) ) then #ifdef OBJ_ERR_HANDLER call OBJ_ERR_HANDLER ( \"Assignment of non-initialized object in \" // trim(mod_name)) #else ! Our default behavior STOP \"Assignment of non-initialized object in \" // trim(mod_name) # endif endif ! Delete to remove the current reference of \"this\" call delete ( this ) ! Establish the new reference and increment the reference counter . this % data = > other % data this % data % refcount = this % data % refcount + 1 end subroutine assign_ pure function initialized_ ( this ) result ( init ) type ( TYPE_NAME ), intent ( in ) :: this logical :: init ! If it is not associated , it can not contain any data init = associated ( this % data ) end function initialized_ pure function same_ ( this1 , this2 ) result ( same ) type ( TYPE_NAME ), intent ( in ) :: this1 , this2 logical :: same ! If they are not both initialized they can not be the same same = initialized ( this1 ) . and . initialized ( this2 ) if ( . not . same ) return same = associated ( this1 % data , target = this2 % data ) end function same_ function refcount_ ( this ) result ( count ) type ( TYPE_NAME ), intent ( in ) :: this integer :: count count = this % data % refCount end function refcount_ ! The remaining procedures are not essential function id_ ( this ) result ( str ) type ( TYPE_NAME ), intent ( in ) :: this character ( len = 36 ) :: str str = this % data % id end function id_ function name_ ( this ) result ( str ) type ( TYPE_NAME ), intent ( in ) :: this character ( len = len_trim ( this % data % name )) :: str str = trim ( this % data % name ) end function name_ subroutine tag_new_object ( this ) type ( TYPE_NAME ), intent ( inout ) :: this ! logical , external :: print_debug_object_info ! external :: get_uuid ! call get_uuid ( this % data % id ) ! if ( print_debug_object_info ()) then ! print * , ' -- > allocated ' // trim(this%data%name) // \" \" // id(this) ! endif end subroutine tag_new_object ! =============================================================","tags":"","loc":"sourcefile/basic_type.inc.html","title":"basic_type.inc – libPSML"},{"text":"Source Code config.sh Source Code #!/bin/sh # ##set -x # # Get absolute path of this script, as that will be the Src directory to use # as reference when copying files. # # srcdir = $( cd -P -- \" $( dirname -- \" $0 \" ) \" && pwd -P ) # The above construct is more robust than:  srcdir=$(dirname $0) # (It will work if $0 is \"../Src\", since we want an *absolute* path # # Get also the absolute path of the object directory # objdir = $( cd -P -- \" $( pwd ) \" && pwd -P ) # destdir = $objdir # # Replicate the hierarchy of makefiles for the library only # ( cd $srcdir ; for i in $( find . \\ -name  mM  akefile | grep -v \\\\ ./Makefile ) ; do relpath = ${ i %/* } mkdir -p ${ destdir } / $relpath cp $relpath /*akefile ${ destdir } / $relpath done ) # # Copy full Examples material # ( cd $srcdir ; cd .. ; cp -rp examples ${ destdir } ) # # Copy other needed top-level files # cp -p $srcdir /psml.mk.in ${ destdir } # # Set the appropiate variables in the build makefile # sed \"s#VPATH=\\.#VPATH= ${ srcdir } #g\" ${ srcdir } /makefile | \\ sed \"s#MAIN_OBJDIR=\\.#MAIN_OBJDIR= ${ objdir } #g\" > ${ destdir } /makefile # echo \" *** Compilation setup done. \" ## for i in $(find .  -path Tutorial -o -path Examples  -prune -o \\","tags":"","loc":"sourcefile/config.sh.html","title":"config.sh – libPSML"},{"text":"type, public :: assoc_list_t Variables nslots nitems key value Source Code assoc_list_t Components Type Visibility Attributes Name Initial integer, private :: nslots = 0 integer, private :: nitems = 0 character(len=50), private, allocatable :: key (:) character(len=120), private, allocatable :: value (:) Source Code type , public :: assoc_list_t private integer :: nslots = 0 integer :: nitems = 0 character ( len = 50 ), allocatable :: key (:) character ( len = 120 ), allocatable :: value (:) end type assoc_list_t","tags":"","loc":"type/assoc_list_t.html","title":"assoc_list_t – libPSML "},{"text":"type, public :: Grid_ Variables refCount id name npts grid_data annotation Source Code Grid_ Components Type Visibility Attributes Name Initial integer, public :: refCount = 0 character(len=36), public :: id = \"null_id\" character(len=256), public :: name = \"null Grid\" integer, public :: npts = 0 real(kind=dp), public, pointer :: grid_data (:) => null() type(ps_annotation_t), public :: annotation Source Code type Grid_ integer :: refCount = 0 character ( len = 36 ) :: id = \"null_id\" !---------------------- character ( len = 256 ) :: name = \"null Grid\" integer :: npts = 0 real ( dp ), pointer :: grid_data (:) => null () type ( ps_annotation_t ) :: annotation end type Grid_","tags":"","loc":"type/grid_.html","title":"Grid_ – libPSML "},{"text":"type, public :: Grid Variables data Source Code Grid Components Type Visibility Attributes Name Initial type( Grid_ ), public, pointer :: data => null() Source Code type Grid type ( Grid_ ), pointer :: data => null () end type Grid","tags":"","loc":"type/grid.html","title":"Grid – libPSML "},{"text":"type, public :: input_file_t Variables name buffer Source Code input_file_t Components Type Visibility Attributes Name Initial character(len=40), public :: name = \"-----\" type(varying_string), public :: buffer Source Code type , public :: input_file_t character ( len = 40 ) :: name = \"-----\" type ( varying_string ) :: buffer end type input_file_t","tags":"","loc":"type/input_file_t.html","title":"input_file_t – libPSML "},{"text":"type, public :: provenance_t Variables prev creator date input_file annotation next Source Code provenance_t Components Type Visibility Attributes Name Initial type( provenance_t ), public, pointer :: prev => null() character(len=40), public :: creator = \"-----\" character(len=30), public :: date = \"-----\" type( input_file_t ), public :: input_file type(ps_annotation_t), public :: annotation type( provenance_t ), public, pointer :: next => null() Source Code type , public :: provenance_t type ( provenance_t ), pointer :: prev => null () character ( len = 40 ) :: creator = \"-----\" character ( len = 30 ) :: date = \"-----\" type ( input_file_t ) :: input_file type ( ps_annotation_t ) :: annotation type ( provenance_t ), pointer :: next => null () end type provenance_t","tags":"","loc":"type/provenance_t.html","title":"provenance_t – libPSML "},{"text":"type, public :: header_t Variables atomic_label z zpseudo flavor relativity polarized core_corrections Source Code header_t Components Type Visibility Attributes Name Initial character(len=30), public :: atomic_label real(kind=dp), public :: z real(kind=dp), public :: zpseudo character(len=50), public :: flavor character(len=6), public :: relativity logical, public :: polarized character(len=3), public :: core_corrections Source Code type , public :: header_t character ( len = 30 ) :: atomic_label !! generalized symbol real ( kind = dp ) :: z !! atomic number (might be non-integer) real ( kind = dp ) :: zpseudo !! Z - ncore-electrons character ( len = 50 ) :: flavor !! pseudization method character ( len = 6 ) :: relativity !! \"no|scalar|dirac\" logical :: polarized !! is spin_polarized? ! character ( len = 3 ) :: core_corrections !! are there NLCC's? end type header_t","tags":"","loc":"type/header_t.html","title":"header_t – libPSML "},{"text":"type, public :: config_val_t Variables nshells total_charge n l occ occ_up occ_down annotation Source Code config_val_t Components Type Visibility Attributes Name Initial integer, public :: nshells real(kind=dp), public :: total_charge integer, public, dimension(MAXN_SHELLS) :: n character(len=1), public, dimension(MAXN_SHELLS) :: l real(kind=dp), public, dimension(MAXN_SHELLS) :: occ real(kind=dp), public, dimension(MAXN_SHELLS) :: occ_up real(kind=dp), public, dimension(MAXN_SHELLS) :: occ_down type(ps_annotation_t), public :: annotation Source Code type , public :: config_val_t integer :: nshells real ( kind = dp ) :: total_charge integer , dimension ( MAXN_SHELLS ) :: n character ( len = 1 ), dimension ( MAXN_SHELLS ) :: l real ( dp ), dimension ( MAXN_SHELLS ) :: occ real ( dp ), dimension ( MAXN_SHELLS ) :: occ_up real ( dp ), dimension ( MAXN_SHELLS ) :: occ_down ! type ( ps_annotation_t ) :: annotation end type config_val_t","tags":"","loc":"type/config_val_t.html","title":"config_val_t – libPSML "},{"text":"type, public :: xc_t Variables n_functs_libxc libxc_name libxc_type libxc_id libxc_weight annotation Source Code xc_t Components Type Visibility Attributes Name Initial integer, public :: n_functs_libxc = 0 character(len=50), public, allocatable :: libxc_name (:) character(len=50), public, allocatable :: libxc_type (:) integer, public, allocatable :: libxc_id (:) real(kind=dp), public, allocatable :: libxc_weight (:) type(ps_annotation_t), public :: annotation Source Code type , public :: xc_t integer :: n_functs_libxc = 0 character ( len = 50 ), allocatable :: libxc_name (:) character ( len = 50 ), allocatable :: libxc_type (:) integer , allocatable :: libxc_id (:) real ( dp ), allocatable :: libxc_weight (:) type ( ps_annotation_t ) :: annotation end type xc_t","tags":"","loc":"type/xc_t.html","title":"xc_t – libPSML "},{"text":"type, public :: radfunc_t Variables grid data Source Code radfunc_t Components Type Visibility Attributes Name Initial type(Grid), public :: grid real(kind=dp), public, dimension(:), pointer :: data => null() Source Code type , public :: radfunc_t type ( Grid ) :: grid real ( kind = dp ), dimension (:), pointer :: data => null () end type radfunc_t","tags":"","loc":"type/radfunc_t.html","title":"radfunc_t – libPSML "},{"text":"type, public :: slps_t Variables n l j set flavor rc V parent_group next Source Code slps_t Components Type Visibility Attributes Name Initial integer, public :: n character(len=1), public :: l real(kind=dp), public :: j integer, public :: set character(len=40), public :: flavor real(kind=dp), public :: rc type( radfunc_t ), public :: V type( semilocal_t ), public, pointer :: parent_group => null() type( slps_t ), public, pointer :: next => null() Source Code type , public :: slps_t integer :: n character ( len = 1 ) :: l real ( dp ) :: j integer :: set character ( len = 40 ) :: flavor real ( dp ) :: rc type ( radfunc_t ) :: V type ( semilocal_t ), pointer :: parent_group => null () type ( slps_t ), pointer :: next => null () end type slps_t","tags":"","loc":"type/slps_t.html","title":"slps_t – libPSML "},{"text":"type, public :: sl_table_t Variables p Source Code sl_table_t Components Type Visibility Attributes Name Initial type( slps_t ), public, pointer :: p => null() Source Code type , public :: sl_table_t type ( slps_t ), pointer :: p => null () end type sl_table_t","tags":"","loc":"type/sl_table_t.html","title":"sl_table_t – libPSML "},{"text":"type, public :: semilocal_t Variables pot set grid annotation next Source Code semilocal_t Components Type Visibility Attributes Name Initial type( slps_t ), public, pointer :: pot => null() integer, public :: set type(Grid), public :: grid type(ps_annotation_t), public :: annotation type( semilocal_t ), public, pointer :: next => null() Source Code type , public :: semilocal_t type ( slps_t ), pointer :: pot => null () integer :: set ! ! Optional private grid ! type ( Grid ) :: grid type ( ps_annotation_t ) :: annotation ! type ( semilocal_t ), pointer :: next => null () end type semilocal_t","tags":"","loc":"type/semilocal_t.html","title":"semilocal_t – libPSML "},{"text":"type, public :: local_t Variables annotation grid Vlocal vlocal_type Chlocal Source Code local_t Components Type Visibility Attributes Name Initial type(ps_annotation_t), public :: annotation type(Grid), public :: grid type( radfunc_t ), public :: Vlocal character(len=40), public :: vlocal_type type( radfunc_t ), public :: Chlocal Source Code type , public :: local_t ! type ( ps_annotation_t ) :: annotation ! Optional private grid ! type ( Grid ) :: grid type ( radfunc_t ) :: Vlocal character ( len = 40 ) :: vlocal_type type ( radfunc_t ) :: Chlocal end type local_t","tags":"","loc":"type/local_t.html","title":"local_t – libPSML "},{"text":"type, public :: nlpj_t Variables seq l j set type ekb proj parent_group next Source Code nlpj_t Components Type Visibility Attributes Name Initial integer, public :: seq character(len=1), public :: l real(kind=dp), public :: j integer, public :: set character(len=40), public :: type real(kind=dp), public :: ekb type( radfunc_t ), public :: proj type( nonlocal_t ), public, pointer :: parent_group => null() type( nlpj_t ), public, pointer :: next => null() Source Code type , public :: nlpj_t integer :: seq character ( len = 1 ) :: l real ( dp ) :: j integer :: set character ( len = 40 ) :: type real ( dp ) :: ekb type ( radfunc_t ) :: proj type ( nonlocal_t ), pointer :: parent_group => null () type ( nlpj_t ), pointer :: next => null () end type nlpj_t","tags":"","loc":"type/nlpj_t.html","title":"nlpj_t – libPSML "},{"text":"type, public :: nl_table_t Variables p Source Code nl_table_t Components Type Visibility Attributes Name Initial type( nlpj_t ), public, pointer :: p => null() Source Code type , public :: nl_table_t type ( nlpj_t ), pointer :: p => null () end type nl_table_t","tags":"","loc":"type/nl_table_t.html","title":"nl_table_t – libPSML "},{"text":"type, public :: nonlocal_t Variables proj set grid annotation next Source Code nonlocal_t Components Type Visibility Attributes Name Initial type( nlpj_t ), public, pointer :: proj => null() integer, public :: set type(Grid), public :: grid type(ps_annotation_t), public :: annotation type( nonlocal_t ), public, pointer :: next => null() Source Code type , public :: nonlocal_t type ( nlpj_t ), pointer :: proj => null () integer :: set ! ! Optional private grid ! type ( Grid ) :: grid type ( ps_annotation_t ) :: annotation ! type ( nonlocal_t ), pointer :: next => null () end type nonlocal_t","tags":"","loc":"type/nonlocal_t.html","title":"nonlocal_t – libPSML "},{"text":"type, public :: pswfs_t Variables npswfs n l j set Phi grid annotation Source Code pswfs_t Components Type Visibility Attributes Name Initial integer, public :: npswfs = 0 integer, public, dimension(MAXN_WFNS) :: n character(len=1), public, dimension(MAXN_WFNS) :: l real(kind=dp), public, dimension(MAXN_WFNS) :: j integer, public, dimension(MAXN_WFNS) :: set type( radfunc_t ), public, dimension(MAXN_WFNS) :: Phi type(Grid), public :: grid type(ps_annotation_t), public :: annotation Source Code type , public :: pswfs_t integer :: npswfs = 0 integer , dimension ( MAXN_WFNS ) :: n character ( len = 1 ), dimension ( MAXN_WFNS ) :: l real ( dp ), dimension ( MAXN_WFNS ) :: j integer , dimension ( MAXN_WFNS ) :: set type ( radfunc_t ), dimension ( MAXN_WFNS ) :: Phi ! ! Optional private grid ! type ( Grid ) :: grid type ( ps_annotation_t ) :: annotation end type pswfs_t","tags":"","loc":"type/pswfs_t.html","title":"pswfs_t – libPSML "},{"text":"type, public :: valence_charge_t Variables total_charge rho_val annotation Source Code valence_charge_t Components Type Visibility Attributes Name Initial real(kind=dp), public :: total_charge type( radfunc_t ), public :: rho_val type(ps_annotation_t), public :: annotation Source Code type , public :: valence_charge_t real ( dp ) :: total_charge type ( radfunc_t ) :: rho_val type ( ps_annotation_t ) :: annotation end type valence_charge_t","tags":"","loc":"type/valence_charge_t.html","title":"valence_charge_t – libPSML "},{"text":"type, public :: core_charge_t Variables n_cont_derivs rcore rho_core annotation Source Code core_charge_t Components Type Visibility Attributes Name Initial integer, public :: n_cont_derivs real(kind=dp), public :: rcore type( radfunc_t ), public :: rho_core type(ps_annotation_t), public :: annotation Source Code type , public :: core_charge_t integer :: n_cont_derivs real ( dp ) :: rcore type ( radfunc_t ) :: rho_core type ( ps_annotation_t ) :: annotation end type core_charge_t","tags":"","loc":"type/core_charge_t.html","title":"core_charge_t – libPSML "},{"text":"type, public :: ps_t Variables version energy_unit length_unit uuid annotation provenance header config_val xc_info global_grid local semilocal nonlocal pswfs valence_charge core_charge sl_table nl_table Source Code ps_t Components Type Visibility Attributes Name Initial character(len=10), public :: version = \"\" character(len=10), public :: energy_unit = \"\" character(len=10), public :: length_unit = \"\" character(len=36), public :: uuid = \"\" type(ps_annotation_t), public :: annotation type( provenance_t ), public, pointer :: provenance => null() type( header_t ), public :: header type( config_val_t ), public :: config_val type( xc_t ), public :: xc_info type(Grid), public :: global_grid type( local_t ), public :: local type( semilocal_t ), public, pointer :: semilocal => null() type( nonlocal_t ), public, pointer :: nonlocal => null() type( pswfs_t ), public :: pswfs type( valence_charge_t ), public :: valence_charge type( core_charge_t ), public :: core_charge type( sl_table_t ), public, allocatable :: sl_table (:) type( nl_table_t ), public, allocatable :: nl_table (:) Source Code type , public :: ps_t !! Main derived type to hold the PSML information character ( len = 10 ) :: version = \"\" character ( len = 10 ) :: energy_unit = \"\" character ( len = 10 ) :: length_unit = \"\" character ( len = 36 ) :: uuid = \"\" type ( ps_annotation_t ) :: annotation type ( provenance_t ), pointer :: provenance => null () type ( header_t ) :: header type ( config_val_t ) :: config_val type ( xc_t ) :: xc_info type ( Grid ) :: global_grid type ( local_t ) :: local type ( semilocal_t ), pointer :: semilocal => null () type ( nonlocal_t ), pointer :: nonlocal => null () type ( pswfs_t ) :: pswfs ! type ( valence_charge_t ) :: valence_charge type ( core_charge_t ) :: core_charge ! ! index tables ! type ( sl_table_t ), allocatable :: sl_table (:) type ( nl_table_t ), allocatable :: nl_table (:) end type ps_t","tags":"","loc":"type/ps_t.html","title":"ps_t – libPSML "},{"text":"type, private :: alloc_t Variables ind Source Code alloc_t Components Type Visibility Attributes Name Initial integer, public, allocatable :: ind (:) Source Code type alloc_t integer , allocatable :: ind (:) end type alloc_t","tags":"","loc":"type/alloc_t.html","title":"alloc_t – libPSML "},{"text":"type, public :: set_info_t Variables nsets set nels indexes Source Code set_info_t Components Type Visibility Attributes Name Initial integer, private :: nsets integer, private :: set (MAX_NSETS) integer, private :: nels (MAX_NSETS) type( alloc_t ), private :: indexes (MAX_NSETS) Source Code type , public :: set_info_t private integer :: nsets integer :: set ( MAX_NSETS ) integer :: nels ( MAX_NSETS ) type ( alloc_t ) :: indexes ( MAX_NSETS ) end type set_info_t","tags":"","loc":"type/set_info_t.html","title":"set_info_t – libPSML "},{"text":"public function assoc_list_nitems(a) result(n) Arguments Type Intent Optional Attributes Name type( assoc_list_t ), intent(in) :: a Return Value integer Source Code assoc_list_nitems Source Code function assoc_list_nitems ( a ) result ( n ) type ( assoc_list_t ), intent ( in ) :: a integer :: n n = a % nitems end function assoc_list_nitems","tags":"","loc":"proc/assoc_list_nitems.html","title":"assoc_list_nitems – libPSML"},{"text":"public subroutine assoc_list_init(a, n, stat) Arguments Type Intent Optional Attributes Name type( assoc_list_t ), intent(inout) :: a integer, intent(in) :: n integer, intent(out) :: stat Source Code assoc_list_init Source Code subroutine assoc_list_init ( a , n , stat ) type ( assoc_list_t ), intent ( inout ) :: a integer , intent ( in ) :: n integer , intent ( out ) :: stat if ( allocated ( a % key )) then deallocate ( a % key ) endif if ( allocated ( a % value )) then deallocate ( a % value ) endif a % nslots = n a % nitems = 0 allocate ( a % key ( n ), a % value ( n ), stat = stat ) end subroutine assoc_list_init","tags":"","loc":"proc/assoc_list_init.html","title":"assoc_list_init – libPSML"},{"text":"public subroutine assoc_list_reset(a) Arguments Type Intent Optional Attributes Name type( assoc_list_t ), intent(inout) :: a Source Code assoc_list_reset Source Code subroutine assoc_list_reset ( a ) type ( assoc_list_t ), intent ( inout ) :: a if ( allocated ( a % key )) then deallocate ( a % key ) endif if ( allocated ( a % value )) then deallocate ( a % value ) endif a % nslots = 0 a % nitems = 0 end subroutine assoc_list_reset","tags":"","loc":"proc/assoc_list_reset.html","title":"assoc_list_reset – libPSML"},{"text":"public subroutine assoc_list_insert(a, key, value, stat) Arguments Type Intent Optional Attributes Name type( assoc_list_t ), intent(inout) :: a character(len=*), intent(in) :: key character(len=*), intent(in) :: value integer, intent(out) :: stat Source Code assoc_list_insert Source Code subroutine assoc_list_insert ( a , key , value , stat ) type ( assoc_list_t ), intent ( inout ) :: a character ( len =* ), intent ( in ) :: key , value integer , intent ( out ) :: stat integer :: i ! Replace if key exists already do i = 1 , a % nitems if ( a % key ( i ) == key ) then a % value ( i ) = value stat = 0 return endif enddo ! ! Add at the end a % nitems = a % nitems + 1 if ( a % nitems > a % nslots ) then stat = - 1 return endif i = a % nitems a % key ( i ) = key a % value ( i ) = value stat = 0 end subroutine assoc_list_insert","tags":"","loc":"proc/assoc_list_insert.html","title":"assoc_list_insert – libPSML"},{"text":"public subroutine assoc_list_get_key(a, i, key, stat) Arguments Type Intent Optional Attributes Name type( assoc_list_t ), intent(in) :: a integer, intent(in) :: i character(len=*), intent(out) :: key integer, intent(out) :: stat Source Code assoc_list_get_key Source Code subroutine assoc_list_get_key ( a , i , key , stat ) type ( assoc_list_t ), intent ( in ) :: a integer , intent ( in ) :: i character ( len =* ), intent ( out ) :: key integer , intent ( out ) :: stat if ( i > a % nitems ) then stat = - 1 return endif key = a % key ( i ) stat = 0 end subroutine assoc_list_get_key","tags":"","loc":"proc/assoc_list_get_key.html","title":"assoc_list_get_key – libPSML"},{"text":"public subroutine assoc_list_get_value_of_key(a, key, value, stat) Arguments Type Intent Optional Attributes Name type( assoc_list_t ), intent(in) :: a character(len=*), intent(in) :: key character(len=*), intent(out) :: value integer, intent(out) :: stat Source Code assoc_list_get_value_of_key Source Code subroutine assoc_list_get_value_of_key ( a , key , value , stat ) type ( assoc_list_t ), intent ( in ) :: a character ( len =* ), intent ( in ) :: key character ( len =* ), intent ( out ) :: value integer , intent ( out ) :: stat integer :: i do i = 1 , a % nitems if ( a % key ( i ) == key ) then value = a % value ( i ) stat = 0 return endif enddo stat = - 1 end subroutine assoc_list_get_value_of_key","tags":"","loc":"proc/assoc_list_get_value_of_key.html","title":"assoc_list_get_value_of_key – libPSML"},{"text":"public subroutine assoc_list_get_value_by_index(a, i, value, stat) Arguments Type Intent Optional Attributes Name type( assoc_list_t ), intent(in) :: a integer, intent(in) :: i character(len=*), intent(out) :: value integer, intent(out) :: stat Source Code assoc_list_get_value_by_index Source Code subroutine assoc_list_get_value_by_index ( a , i , value , stat ) type ( assoc_list_t ), intent ( in ) :: a integer , intent ( in ) :: i character ( len =* ), intent ( out ) :: value integer , intent ( out ) :: stat if ( i <= a % nitems ) then value = a % value ( i ) stat = 0 else stat = - 1 value = \"\" endif end subroutine assoc_list_get_value_by_index","tags":"","loc":"proc/assoc_list_get_value_by_index.html","title":"assoc_list_get_value_by_index – libPSML"},{"text":"public interface assoc_list_get_value Module Procedures assoc_list_get_value_by_index assoc_list_get_value_of_key Module Procedures public subroutine assoc_list_get_value_by_index (a, i, value, stat) Arguments Type Intent Optional Attributes Name type( assoc_list_t ), intent(in) :: a integer, intent(in) :: i character(len=*), intent(out) :: value integer, intent(out) :: stat public subroutine assoc_list_get_value_of_key (a, key, value, stat) Arguments Type Intent Optional Attributes Name type( assoc_list_t ), intent(in) :: a character(len=*), intent(in) :: key character(len=*), intent(out) :: value integer, intent(out) :: stat","tags":"","loc":"interface/assoc_list_get_value.html","title":"assoc_list_get_value – libPSML"},{"text":"private pure function initialized_(this) result(init) Arguments Type Intent Optional Attributes Name type( Grid ), intent(in) :: this Return Value logical","tags":"","loc":"proc/initialized_.html","title":"initialized_ – libPSML"},{"text":"private pure function same_(this1, this2) result(same) Arguments Type Intent Optional Attributes Name type( Grid ), intent(in) :: this1 type( Grid ), intent(in) :: this2 Return Value logical","tags":"","loc":"proc/same_.html","title":"same_ – libPSML"},{"text":"private function refcount_(this) result(count) Arguments Type Intent Optional Attributes Name type( Grid ), intent(in) :: this Return Value integer","tags":"","loc":"proc/refcount_.html","title":"refcount_ – libPSML"},{"text":"private function id_(this) result(str) Arguments Type Intent Optional Attributes Name type( Grid ), intent(in) :: this Return Value character(len=36)","tags":"","loc":"proc/id_.html","title":"id_ – libPSML"},{"text":"private function name_(this) result(str) Arguments Type Intent Optional Attributes Name type( Grid ), intent(in) :: this Return Value character(len=len_trim(this%data%name))","tags":"","loc":"proc/name_.html","title":"name_ – libPSML"},{"text":"public function valGrid(this) result(p) Arguments Type Intent Optional Attributes Name type( Grid ), intent(in) :: this Return Value real(kind=dp),\n  pointer,(:) Source Code valGrid Source Code function valGrid ( this ) result ( p ) type ( Grid ), intent ( in ) :: this real ( dp ), pointer :: p (:) nullify ( p ) p => this % data % grid_data end function valGrid","tags":"","loc":"proc/valgrid.html","title":"valGrid – libPSML"},{"text":"public function annotationGrid(this) result(p) Arguments Type Intent Optional Attributes Name type( Grid ), intent(in) :: this Return Value type(ps_annotation_t),\n  pointer Source Code annotationGrid Source Code function annotationGrid ( this ) result ( p ) type ( Grid ), intent ( in ) :: this type ( ps_annotation_t ) , pointer :: p nullify ( p ) p => this % data % annotation end function annotationGrid","tags":"","loc":"proc/annotationgrid.html","title":"annotationGrid – libPSML"},{"text":"public function sizeGrid(this) result(n) Arguments Type Intent Optional Attributes Name type( Grid ), intent(in) :: this Return Value integer Source Code sizeGrid Source Code function sizeGrid ( this ) result ( n ) type ( Grid ), intent ( in ) :: this integer :: n if (. not . initialized ( this )) then n = 0 else n = size ( this % data % grid_data ) endif end function sizeGrid","tags":"","loc":"proc/sizegrid.html","title":"sizeGrid – libPSML"},{"text":"private subroutine init_(this) Arguments Type Intent Optional Attributes Name type( Grid ), intent(inout) :: this","tags":"","loc":"proc/init_.html","title":"init_ – libPSML"},{"text":"private subroutine delete_(this) Arguments Type Intent Optional Attributes Name type( Grid ), intent(inout) :: this","tags":"","loc":"proc/delete_.html","title":"delete_ – libPSML"},{"text":"private subroutine assign_(this, other) Arguments Type Intent Optional Attributes Name type( Grid ), intent(inout) :: this type( Grid ), intent(in) :: other","tags":"","loc":"proc/assign_.html","title":"assign_ – libPSML"},{"text":"private subroutine tag_new_object(this) Arguments Type Intent Optional Attributes Name type( Grid ), intent(inout) :: this","tags":"","loc":"proc/tag_new_object.html","title":"tag_new_object – libPSML"},{"text":"private subroutine delete_Data(gd) Arguments Type Intent Optional Attributes Name type( Grid_ ) :: gd Source Code delete_Data Source Code subroutine delete_Data ( gd ) type ( Grid_ ) :: gd if ( associated ( gd % grid_data )) then deallocate ( gd % grid_data ) gd % grid_data => null () endif call ps_clean_annotation ( gd % annotation ) end subroutine delete_Data","tags":"","loc":"proc/delete_data.html","title":"delete_Data – libPSML"},{"text":"public subroutine newGrid(this, n, name) Arguments Type Intent Optional Attributes Name type( Grid ), intent(inout) :: this integer, intent(in) :: n character(len=*), intent(in), optional :: name Source Code newGrid Source Code subroutine newGrid ( this , n , name ) type ( Grid ), intent ( inout ) :: this integer , intent ( in ) :: n character ( len =* ), intent ( in ), optional :: name integer :: stat ! We release the previous incarnation ! This means that we relinquish access to the previous ! memory location. It will be deallocated when nobody ! else is using it. call init ( this ) if ( present ( name )) then this % data % name = trim ( name ) else this % data % name = \"(Grid from n)\" endif allocate ( this % data % grid_data ( n )) call tag_new_object ( this ) end subroutine newGrid","tags":"","loc":"proc/newgrid.html","title":"newGrid – libPSML"},{"text":"private subroutine printGrid(this) Arguments Type Intent Optional Attributes Name type( Grid ), intent(in) :: this Source Code printGrid Source Code subroutine printGrid ( this ) type ( Grid ), intent ( in ) :: this integer :: n , m if (. not . associated ( this % data )) then print \"(a)\" , \"Grid Not Associated\" RETURN endif n = size ( this % data % grid_data ) print \"(a,i0,a,i0,a,i0,a)\" , \"  <grid:\" // trim ( this % data % name ) // & \" n=\" , n , & \", refcount: \" , refcount ( this ), \">\" end subroutine printGrid","tags":"","loc":"proc/printgrid.html","title":"printGrid – libPSML"},{"text":"public interface print_type Module Procedures printGrid Module Procedures private subroutine printGrid (this) Arguments Type Intent Optional Attributes Name type( Grid ), intent(in) :: this","tags":"","loc":"interface/print_type.html","title":"print_type – libPSML"},{"text":"public interface assignment(=) Module Procedures assign_ Module Procedures private subroutine assign_ (this, other) Arguments Type Intent Optional Attributes Name type( Grid ), intent(inout) :: this type( Grid ), intent(in) :: other","tags":"","loc":"interface/assignment(=).html","title":"assignment(=) – libPSML"},{"text":"public interface init Module Procedures init_ Module Procedures private subroutine init_ (this) Arguments Type Intent Optional Attributes Name type( Grid ), intent(inout) :: this","tags":"","loc":"interface/init.html","title":"init – libPSML"},{"text":"public interface delete Module Procedures delete_ Module Procedures private subroutine delete_ (this) Arguments Type Intent Optional Attributes Name type( Grid ), intent(inout) :: this","tags":"","loc":"interface/delete.html","title":"delete – libPSML"},{"text":"public interface refcount Module Procedures refcount_ Module Procedures private function refcount_ (this) result(count) Arguments Type Intent Optional Attributes Name type( Grid ), intent(in) :: this Return Value integer","tags":"","loc":"interface/refcount.html","title":"refcount – libPSML"},{"text":"public interface id Module Procedures id_ Module Procedures private function id_ (this) result(str) Arguments Type Intent Optional Attributes Name type( Grid ), intent(in) :: this Return Value character(len=36)","tags":"","loc":"interface/id.html","title":"id – libPSML"},{"text":"public interface name Module Procedures name_ Module Procedures private function name_ (this) result(str) Arguments Type Intent Optional Attributes Name type( Grid ), intent(in) :: this Return Value character(len=len_trim(this%data%name))","tags":"","loc":"interface/name.html","title":"name – libPSML"},{"text":"public interface initialized Module Procedures initialized_ Module Procedures private pure function initialized_ (this) result(init) Arguments Type Intent Optional Attributes Name type( Grid ), intent(in) :: this Return Value logical","tags":"","loc":"interface/initialized.html","title":"initialized – libPSML"},{"text":"public interface same Module Procedures same_ Module Procedures private pure function same_ (this1, this2) result(same) Arguments Type Intent Optional Attributes Name type( Grid ), intent(in) :: this1 type( Grid ), intent(in) :: this2 Return Value logical","tags":"","loc":"interface/same.html","title":"same – libPSML"},{"text":"interface private subroutine psml_die(str) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: str","tags":"","loc":"interface/psml_die.html","title":"psml_die – libPSML"},{"text":"interface public subroutine psml_die(str) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: str","tags":"","loc":"interface/psml_die~2.html","title":"psml_die – libPSML"},{"text":"public subroutine set_interpolator(func, nquality) Arguments Type Intent Optional Attributes Name public subroutine func(nquality, x, y, npts, r, val, debug) Arguments Type Intent Optional Attributes Name integer, intent(in) :: nquality real(kind=dp), intent(in) :: x (*) real(kind=dp), intent(in) :: y (*) integer, intent(in) :: npts real(kind=dp), intent(in) :: r real(kind=dp), intent(out) :: val logical, intent(in) :: debug integer, intent(in) :: nquality Source Code set_interpolator Source Code subroutine set_interpolator ( func , nquality ) ! Parameter for interpolator's quality ! It might mean different things for different ! interpolators integer , intent ( in ) :: nquality ! We should not need to repeat this... interface subroutine func ( nquality , x , y , npts , r , val , debug ) integer , parameter :: dp = selected_real_kind ( 10 , 100 ) integer , intent ( in ) :: nquality ! Quality parameter real ( dp ), intent ( in ) :: x ( * ), y ( * ) integer , intent ( in ) :: npts ! Size of x, y arrays real ( dp ), intent ( in ) :: r real ( dp ), intent ( out ) :: val logical , intent ( in ) :: debug end subroutine func end interface interpolator => func nq = nquality end subroutine set_interpolator","tags":"","loc":"proc/set_interpolator.html","title":"set_interpolator – libPSML"},{"text":"public subroutine set_default_interpolator() Arguments None Source Code set_default_interpolator Source Code subroutine set_default_interpolator () ! Default interpolator and quality parameter ! DRH's dpnint modified by AG, at 7th order ! (Included in this module with permission) ! call set_interpolator ( dpnint1 , 7 ) end subroutine set_default_interpolator","tags":"","loc":"proc/set_default_interpolator.html","title":"set_default_interpolator – libPSML"},{"text":"private subroutine dpnint1(npoly, xx, yy, nn, r, val, debug) Arguments Type Intent Optional Attributes Name integer, intent(in) :: npoly real(kind=dp), intent(in) :: xx (*) real(kind=dp), intent(in) :: yy (*) integer, intent(in) :: nn real(kind=dp), intent(in) :: r real(kind=dp), intent(out) :: val logical, intent(in) :: debug Source Code dpnint1 Source Code subroutine dpnint1 ( npoly , xx , yy , nn , r , val , debug ) ! Modified by Alberto Garcia, March 2015 from routine ! dpnint by D.R. Hamann. ! Changes: !   -- A single value is returned !   -- It can extrapolate, instead of stopping, !      when called with an abscissa outside the !      data range. !   -- If the number of data points is less than !      npoly+1, npoly is implicitly reduced, without !      error, and without warning. !   -- Debug interface ! ! local polynomial interpolation of data yy on nn points xx ! giving value val on point r ! npoly sets order of polynomial ! xx must be ordered in ascending order ! output interpolated value val on point r implicit none integer , parameter :: dp = kind ( 1.0 d0 ) !Input variables real ( dp ), intent ( in ) :: xx ( * ), yy ( * ) real ( dp ), intent ( in ) :: r real ( dp ), intent ( out ) :: val integer , intent ( in ) :: nn , npoly logical , intent ( in ) :: debug !Local variables real ( dp ) :: sum , term , zz integer ii , imin , imax , iprod , iy , istart , kk , iend ! interval halving search for xx(ii) points bracketing r imin = 1 imax = nn do kk = 1 , nn ii = ( imin + imax ) / 2 if ( r > xx ( ii )) then imin = ii else imax = ii end if if ( imax - imin . eq . 1 ) then exit end if end do zz = r !   if (debug) print *, \"imin, imax: \", imin, imax if ( mod ( npoly , 2 ) == 1 ) then istart = imin - npoly / 2 else if ( zz - xx ( imin ) < xx ( imax ) - zz ) then istart = imin - npoly / 2 else istart = imax - npoly / 2 end if istart = min ( istart , nn - npoly ) istart = max ( istart , 1 ) iend = min ( istart + npoly , nn ) !  if (debug) print *, \"istart, iend: \", istart, iend sum = 0.0 d0 do iy = istart , iend if ( yy ( iy ) == 0.0 d0 ) cycle term = yy ( iy ) do iprod = istart , iend if ( iprod == iy ) cycle term = term * ( zz - xx ( iprod )) / ( xx ( iy ) - xx ( iprod )) end do sum = sum + term end do val = sum end subroutine dpnint1","tags":"","loc":"proc/dpnint1.html","title":"dpnint1 – libPSML"},{"text":"interface public subroutine interpolate(nquality, x, y, npts, r, val, debug) Arguments Type Intent Optional Attributes Name integer, intent(in) :: nquality real(kind=dp), intent(in) :: x (*) real(kind=dp), intent(in) :: y (*) integer, intent(in) :: npts real(kind=dp), intent(in) :: r real(kind=dp), intent(out) :: val logical, intent(in) :: debug","tags":"","loc":"interface/interpolate.html","title":"interpolate – libPSML"},{"text":"public function ps_GetLibPSMLVersion() result(v) Returns the library version in integer format Arguments None Return Value integer Source Code ps_GetLibPSMLVersion Source Code function ps_GetLibPSMLVersion () result ( v ) integer :: v v = PSML_LIBRARY_VERSION end function ps_GetLibPSMLVersion","tags":"","loc":"proc/ps_getlibpsmlversion.html","title":"ps_GetLibPSMLVersion – libPSML"},{"text":"public function ps_NValenceShells(ps) result(nshells) Returns the number of non-empty valence shells\n in the ps generation configuration\n @param ps is a handle to the psml information Arguments Type Intent Optional Attributes Name type( ps_t ), intent(in) :: ps Return Value integer Source Code ps_NValenceShells Source Code function ps_NValenceShells ( ps ) result ( nshells ) type ( ps_t ), intent ( in ) :: ps integer :: nshells nshells = ps % config_val % nshells end function ps_NValenceShells","tags":"","loc":"proc/ps_nvalenceshells.html","title":"ps_NValenceShells – libPSML"},{"text":"public function ps_ValenceShellL(ps, i) result(l) Returns the angular momentum of the i'th valence shell\n in the ps generation configuration\n @param ps is a handle to the psml information\n @param i is the index of the shell Note i should be within range Arguments Type Intent Optional Attributes Name type( ps_t ), intent(in) :: ps integer, intent(in) :: i Return Value integer Source Code ps_ValenceShellL Source Code function ps_ValenceShellL ( ps , i ) result ( l ) type ( ps_t ), intent ( in ) :: ps integer , intent ( in ) :: i integer :: l character ( len = 1 ) :: str call check_index ( i , ps % config_val % nshells , \"valence shell\" ) l = l_of_sym ( ps % config_val % l ( i ), \"valence shell\" ) end function ps_ValenceShellL","tags":"","loc":"proc/ps_valenceshelll.html","title":"ps_ValenceShellL – libPSML"},{"text":"public function ps_ValenceShellN(ps, i) result(n) Returns the principal quantum number of the i'th valence shell\n in the ps generation configuration\n @author Alberto Garcia\n @date 2014\n @param ps is a handle to the psml information\n @param i is the index of the shell Note i should be within range Arguments Type Intent Optional Attributes Name type( ps_t ), intent(in) :: ps integer, intent(in) :: i Return Value integer Source Code ps_ValenceShellN Source Code function ps_ValenceShellN ( ps , i ) result ( n ) type ( ps_t ), intent ( in ) :: ps integer , intent ( in ) :: i integer :: n call check_index ( i , ps % config_val % nshells , \"valence shell\" ) n = ps % config_val % n ( i ) end function ps_ValenceShellN","tags":"","loc":"proc/ps_valenceshelln.html","title":"ps_ValenceShellN – libPSML"},{"text":"public function ps_ValenceShellOccupation(ps, i, channel) result(occ) Returns the occupation of the i'th valence shell\n in the ps generation configuration\n @author Alberto Garcia\n @date 2014\n @param ps is a handle to the psml information\n @param i is the index of the shell\n @param channel is an optional parameter for spin-polarized \n calculations (\"u\" or \"d\"). Note i should be within range\n @note If \"channel\" is present, the occupation returned\n corresponds to the given channel Arguments Type Intent Optional Attributes Name type( ps_t ), intent(in) :: ps integer, intent(in) :: i character(len=1), intent(in), optional :: channel Return Value real(kind=dp) Source Code ps_ValenceShellOccupation Source Code function ps_ValenceShellOccupation ( ps , i , channel ) result ( occ ) type ( ps_t ), intent ( in ) :: ps integer , intent ( in ) :: i character ( len = 1 ), intent ( in ), optional :: channel real ( dp ) :: occ call check_index ( i , ps % config_val % nshells , \"valence shell\" ) if ( present ( channel )) then if ( ps_IsSpinPolarized ( ps )) then if ( channel == \"u\" ) then occ = ps % config_val % occ_up ( i ) else if ( channel == \"d\" ) then occ = ps % config_val % occ_down ( i ) else call die ( \"Wrong channel in ValShellOccupation\" ) endif else call die ( \"Cannot speficy channel in ValShellOccupation\" ) endif else occ = ps % config_val % occ ( i ) endif end function ps_ValenceShellOccupation","tags":"","loc":"proc/ps_valenceshelloccupation.html","title":"ps_ValenceShellOccupation – libPSML"},{"text":"public function ps_ValenceCharge_Value(ps, r) result(val) Computes the value of the valence charge at r\n @param ps is a handle to the psml information\n @param r is the radius\n It returns the valence charge density integrated over\n solid angle, so that Q_val = int{ val r r } Arguments Type Intent Optional Attributes Name type( ps_t ), intent(in) :: ps real(kind=dp), intent(in) :: r Return Value real(kind=dp) Source Code ps_ValenceCharge_Value Source Code function ps_ValenceCharge_Value ( ps , r ) result ( val ) type ( ps_t ), intent ( in ) :: ps real ( dp ), intent ( in ) :: r real ( dp ) :: val if ( r > max_range ( ps % valence_charge % rho_val )) then val = 0.0_dp else val = eval_radfunc ( ps % valence_charge % rho_val , r , debug = global_debug ) endif end function ps_ValenceCharge_Value","tags":"","loc":"proc/ps_valencecharge_value.html","title":"ps_ValenceCharge_Value – libPSML"},{"text":"public function ps_CoreCharge_Value(ps, r) result(val) Computes the value of the pseudo-core charge at r\n @param ps is a handle to the psml information\n @param r is the radius\n It returns the pseudo-core charge density integrated over\n solid angle, so that Q_core = int{ val r r } Arguments Type Intent Optional Attributes Name type( ps_t ), intent(in) :: ps real(kind=dp), intent(in) :: r Return Value real(kind=dp) Source Code ps_CoreCharge_Value Source Code function ps_CoreCharge_Value ( ps , r ) result ( val ) type ( ps_t ), intent ( in ) :: ps real ( dp ), intent ( in ) :: r real ( dp ) :: val if ( r > max_range ( ps % core_charge % rho_core )) then val = 0.0_dp else val = eval_radfunc ( ps % core_charge % rho_core , r , debug = global_debug ) endif end function ps_CoreCharge_Value","tags":"","loc":"proc/ps_corecharge_value.html","title":"ps_CoreCharge_Value – libPSML"},{"text":"public function ps_CoreCharge_MatchingRadius(ps) result(rmatch) Returns the matching radius used in the fit of the\n  pseudo-core charge\n @param ps is a handle to the psml information\n It returns -1.0 if the information is not provided in the file Arguments Type Intent Optional Attributes Name type( ps_t ), intent(in) :: ps Return Value real(kind=dp) Source Code ps_CoreCharge_MatchingRadius Source Code function ps_CoreCharge_MatchingRadius ( ps ) result ( rmatch ) type ( ps_t ), intent ( in ) :: ps real ( dp ) :: rmatch rmatch = ps % core_charge % rcore end function ps_CoreCharge_MatchingRadius","tags":"","loc":"proc/ps_corecharge_matchingradius.html","title":"ps_CoreCharge_MatchingRadius – libPSML"},{"text":"public function ps_CoreCharge_NumberOfKeptDerivatives(ps) result(n) Returns the number of derivatives kept in the fit of the\n  pseudo-core charge\n @param ps is a handle to the psml information\n It returns -1 if the information is not provided in the file Arguments Type Intent Optional Attributes Name type( ps_t ), intent(in) :: ps Return Value integer Source Code ps_CoreCharge_NumberOfKeptDerivatives Source Code function ps_CoreCharge_NumberOfKeptDerivatives ( ps ) result ( n ) type ( ps_t ), intent ( in ) :: ps integer :: n n = ps % core_charge % n_cont_derivs end function ps_CoreCharge_NumberOfKeptDerivatives","tags":"","loc":"proc/ps_corecharge_numberofkeptderivatives.html","title":"ps_CoreCharge_NumberOfKeptDerivatives – libPSML"},{"text":"public function ps_AtomicSymbol(ps) result(name) Returns the atomic symbol\n @param ps is a handle to the psml information Arguments Type Intent Optional Attributes Name type( ps_t ), intent(in) :: ps Return Value character(len=2) Source Code ps_AtomicSymbol Source Code function ps_AtomicSymbol ( ps ) result ( name ) type ( ps_t ), intent ( in ) :: ps character ( len = 2 ) :: name name = ps % header % atomic_label ( 1 : 2 ) end function ps_AtomicSymbol","tags":"","loc":"proc/ps_atomicsymbol.html","title":"ps_AtomicSymbol – libPSML"},{"text":"public function ps_AtomicLabel(ps) result(name) Returns the atomic label\n @param ps is a handle to the psml information\n The label is more general than the atomic symbol Arguments Type Intent Optional Attributes Name type( ps_t ), intent(in) :: ps Return Value character(len=len_trim(ps%header%atomic_label)) Source Code ps_AtomicLabel Source Code function ps_AtomicLabel ( ps ) result ( name ) type ( ps_t ), intent ( in ) :: ps character ( len = len_trim ( ps % header % atomic_label )) :: name name = trim ( ps % header % atomic_label ) end function ps_AtomicLabel","tags":"","loc":"proc/ps_atomiclabel.html","title":"ps_AtomicLabel – libPSML"},{"text":"public function ps_AtomicNumber(ps) result(z) Returns the atomic number\n @param ps is a handle to the psml information Arguments Type Intent Optional Attributes Name type( ps_t ), intent(in) :: ps Return Value real(kind=dp) Source Code ps_AtomicNumber Source Code function ps_AtomicNumber ( ps ) result ( z ) type ( ps_t ), intent ( in ) :: ps real ( dp ) :: z z = ps % header % z end function ps_AtomicNumber","tags":"","loc":"proc/ps_atomicnumber.html","title":"ps_AtomicNumber – libPSML"},{"text":"public function ps_GetPSMLVersion(ps) result(version) Returns the PSML version used in the file Arguments Type Intent Optional Attributes Name type( ps_t ), intent(in) :: ps Return Value character(len=10) Source Code ps_GetPSMLVersion Source Code function ps_GetPSMLVersion ( ps ) result ( version ) type ( ps_t ), intent ( in ) :: ps character ( len = 10 ) :: version version = ps % version end function ps_GetPSMLVersion","tags":"","loc":"proc/ps_getpsmlversion.html","title":"ps_GetPSMLVersion – libPSML"},{"text":"public function ps_GetUUID(ps) result(name) Returns the unique uuid of the PSML file Arguments Type Intent Optional Attributes Name type( ps_t ), intent(in) :: ps Return Value character(len=36) Source Code ps_GetUUID Source Code function ps_GetUUID ( ps ) result ( name ) type ( ps_t ), intent ( in ) :: ps character ( len = 36 ) :: name name = ps % uuid end function ps_GetUUID","tags":"","loc":"proc/ps_getuuid.html","title":"ps_GetUUID – libPSML"},{"text":"public function ps_Creator(ps) result(name) Returns the creator of the PSML file, as\n written in the provenance element.\n @param ps is a handle to the psml information\n The format is arbitrary Arguments Type Intent Optional Attributes Name type( ps_t ), intent(in) :: ps Return Value character(len=len_trim(ps%provenance%creator)) Source Code ps_Creator Source Code function ps_Creator ( ps ) result ( name ) type ( ps_t ), intent ( in ) :: ps character ( len = len_trim ( ps % provenance % creator )) :: name name = trim ( ps % provenance % creator ) end function ps_Creator","tags":"","loc":"proc/ps_creator.html","title":"ps_Creator – libPSML"},{"text":"public function ps_Date(ps) result(str) Returns the date appearing in the provenance element.\n @param ps is a handle to the psml information\n The format is arbitrary Arguments Type Intent Optional Attributes Name type( ps_t ), intent(in) :: ps Return Value character(len=len_trim(ps%provenance%date)) Source Code ps_Date Source Code function ps_Date ( ps ) result ( str ) type ( ps_t ), intent ( in ) :: ps character ( len = len_trim ( ps % provenance % date )) :: str str = trim ( ps % provenance % date ) end function ps_Date","tags":"","loc":"proc/ps_date.html","title":"ps_Date – libPSML"},{"text":"public function ps_PseudoFlavor(ps) result(str) category: needs_work\n  Returns the pseudization flavor appearing in the header element. NOTE Generalize to accept an index argument for potential\n In principle, different flavors for different channels are\n possible in the PSML file, but there is not support in the API for it. Arguments Type Intent Optional Attributes Name type( ps_t ), intent(in) :: ps Handle for PSML information Return Value character(len=len_trim(ps%header%flavor)) Source Code ps_PseudoFlavor Source Code function ps_PseudoFlavor ( ps ) result ( str ) !+ category: needs_work !+  Returns the pseudization flavor appearing in the header element. !*### NOTE ! Generalize to accept an index argument for potential ! In principle, different flavors for different channels are ! possible in the PSML file, but there is not support in the API for it. type ( ps_t ), intent ( in ) :: ps !+ Handle for PSML information character ( len = len_trim ( ps % header % flavor )) :: str str = trim ( ps % header % flavor ) end function ps_PseudoFlavor","tags":"","loc":"proc/ps_pseudoflavor.html","title":"ps_PseudoFlavor – libPSML"},{"text":"public function ps_ZPseudo(ps) result(zpseudo) Returns the effective valence of the pseudo-atom,\n i.e., the atomic number minus the number of \"core\" electrons. Arguments Type Intent Optional Attributes Name type( ps_t ), intent(in) :: ps Handle for PSML information Return Value real(kind=dp) Source Code ps_ZPseudo Source Code function ps_ZPseudo ( ps ) result ( zpseudo ) !*  Returns the effective valence of the pseudo-atom, ! i.e., the atomic number minus the number of \"core\" electrons. type ( ps_t ), intent ( in ) :: ps !+ Handle for PSML information real ( dp ) :: zpseudo zpseudo = ps % header % zpseudo end function ps_ZPseudo","tags":"","loc":"proc/ps_zpseudo.html","title":"ps_ZPseudo – libPSML"},{"text":"public function ps_GenerationZval(ps) result(zval) Returns the total valence charge density in the\n atomic configuration used to generate the pseudopotential.\n !> @param ps is a handle to the psml information Arguments Type Intent Optional Attributes Name type( ps_t ), intent(in) :: ps Return Value real(kind=dp) Source Code ps_GenerationZval Source Code function ps_GenerationZval ( ps ) result ( zval ) type ( ps_t ), intent ( in ) :: ps real ( dp ) :: zval zval = ps % config_val % total_charge end function ps_GenerationZval","tags":"","loc":"proc/ps_generationzval.html","title":"ps_GenerationZval – libPSML"},{"text":"public function ps_NLibxcFunctionals(ps) result(xc_n) Returns the number of libxc functionals that\n would correspond to the exchange-correlation scheme\n used in the generation code.\n @param ps is a handle to the psml information Arguments Type Intent Optional Attributes Name type( ps_t ), intent(in) :: ps Return Value integer Source Code ps_NLibxcFunctionals Source Code function ps_NLibxcFunctionals ( ps ) result ( xc_n ) type ( ps_t ), intent ( in ) :: ps integer :: xc_n xc_n = ps % xc_info % n_functs_libxc end function ps_NLibxcFunctionals","tags":"","loc":"proc/ps_nlibxcfunctionals.html","title":"ps_NLibxcFunctionals – libPSML"},{"text":"public function ps_LibxcName(ps, i) result(xc_name) Arguments Type Intent Optional Attributes Name type( ps_t ), intent(in) :: ps integer, intent(in) :: i Return Value character(len=50) Source Code ps_LibxcName Source Code function ps_LibxcName ( ps , i ) result ( xc_name ) type ( ps_t ), intent ( in ) :: ps integer , intent ( in ) :: i character ( len = 50 ) :: xc_name call check_index ( i , ps % xc_info % n_functs_libxc , \"libxc functional\" ) xc_name = ps % xc_info % libxc_name ( i ) end function ps_LibxcName","tags":"","loc":"proc/ps_libxcname.html","title":"ps_LibxcName – libPSML"},{"text":"public function ps_LibxcId(ps, i) result(xc_id) Arguments Type Intent Optional Attributes Name type( ps_t ), intent(in) :: ps integer, intent(in) :: i Return Value integer Source Code ps_LibxcId Source Code function ps_LibxcId ( ps , i ) result ( xc_id ) type ( ps_t ), intent ( in ) :: ps integer , intent ( in ) :: i integer :: xc_id call check_index ( i , ps % xc_info % n_functs_libxc , \"libxc functional\" ) xc_id = ps % xc_info % libxc_id ( i ) end function ps_LibxcId","tags":"","loc":"proc/ps_libxcid.html","title":"ps_LibxcId – libPSML"},{"text":"public function ps_LibxcWeight(ps, i) result(xc_weight) Arguments Type Intent Optional Attributes Name type( ps_t ), intent(in) :: ps integer, intent(in) :: i Return Value real(kind=dp) Source Code ps_LibxcWeight Source Code function ps_LibxcWeight ( ps , i ) result ( xc_weight ) type ( ps_t ), intent ( in ) :: ps integer , intent ( in ) :: i real ( dp ) :: xc_weight call check_index ( i , ps % xc_info % n_functs_libxc , \"libxc functional\" ) xc_weight = ps % xc_info % libxc_weight ( i ) end function ps_LibxcWeight","tags":"","loc":"proc/ps_libxcweight.html","title":"ps_LibxcWeight – libPSML"},{"text":"private function ps_LibxcIdArray(ps) result(xc_id_array) Arguments Type Intent Optional Attributes Name type( ps_t ), intent(in) :: ps Return Value integer\n  (2) Source Code ps_LibxcIdArray Source Code function ps_LibxcIdArray ( ps ) result ( xc_id_array ) type ( ps_t ), intent ( in ) :: ps integer :: xc_id_array ( 2 ) xc_id_array (:) = ps % xc_info % libxc_id (:) end function ps_LibxcIdArray","tags":"","loc":"proc/ps_libxcidarray.html","title":"ps_LibxcIdArray – libPSML"},{"text":"public function ps_ValidLibxc(ps) result(libxc_ok) Arguments Type Intent Optional Attributes Name type( ps_t ), intent(in), target :: ps Return Value logical Source Code ps_ValidLibxc Source Code function ps_ValidLibxc ( ps ) result ( libxc_ok ) type ( ps_t ), intent ( in ), target :: ps logical :: libxc_ok integer , pointer :: xc_id_array (:) xc_id_array => ps % xc_info % libxc_id (:) libxc_ok = . true . if ( any ( xc_id_array (:) <= 0 )) then libxc_ok = . false . endif end function ps_ValidLibxc","tags":"","loc":"proc/ps_validlibxc.html","title":"ps_ValidLibxc – libPSML"},{"text":"public function ps_GetAnnotation(ps, name) result(annotation) Returns the annotation associated to a\n given element. For grids, if a radial function\n handle is given, the annotation for that \n radial function's grid is returned. Otherwise,\n the return value is the annotation for the global grid.\n If there is no appropriate annotation, an empty\n structure is returned. Note Support for radfunc handles is not yet implemented\n @param ps is a handle to the psml information\n @param name is the element name or a common alias\n @param radfunc is a handle to a radial function structure Arguments Type Intent Optional Attributes Name type( ps_t ), intent(in) :: ps character(len=*), intent(in) :: name Return Value type(ps_annotation_t) Source Code ps_GetAnnotation Source Code function ps_GetAnnotation ( ps , name ) result ( annotation ) !! ,radfunc)  To be implemented type ( ps_t ), intent ( in ) :: ps character ( len =* ), intent ( in ) :: name !!  type(radfunc_t), intent(in), optional  :: radfunc type ( ps_annotation_t ) :: annotation type ( ps_annotation_t ), pointer :: annotation_p select case ( name ) case ( \"psml\" , \"PSML\" , \"top-level\" , \"global\" ) annotation = ps % annotation case ( \"provenance\" ) annotation = ps % provenance % annotation case ( \"exchange-correlation\" , \"xc\" , \"XC\" ) annotation = ps % xc_info % annotation case ( \"valence-configuration\" ) annotation = ps % config_val % annotation case ( \"grid\" ) !!$      if (present(radfunc)) then !!$         ! We are told to get the grid annotation !!$         ! for a specific radial function !!$ !!$         if (.not. associated(radfunc%grid)) then !!$            call die(\"get_annotation: Invalid radial function\") !!$         endif !!$         annotation = radfunc%grid%annotation !!$ !!$      else ! This is the global grid annotation if (. not . initialized ( ps % global_grid )) then annotation = EMPTY_ANNOTATION else annotation_p => annotationGrid ( ps % global_grid ) annotation = annotation_p endif !!$      endif case ( \"semilocal-potentials\" ) annotation = ps % semilocal % annotation case ( \"nonlocal-projectors\" ) annotation = ps % nonlocal % annotation case ( \"local-potential\" ) annotation = ps % local % annotation case ( \"pseudo-wavefunctions\" ) annotation = ps % pswfs % annotation case ( \"valence-charge\" ) annotation = ps % valence_charge % annotation case ( \"core-charge\" ) annotation = ps % core_charge % annotation case default call die ( \"Unrecognized annotation name: \" // trim ( name )) end select end function ps_GetAnnotation","tags":"","loc":"proc/ps_getannotation.html","title":"ps_GetAnnotation – libPSML"},{"text":"public function ps_XCAnnotation(ps) result(xc_annotation) Arguments Type Intent Optional Attributes Name type( ps_t ), intent(in) :: ps Return Value type(ps_annotation_t) Source Code ps_XCAnnotation Source Code function ps_XCAnnotation ( ps ) result ( xc_annotation ) type ( ps_t ), intent ( in ) :: ps type ( ps_annotation_t ) :: xc_annotation xc_annotation = ps % xc_info % annotation end function ps_XCAnnotation","tags":"","loc":"proc/ps_xcannotation.html","title":"ps_XCAnnotation – libPSML"},{"text":"public function ps_Relativity(ps) result(rel) Arguments Type Intent Optional Attributes Name type( ps_t ), intent(in) :: ps Return Value character(len=6) Source Code ps_Relativity Source Code function ps_Relativity ( ps ) result ( rel ) type ( ps_t ), intent ( in ) :: ps character ( len = 6 ) :: rel rel = ps % header % relativity end function ps_Relativity","tags":"","loc":"proc/ps_relativity.html","title":"ps_Relativity – libPSML"},{"text":"public function ps_IsSpinPolarized(ps) result(pol) Arguments Type Intent Optional Attributes Name type( ps_t ), intent(in) :: ps Return Value logical Source Code ps_IsSpinPolarized Source Code function ps_IsSpinPolarized ( ps ) result ( pol ) type ( ps_t ), intent ( in ) :: ps logical :: pol pol = ps % header % polarized end function ps_IsSpinPolarized","tags":"","loc":"proc/ps_isspinpolarized.html","title":"ps_IsSpinPolarized – libPSML"},{"text":"public function ps_HasCoreCorrections(ps) result(cc) Arguments Type Intent Optional Attributes Name type( ps_t ), intent(in) :: ps Return Value logical Source Code ps_HasCoreCorrections Source Code function ps_HasCoreCorrections ( ps ) result ( cc ) type ( ps_t ), intent ( in ) :: ps logical :: cc cc = ( ps % header % core_corrections == \"yes\" ) end function ps_HasCoreCorrections","tags":"","loc":"proc/ps_hascorecorrections.html","title":"ps_HasCoreCorrections – libPSML"},{"text":"public function ps_Number_Of_Potentials(ps, set) result(n) Arguments Type Intent Optional Attributes Name type( ps_t ), intent(in) :: ps integer, intent(in) :: set Return Value integer Source Code ps_Number_Of_Potentials Source Code function ps_Number_Of_Potentials ( ps , set ) result ( n ) type ( ps_t ), intent ( in ) :: ps integer , intent ( in ) :: set integer :: n integer , allocatable :: idx (:) call ps_Get_Potential_Indexes ( ps , set , idx ) n = size ( idx ) deallocate ( idx ) end function ps_Number_Of_Potentials","tags":"","loc":"proc/ps_number_of_potentials.html","title":"ps_Number_Of_Potentials – libPSML"},{"text":"public function ps_Number_Of_Projectors(ps, set) result(n) Arguments Type Intent Optional Attributes Name type( ps_t ), intent(in) :: ps integer, intent(in) :: set Return Value integer Source Code ps_Number_Of_Projectors Source Code function ps_Number_Of_Projectors ( ps , set ) result ( n ) type ( ps_t ), intent ( in ) :: ps integer , intent ( in ) :: set integer :: n integer , allocatable :: idx (:) call ps_Get_Projector_Indexes ( ps , set , idx ) n = size ( idx ) deallocate ( idx ) end function ps_Number_Of_Projectors","tags":"","loc":"proc/ps_number_of_projectors.html","title":"ps_Number_Of_Projectors – libPSML"},{"text":"public function ps_Number_Of_PseudoWfs(ps, set) result(n) Arguments Type Intent Optional Attributes Name type( ps_t ), intent(in) :: ps integer, intent(in) :: set Return Value integer Source Code ps_Number_Of_PseudoWfs Source Code function ps_Number_Of_PseudoWfs ( ps , set ) result ( n ) type ( ps_t ), intent ( in ) :: ps integer , intent ( in ) :: set integer :: n integer , allocatable :: idx (:) call ps_Get_PseudoWf_Indexes ( ps , set , idx ) n = size ( idx ) deallocate ( idx ) end function ps_Number_Of_PseudoWfs","tags":"","loc":"proc/ps_number_of_pseudowfs.html","title":"ps_Number_Of_PseudoWfs – libPSML"},{"text":"public function ps_Potential_Set(ps, i) result(set) Arguments Type Intent Optional Attributes Name type( ps_t ), intent(in) :: ps integer, intent(in) :: i Return Value integer Source Code ps_Potential_Set Source Code function ps_Potential_Set ( ps , i ) result ( set ) type ( ps_t ), intent ( in ) :: ps integer , intent ( in ) :: i integer :: set call check_index ( i , size ( ps % sl_table ), \"SL pot\" ) set = ps % sl_table ( i )% p % set ! end function ps_Potential_Set","tags":"","loc":"proc/ps_potential_set.html","title":"ps_Potential_Set – libPSML"},{"text":"public function ps_Potential_L(ps, i) result(l) Arguments Type Intent Optional Attributes Name type( ps_t ), intent(in) :: ps integer, intent(in) :: i Return Value integer Source Code ps_Potential_L Source Code function ps_Potential_L ( ps , i ) result ( l ) type ( ps_t ), intent ( in ) :: ps integer , intent ( in ) :: i integer :: l call check_index ( i , size ( ps % sl_table ), \"SL pot\" ) l = l_of_sym ( ps % sl_table ( i )% p % l , \"SL pot\" ) end function ps_Potential_L","tags":"","loc":"proc/ps_potential_l.html","title":"ps_Potential_L – libPSML"},{"text":"public function ps_Potential_J(ps, i) result(j) Arguments Type Intent Optional Attributes Name type( ps_t ), intent(in) :: ps integer, intent(in) :: i Return Value real(kind=dp) Source Code ps_Potential_J Source Code function ps_Potential_J ( ps , i ) result ( j ) type ( ps_t ), intent ( in ) :: ps integer , intent ( in ) :: i real ( dp ) :: j call check_index ( i , size ( ps % sl_table ), \"SL pot\" ) if ( iand ( ps % sl_table ( i )% p % set , & SET_LJ + SET_USER1 + SET_USER2 ) & == 0 ) then call die ( \"Attempt to get j from wrong set\" ) endif j = ps % sl_table ( i )% p % j end function ps_Potential_J","tags":"","loc":"proc/ps_potential_j.html","title":"ps_Potential_J – libPSML"},{"text":"public function ps_Potential_Rc(ps, i) result(rc) Arguments Type Intent Optional Attributes Name type( ps_t ), intent(in) :: ps integer, intent(in) :: i Return Value real(kind=dp) Source Code ps_Potential_Rc Source Code function ps_Potential_Rc ( ps , i ) result ( rc ) type ( ps_t ), intent ( in ) :: ps integer , intent ( in ) :: i real ( dp ) :: rc call check_index ( i , size ( ps % sl_table ), \"SL pot\" ) rc = ps % sl_table ( i )% p % rc end function ps_Potential_Rc","tags":"","loc":"proc/ps_potential_rc.html","title":"ps_Potential_Rc – libPSML"},{"text":"public function ps_Potential_N(ps, i) result(n) Arguments Type Intent Optional Attributes Name type( ps_t ), intent(in) :: ps integer, intent(in) :: i Return Value integer Source Code ps_Potential_N Source Code function ps_Potential_N ( ps , i ) result ( n ) type ( ps_t ), intent ( in ) :: ps integer , intent ( in ) :: i integer :: n call check_index ( i , size ( ps % sl_table ), \"SL pot\" ) n = ps % sl_table ( i )% p % n end function ps_Potential_N","tags":"","loc":"proc/ps_potential_n.html","title":"ps_Potential_N – libPSML"},{"text":"public function ps_Potential_Value(ps, i, r) result(val) Evaluator by storage index Arguments Type Intent Optional Attributes Name type( ps_t ), intent(in) :: ps integer, intent(in) :: i real(kind=dp), intent(in) :: r Return Value real(kind=dp) Source Code ps_Potential_Value Source Code function ps_Potential_Value ( ps , i , r ) result ( val ) type ( ps_t ), intent ( in ) :: ps integer , intent ( in ) :: i real ( dp ), intent ( in ) :: r real ( dp ) :: val logical :: coulomb_tail call check_index ( i , size ( ps % sl_table ), \"SL pot\" ) select case ( ps % sl_table ( i )% p % set ) case ( SET_SO , SET_SPINDIFF ) coulomb_tail = . false . case default coulomb_tail = . true . end select if ( r > max_range ( ps % sl_table ( i )% p % V )) then if ( coulomb_tail ) then val = - ps_ZPseudo ( ps ) / r else val = 0.0_dp endif else val = eval_radfunc ( ps % sl_table ( i )% p % V , r , debug = global_debug ) endif end function ps_Potential_Value","tags":"","loc":"proc/ps_potential_value.html","title":"ps_Potential_Value – libPSML"},{"text":"public function ps_PseudoWf_L(ps, i) result(l) Arguments Type Intent Optional Attributes Name type( ps_t ), intent(in) :: ps integer, intent(in) :: i Return Value integer Source Code ps_PseudoWf_L Source Code function ps_PseudoWf_L ( ps , i ) result ( l ) type ( ps_t ), intent ( in ) :: ps integer , intent ( in ) :: i integer :: l call check_index ( i , ps % pswfs % npswfs , \"pswf\" ) l = l_of_sym ( ps % pswfs % l ( i ), \"pswf\" ) end function ps_PseudoWf_L","tags":"","loc":"proc/ps_pseudowf_l.html","title":"ps_PseudoWf_L – libPSML"},{"text":"public function ps_PseudoWf_J(ps, i) result(j) Arguments Type Intent Optional Attributes Name type( ps_t ), intent(in) :: ps integer, intent(in) :: i Return Value real(kind=dp) Source Code ps_PseudoWf_J Source Code function ps_PseudoWf_J ( ps , i ) result ( j ) type ( ps_t ), intent ( in ) :: ps integer , intent ( in ) :: i real ( dp ) :: j call check_index ( i , ps % pswfs % npswfs , \"pswf\" ) if ( iand ( ps % pswfs % set ( i ), & SET_LJ + SET_USER1 + SET_USER2 ) & == 0 ) then call die ( \"Attempt to get j from wrong set\" ) endif j = ps % pswfs % j ( i ) end function ps_PseudoWf_J","tags":"","loc":"proc/ps_pseudowf_j.html","title":"ps_PseudoWf_J – libPSML"},{"text":"public function ps_PseudoWf_N(ps, i) result(n) Arguments Type Intent Optional Attributes Name type( ps_t ), intent(in) :: ps integer, intent(in) :: i Return Value integer Source Code ps_PseudoWf_N Source Code function ps_PseudoWf_N ( ps , i ) result ( n ) type ( ps_t ), intent ( in ) :: ps integer , intent ( in ) :: i integer :: n call check_index ( i , ps % pswfs % npswfs , \"pswf\" ) n = ps % pswfs % n ( i ) end function ps_PseudoWf_N","tags":"","loc":"proc/ps_pseudowf_n.html","title":"ps_PseudoWf_N – libPSML"},{"text":"public function ps_PseudoWf_Set(ps, i) result(set) Arguments Type Intent Optional Attributes Name type( ps_t ), intent(in) :: ps integer, intent(in) :: i Return Value integer Source Code ps_PseudoWf_Set Source Code function ps_PseudoWf_Set ( ps , i ) result ( set ) type ( ps_t ), intent ( in ) :: ps integer , intent ( in ) :: i integer :: set call check_index ( i , ps % pswfs % npswfs , \"pswf\" ) set = ps % pswfs % set ( i ) ! end function ps_PseudoWf_Set","tags":"","loc":"proc/ps_pseudowf_set.html","title":"ps_PseudoWf_Set – libPSML"},{"text":"public function ps_PseudoWf_Value(ps, i, r) result(val) Arguments Type Intent Optional Attributes Name type( ps_t ), intent(in) :: ps integer, intent(in) :: i real(kind=dp), intent(in) :: r Return Value real(kind=dp) Source Code ps_PseudoWf_Value Source Code function ps_PseudoWf_Value ( ps , i , r ) result ( val ) type ( ps_t ), intent ( in ) :: ps integer , intent ( in ) :: i real ( dp ), intent ( in ) :: r real ( dp ) :: val call check_index ( i , ps % pswfs % npswfs , \"pswf\" ) if ( r > max_range ( ps % pswfs % Phi ( i ))) then val = 0.0_dp else val = eval_radfunc ( ps % pswfs % Phi ( i ), r , debug = global_debug ) endif end function ps_PseudoWf_Value","tags":"","loc":"proc/ps_pseudowf_value.html","title":"ps_PseudoWf_Value – libPSML"},{"text":"public function ps_HasProjectors(ps) result(p) Arguments Type Intent Optional Attributes Name type( ps_t ), intent(in) :: ps Return Value logical Source Code ps_HasProjectors Source Code function ps_HasProjectors ( ps ) result ( p ) type ( ps_t ), intent ( in ) :: ps logical :: p ! p = ( size ( ps % nl_table ) > 0 ) end function ps_HasProjectors","tags":"","loc":"proc/ps_hasprojectors.html","title":"ps_HasProjectors – libPSML"},{"text":"public function ps_HasLocalPotential(ps) result(p) Arguments Type Intent Optional Attributes Name type( ps_t ), intent(in) :: ps Return Value logical Source Code ps_HasLocalPotential Source Code function ps_HasLocalPotential ( ps ) result ( p ) type ( ps_t ), intent ( in ) :: ps logical :: p ! p = ( initialized ( ps % local % Vlocal % grid )) end function ps_HasLocalPotential","tags":"","loc":"proc/ps_haslocalpotential.html","title":"ps_HasLocalPotential – libPSML"},{"text":"public function ps_HasLocalCharge(ps) result(p) Arguments Type Intent Optional Attributes Name type( ps_t ), intent(in) :: ps Return Value logical Source Code ps_HasLocalCharge Source Code function ps_HasLocalCharge ( ps ) result ( p ) type ( ps_t ), intent ( in ) :: ps logical :: p ! p = ( initialized ( ps % local % chlocal % grid )) end function ps_HasLocalCharge","tags":"","loc":"proc/ps_haslocalcharge.html","title":"ps_HasLocalCharge – libPSML"},{"text":"public function ps_HasPSOperator(ps) result(psop) Arguments Type Intent Optional Attributes Name type( ps_t ), intent(in) :: ps Return Value logical Source Code ps_HasPSOperator Source Code function ps_HasPSOperator ( ps ) result ( psop ) type ( ps_t ), intent ( in ) :: ps logical :: psop ! psop = ( ps_HasProjectors ( ps ) . and . ps_HasLocalPotential ( ps )) end function ps_HasPSOperator","tags":"","loc":"proc/ps_haspsoperator.html","title":"ps_HasPSOperator – libPSML"},{"text":"public function ps_HasSemilocalPotentials(ps) result(p) Arguments Type Intent Optional Attributes Name type( ps_t ), intent(in) :: ps Return Value logical Source Code ps_HasSemilocalPotentials Source Code function ps_HasSemilocalPotentials ( ps ) result ( p ) type ( ps_t ), intent ( in ) :: ps logical :: p ! p = ( associated ( ps % semilocal )) end function ps_HasSemilocalPotentials","tags":"","loc":"proc/ps_hassemilocalpotentials.html","title":"ps_HasSemilocalPotentials – libPSML"},{"text":"public function ps_LocalPotential_Value(ps, r) result(val) Arguments Type Intent Optional Attributes Name type( ps_t ), intent(in) :: ps real(kind=dp), intent(in) :: r Return Value real(kind=dp) Source Code ps_LocalPotential_Value Source Code function ps_LocalPotential_Value ( ps , r ) result ( val ) type ( ps_t ), intent ( in ) :: ps real ( dp ), intent ( in ) :: r real ( dp ) :: val if ( r > max_range ( ps % local % vlocal )) then ! There should be a sanity check upon parsing ! to guarantee that the coulomb behavior has ! been reached at the end of the grid range val = - ps_ZPseudo ( ps ) / r else val = eval_radfunc ( ps % local % vlocal , r , debug = global_debug ) endif end function ps_LocalPotential_Value","tags":"","loc":"proc/ps_localpotential_value.html","title":"ps_LocalPotential_Value – libPSML"},{"text":"public function ps_LocalCharge_Value(ps, r) result(val) Arguments Type Intent Optional Attributes Name type( ps_t ), intent(in) :: ps real(kind=dp), intent(in) :: r Return Value real(kind=dp) Source Code ps_LocalCharge_Value Source Code function ps_LocalCharge_Value ( ps , r ) result ( val ) type ( ps_t ), intent ( in ) :: ps real ( dp ), intent ( in ) :: r real ( dp ) :: val if ( r > max_range ( ps % local % chlocal )) then ! There should be a sanity check upon parsing ! to guarantee that the coulomb behavior has ! been reached at the end of the grid range val = 0.0_dp else val = eval_radfunc ( ps % local % chlocal , r , debug = global_debug ) endif end function ps_LocalCharge_Value","tags":"","loc":"proc/ps_localcharge_value.html","title":"ps_LocalCharge_Value – libPSML"},{"text":"public function ps_LocalPotential_Type(ps) result(type) Arguments Type Intent Optional Attributes Name type( ps_t ), intent(in) :: ps Return Value character(len=40) Source Code ps_LocalPotential_Type Source Code function ps_LocalPotential_Type ( ps ) result ( type ) type ( ps_t ), intent ( in ) :: ps character ( len = 40 ) :: type type = ps % local % vlocal_type ! end function ps_LocalPotential_Type","tags":"","loc":"proc/ps_localpotential_type.html","title":"ps_LocalPotential_Type – libPSML"},{"text":"public function ps_Projector_L(ps, i) result(l) Arguments Type Intent Optional Attributes Name type( ps_t ), intent(in) :: ps integer, intent(in) :: i Return Value integer Source Code ps_Projector_L Source Code function ps_Projector_L ( ps , i ) result ( l ) type ( ps_t ), intent ( in ) :: ps integer , intent ( in ) :: i integer :: l call check_index ( i , size ( ps % nl_table ), \"proj\" ) l = l_of_sym ( ps % nl_table ( i )% p % l , \"proj\" ) end function ps_Projector_L","tags":"","loc":"proc/ps_projector_l.html","title":"ps_Projector_L – libPSML"},{"text":"public function ps_Projector_J(ps, i) result(j) Arguments Type Intent Optional Attributes Name type( ps_t ), intent(in) :: ps integer, intent(in) :: i Return Value real(kind=dp) Source Code ps_Projector_J Source Code function ps_Projector_J ( ps , i ) result ( j ) type ( ps_t ), intent ( in ) :: ps integer , intent ( in ) :: i real ( dp ) :: j call check_index ( i , size ( ps % nl_table ), \"proj\" ) if ( iand ( ps % nl_table ( i )% p % set , & SET_LJ + SET_USER1 + SET_USER2 ) & == 0 ) then call die ( \"Attempt to get j from wrong set\" ) endif j = ps % nl_table ( i )% p % j end function ps_Projector_J","tags":"","loc":"proc/ps_projector_j.html","title":"ps_Projector_J – libPSML"},{"text":"public function ps_Projector_Ekb(ps, i) result(ekb) Arguments Type Intent Optional Attributes Name type( ps_t ), intent(in) :: ps integer, intent(in) :: i Return Value real(kind=dp) Source Code ps_Projector_Ekb Source Code function ps_Projector_Ekb ( ps , i ) result ( ekb ) type ( ps_t ), intent ( in ) :: ps integer , intent ( in ) :: i real ( dp ) :: ekb call check_index ( i , size ( ps % nl_table ), \"proj\" ) ekb = ps % nl_table ( i )% p % ekb end function ps_Projector_Ekb","tags":"","loc":"proc/ps_projector_ekb.html","title":"ps_Projector_Ekb – libPSML"},{"text":"public function ps_Projector_Seq(ps, i) result(seq) Arguments Type Intent Optional Attributes Name type( ps_t ), intent(in) :: ps integer, intent(in) :: i Return Value integer Source Code ps_Projector_Seq Source Code function ps_Projector_Seq ( ps , i ) result ( seq ) type ( ps_t ), intent ( in ) :: ps integer , intent ( in ) :: i integer :: seq call check_index ( i , size ( ps % nl_table ), \"proj\" ) seq = ps % nl_table ( i )% p % seq end function ps_Projector_Seq","tags":"","loc":"proc/ps_projector_seq.html","title":"ps_Projector_Seq – libPSML"},{"text":"public function ps_Projector_Set(ps, i) result(set) Arguments Type Intent Optional Attributes Name type( ps_t ), intent(in) :: ps integer, intent(in) :: i Return Value integer Source Code ps_Projector_Set Source Code function ps_Projector_Set ( ps , i ) result ( set ) type ( ps_t ), intent ( in ) :: ps integer , intent ( in ) :: i integer :: set call check_index ( i , size ( ps % nl_table ), \"proj\" ) set = ps % nl_table ( i )% p % set ! end function ps_Projector_Set","tags":"","loc":"proc/ps_projector_set.html","title":"ps_Projector_Set – libPSML"},{"text":"public function ps_Projector_Type(ps, i) result(type) Arguments Type Intent Optional Attributes Name type( ps_t ), intent(in) :: ps integer, intent(in) :: i Return Value character(len=40) Source Code ps_Projector_Type Source Code function ps_Projector_Type ( ps , i ) result ( type ) type ( ps_t ), intent ( in ) :: ps integer , intent ( in ) :: i character ( len = 40 ) :: type call check_index ( i , size ( ps % nl_table ), \"proj\" ) type = ps % nl_table ( i )% p % type ! end function ps_Projector_Type","tags":"","loc":"proc/ps_projector_type.html","title":"ps_Projector_Type – libPSML"},{"text":"public function ps_Projector_Value(ps, i, r) result(val) Arguments Type Intent Optional Attributes Name type( ps_t ), intent(in) :: ps integer, intent(in) :: i real(kind=dp), intent(in) :: r Return Value real(kind=dp) Source Code ps_Projector_Value Source Code function ps_Projector_Value ( ps , i , r ) result ( val ) !+ display: private type ( ps_t ), intent ( in ) :: ps integer , intent ( in ) :: i real ( dp ), intent ( in ) :: r real ( dp ) :: val call check_index ( i , size ( ps % nl_table ), \"proj\" ) if ( r > max_range ( ps % nl_table ( i )% p % proj )) then val = 0.0_dp else val = eval_radfunc ( ps % nl_table ( i )% p % proj , r , debug = global_debug ) endif end function ps_Projector_Value","tags":"","loc":"proc/ps_projector_value.html","title":"ps_Projector_Value – libPSML"},{"text":"private function l_of_sym(str, name) result(l) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: str character(len=*), intent(in) :: name Return Value integer Source Code l_of_sym Source Code function l_of_sym ( str , name ) result ( l ) character ( len =* ), intent ( in ) :: str , name integer :: l ! ! This routine will disappear once we store ! l as integer in the data structure ! do l = 0 , 4 if ( str == sym ( l )) RETURN enddo call die ( \"Wrong l symbol in \" // trim ( name )) end function l_of_sym","tags":"","loc":"proc/l_of_sym.html","title":"l_of_sym – libPSML"},{"text":"private function max_range(f) result(range) Returns the maximum radius in a radfunc's grid Arguments Type Intent Optional Attributes Name type( radfunc_t ), intent(in) :: f Return Value real(kind=dp) Source Code max_range Source Code function max_range ( f ) result ( range ) type ( radfunc_t ), intent ( in ) :: f real ( dp ) :: range real ( dp ), pointer :: a (:) integer :: npts npts = sizeGrid ( f % grid ) a => valGrid ( f % grid ) range = a ( npts ) end function max_range","tags":"","loc":"proc/max_range.html","title":"max_range – libPSML"},{"text":"private function eval_radfunc(f, r, debug) result(val) Uses: m_interp Arguments Type Intent Optional Attributes Name type( radfunc_t ), intent(in) :: f real(kind=dp), intent(in) :: r logical, intent(in) :: debug Return Value real(kind=dp) Source Code eval_radfunc Source Code function eval_radfunc ( f , r , debug ) result ( val ) use m_interp , only : interpolator , nq type ( radfunc_t ), intent ( in ) :: f real ( dp ), intent ( in ) :: r real ( dp ) :: val logical , intent ( in ) :: debug real ( dp ), pointer :: x (:) => null (), y (:) => null () x => valGrid ( f % grid ) y => f % data (:) call interpolator ( nq , x , y , size ( x ), r , val , debug ) end function eval_radfunc","tags":"","loc":"proc/eval_radfunc.html","title":"eval_radfunc – libPSML"},{"text":"private function atomic_number(SYMBOL) result(Z) Arguments Type Intent Optional Attributes Name character(len=2), intent(in) :: SYMBOL Return Value integer Source Code atomic_number Source Code FUNCTION atomic_number ( SYMBOL ) result ( z ) ! Given the atomic symbol, it returns the atomic number ! Based on code by J. Soler character ( len = 2 ), intent ( in ) :: SYMBOL ! Atomic symbol integer :: Z ! Atomic number integer , parameter :: NZ = 103 character ( len = 2 ), parameter :: NAME ( NZ ) = & ( / 'H ' , 'He' , 'Li' , 'Be' , 'B ' , 'C ' , 'N ' , 'O ' , 'F ' , 'Ne' , & 'Na' , 'Mg' , 'Al' , 'Si' , 'P ' , 'S ' , 'Cl' , 'Ar' , 'K ' , 'Ca' , & 'Sc' , 'Ti' , 'V ' , 'Cr' , 'Mn' , 'Fe' , 'Co' , 'Ni' , 'Cu' , 'Zn' , & 'Ga' , 'Ge' , 'As' , 'Se' , 'Br' , 'Kr' , 'Rb' , 'Sr' , 'Y ' , 'Zr' , & 'Nb' , 'Mo' , 'Tc' , 'Ru' , 'Rh' , 'Pd' , 'Ag' , 'Cd' , 'In' , 'Sn' , & 'Sb' , 'Te' , 'I ' , 'Xe' , 'Cs' , 'Ba' , 'La' , 'Ce' , 'Pr' , 'Nd' , & 'Pm' , 'Sm' , 'Eu' , 'Gd' , 'Tb' , 'Dy' , 'Ho' , 'Er' , 'Tm' , 'Yb' , & 'Lu' , 'Hf' , 'Ta' , 'W ' , 'Re' , 'Os' , 'Ir' , 'Pt' , 'Au' , 'Hg' , & 'Tl' , 'Pb' , 'Bi' , 'Po' , 'At' , 'Rn' , 'Fr' , 'Ra' , 'Ac' , 'Th' , & 'Pa' , 'U ' , 'Np' , 'Pu' , 'Am' , 'Cm' , 'Bk' , 'Cf' , 'Es' , 'Fm' , & 'Md' , 'No' , 'Lr' / ) do z = 1 , NZ if ( SYMBOL == NAME ( Z )) then RETURN endif enddo call die ( \"Cannot find atomic number for \" // symbol ) end FUNCTION atomic_number","tags":"","loc":"proc/atomic_number.html","title":"atomic_number – libPSML"},{"text":"public subroutine ps_SetDebug(debug) Sets the global debug flag\n @param debug:logical Arguments Type Intent Optional Attributes Name logical, intent(in) :: debug Source Code ps_SetDebug Source Code subroutine ps_SetDebug ( debug ) logical , intent ( in ) :: debug global_debug = debug end subroutine ps_SetDebug","tags":"","loc":"proc/ps_setdebug.html","title":"ps_SetDebug – libPSML"},{"text":"public subroutine ps_SetInterpolator(func, nquality) Uses: m_interp Sets the default interpolator and\n its quality parameter Arguments Type Intent Optional Attributes Name public subroutine func(nquality, x, y, npts, r, val, debug) Arguments Type Intent Optional Attributes Name integer, intent(in) :: nquality real(kind=dp), intent(in) :: x (*) real(kind=dp), intent(in) :: y (*) integer, intent(in) :: npts real(kind=dp), intent(in) :: r real(kind=dp), intent(out) :: val logical, intent(in) :: debug integer, intent(in) :: nquality Source Code ps_SetInterpolator Source Code subroutine ps_SetInterpolator ( func , nquality ) use m_interp , only : interpolator , nq ! Parameter for interpolator's quality ! It might mean different things for different ! interpolators integer , intent ( in ) :: nquality interface subroutine func ( nquality , x , y , npts , r , val , debug ) integer , parameter :: dp = selected_real_kind ( 10 , 100 ) integer , intent ( in ) :: nquality ! Quality parameter real ( dp ), intent ( in ) :: x ( * ), y ( * ) integer , intent ( in ) :: npts ! Size of x, y arrays real ( dp ), intent ( in ) :: r real ( dp ), intent ( out ) :: val logical , intent ( in ) :: debug end subroutine func end interface interpolator => func nq = nquality end subroutine ps_SetInterpolator","tags":"","loc":"proc/ps_setinterpolator.html","title":"ps_SetInterpolator – libPSML"},{"text":"public subroutine ps_SetInterpolatorQuality(nquality) Uses: m_interp Sets the quality parameter of the current\n default interpolator. Useful when we do\n not care about the type of evaluator, but\n want to compare different qualities Arguments Type Intent Optional Attributes Name integer, intent(in) :: nquality Source Code ps_SetInterpolatorQuality Source Code subroutine ps_SetInterpolatorQuality ( nquality ) use m_interp , only : nq ! Parameter for interpolator's quality ! It might mean different things for different ! interpolators integer , intent ( in ) :: nquality nq = nquality end subroutine ps_SetInterpolatorQuality","tags":"","loc":"proc/ps_setinterpolatorquality.html","title":"ps_SetInterpolatorQuality – libPSML"},{"text":"public subroutine ps_ValenceCharge_GetRawData(ps, raw_r, raw_data) Arguments Type Intent Optional Attributes Name type( ps_t ), intent(in) :: ps real(kind=dp), intent(out), allocatable :: raw_r (:) real(kind=dp), intent(out), allocatable :: raw_data (:) Source Code ps_ValenceCharge_GetRawData Source Code subroutine ps_ValenceCharge_GetRawData ( ps , raw_r , raw_data ) type ( ps_t ), intent ( in ) :: ps real ( dp ), allocatable , intent ( out ) :: raw_r (:), raw_data (:) call get_raw_radfunc ( ps % valence_charge % rho_val , raw_r , raw_data ) end subroutine ps_ValenceCharge_GetRawData","tags":"","loc":"proc/ps_valencecharge_getrawdata.html","title":"ps_ValenceCharge_GetRawData – libPSML"},{"text":"public subroutine ps_CoreCharge_GetRawData(ps, raw_r, raw_data) Arguments Type Intent Optional Attributes Name type( ps_t ), intent(in) :: ps real(kind=dp), intent(out), allocatable :: raw_r (:) real(kind=dp), intent(out), allocatable :: raw_data (:) Source Code ps_CoreCharge_GetRawData Source Code subroutine ps_CoreCharge_GetRawData ( ps , raw_r , raw_data ) type ( ps_t ), intent ( in ) :: ps real ( dp ), allocatable , intent ( out ) :: raw_r (:), raw_data (:) call get_raw_radfunc ( ps % core_charge % rho_core , raw_r , raw_data ) end subroutine ps_CoreCharge_GetRawData","tags":"","loc":"proc/ps_corecharge_getrawdata.html","title":"ps_CoreCharge_GetRawData – libPSML"},{"text":"public subroutine ps_Get_Potential_Indexes(ps, set, indexes) Arguments Type Intent Optional Attributes Name type( ps_t ), intent(in) :: ps integer, intent(in) :: set integer, intent(inout), allocatable :: indexes (:) Source Code ps_Get_Potential_Indexes Source Code subroutine ps_Get_Potential_Indexes ( ps , set , indexes ) type ( ps_t ), intent ( in ) :: ps integer , intent ( in ) :: set integer , allocatable , intent ( inout ) :: indexes (:) integer :: i , n n = 0 do i = 1 , size ( ps % sl_table ) if ( iand ( ps % sl_table ( i )% p % set , set ) /= 0 ) n = n + 1 enddo if ( allocated ( indexes )) deallocate ( indexes ) allocate ( indexes ( n )) n = 0 do i = 1 , size ( ps % sl_table ) if ( iand ( ps % sl_table ( i )% p % set , set ) /= 0 ) then n = n + 1 indexes ( n ) = i end if enddo end subroutine ps_Get_Potential_Indexes","tags":"","loc":"proc/ps_get_potential_indexes.html","title":"ps_Get_Potential_Indexes – libPSML"},{"text":"public subroutine ps_Get_Projector_Indexes(ps, set, indexes) Arguments Type Intent Optional Attributes Name type( ps_t ), intent(in) :: ps integer, intent(in) :: set integer, intent(inout), allocatable :: indexes (:) Source Code ps_Get_Projector_Indexes Source Code subroutine ps_Get_Projector_Indexes ( ps , set , indexes ) type ( ps_t ), intent ( in ) :: ps integer , intent ( in ) :: set integer , allocatable , intent ( inout ) :: indexes (:) integer :: i , n n = 0 do i = 1 , size ( ps % nl_table ) if ( iand ( ps % nl_table ( i )% p % set , set ) /= 0 ) n = n + 1 enddo if ( allocated ( indexes )) deallocate ( indexes ) allocate ( indexes ( n )) n = 0 do i = 1 , size ( ps % nl_table ) if ( iand ( ps % nl_table ( i )% p % set , set ) /= 0 ) then n = n + 1 indexes ( n ) = i end if enddo end subroutine ps_Get_Projector_Indexes","tags":"","loc":"proc/ps_get_projector_indexes.html","title":"ps_Get_Projector_Indexes – libPSML"},{"text":"public subroutine ps_Get_PseudoWf_Indexes(ps, set, indexes) Arguments Type Intent Optional Attributes Name type( ps_t ), intent(in) :: ps integer, intent(in) :: set integer, intent(inout), allocatable :: indexes (:) Source Code ps_Get_PseudoWf_Indexes Source Code subroutine ps_Get_PseudoWf_Indexes ( ps , set , indexes ) type ( ps_t ), intent ( in ) :: ps integer , intent ( in ) :: set integer , allocatable , intent ( inout ) :: indexes (:) call GetSetIndexes ( ps % pswfs % npswfs , ps % pswfs % set , set , indexes ) end subroutine ps_Get_PseudoWf_Indexes","tags":"","loc":"proc/ps_get_pseudowf_indexes.html","title":"ps_Get_PseudoWf_Indexes – libPSML"},{"text":"public subroutine ps_Potential_GetRawData(ps, i, raw_r, raw_data) Arguments Type Intent Optional Attributes Name type( ps_t ), intent(in) :: ps integer, intent(in) :: i real(kind=dp), intent(out), allocatable :: raw_r (:) real(kind=dp), intent(out), allocatable :: raw_data (:) Source Code ps_Potential_GetRawData Source Code subroutine ps_Potential_GetRawData ( ps , i , raw_r , raw_data ) type ( ps_t ), intent ( in ) :: ps integer , intent ( in ) :: i real ( dp ), allocatable , intent ( out ) :: raw_r (:), raw_data (:) call get_raw_radfunc ( ps % sl_table ( i )% p % V , raw_r , raw_data ) end subroutine ps_Potential_GetRawData","tags":"","loc":"proc/ps_potential_getrawdata.html","title":"ps_Potential_GetRawData – libPSML"},{"text":"public subroutine ps_PseudoWf_GetRawData(ps, i, raw_r, raw_data) Arguments Type Intent Optional Attributes Name type( ps_t ), intent(in) :: ps integer, intent(in) :: i real(kind=dp), intent(out), allocatable :: raw_r (:) real(kind=dp), intent(out), allocatable :: raw_data (:) Source Code ps_PseudoWf_GetRawData Source Code subroutine ps_PseudoWf_GetRawData ( ps , i , raw_r , raw_data ) type ( ps_t ), intent ( in ) :: ps integer , intent ( in ) :: i real ( dp ), allocatable , intent ( out ) :: raw_r (:), raw_data (:) call get_raw_radfunc ( ps % pswfs % Phi ( i ), raw_r , raw_data ) end subroutine ps_PseudoWf_GetRawData","tags":"","loc":"proc/ps_pseudowf_getrawdata.html","title":"ps_PseudoWf_GetRawData – libPSML"},{"text":"public subroutine ps_LocalPotential_GetRawData(ps, raw_r, raw_data) Arguments Type Intent Optional Attributes Name type( ps_t ), intent(in) :: ps real(kind=dp), intent(out), allocatable :: raw_r (:) real(kind=dp), intent(out), allocatable :: raw_data (:) Source Code ps_LocalPotential_GetRawData Source Code subroutine ps_LocalPotential_GetRawData ( ps , raw_r , raw_data ) type ( ps_t ), intent ( in ) :: ps real ( dp ), allocatable , intent ( out ) :: raw_r (:), raw_data (:) call get_raw_radfunc ( ps % local % vlocal , raw_r , raw_data ) end subroutine ps_LocalPotential_GetRawData","tags":"","loc":"proc/ps_localpotential_getrawdata.html","title":"ps_LocalPotential_GetRawData – libPSML"},{"text":"public subroutine ps_Projector_GetRawData(ps, i, raw_r, raw_data) Deprecated Arguments Type Intent Optional Attributes Name type( ps_t ), intent(in) :: ps integer, intent(in) :: i real(kind=dp), intent(out), allocatable :: raw_r (:) real(kind=dp), intent(out), allocatable :: raw_data (:) Source Code ps_Projector_GetRawData Source Code subroutine ps_Projector_GetRawData ( ps , i , raw_r , raw_data ) !+ deprecated: true type ( ps_t ), intent ( in ) :: ps integer , intent ( in ) :: i real ( dp ), allocatable , intent ( out ) :: raw_r (:), raw_data (:) call get_raw_radfunc ( ps % nl_table ( i )% p % proj , raw_r , raw_data ) end subroutine ps_Projector_GetRawData","tags":"","loc":"proc/ps_projector_getrawdata.html","title":"ps_Projector_GetRawData – libPSML"},{"text":"public subroutine ps_Get_Projector_Indexes_byL(ps, l, idxset, idxl) Subset of projectors with given l\n Note that this function takes an array of indexes\n and returns another array of indexes\n There is currently no way to check that the idxset\n really corresponds to projectors... Arguments Type Intent Optional Attributes Name type( ps_t ), intent(in) :: ps integer, intent(in) :: l integer, intent(in) :: idxset (:) integer, intent(inout), allocatable :: idxl (:) Source Code ps_Get_Projector_Indexes_byL Source Code subroutine ps_Get_Projector_Indexes_byL ( ps , l , idxset , idxl ) !* Subset of projectors with given l ! Note that this function takes an array of indexes ! and returns another array of indexes ! There is currently no way to check that the idxset ! really corresponds to projectors... type ( ps_t ), intent ( in ) :: ps integer , intent ( in ) :: l integer , intent ( in ) :: idxset (:) integer , allocatable , intent ( inout ) :: idxl (:) integer :: n integer :: n_in_set , i , l_i n_in_set = size ( idxset ) n = 0 do i = 1 , n_in_set l_i = ps_Projector_L ( ps , idxset ( i )) if ( l_i == l ) n = n + 1 enddo if ( allocated ( idxl )) deallocate ( idxl ) allocate ( idxl ( n )) n = 0 do i = 1 , n_in_set l_i = ps_Projector_L ( ps , idxset ( i )) if ( l_i == l ) then n = n + 1 idxl ( n ) = idxset ( i ) endif enddo end subroutine ps_Get_Projector_Indexes_byL","tags":"","loc":"proc/ps_get_projector_indexes_byl.html","title":"ps_Get_Projector_Indexes_byL – libPSML"},{"text":"private subroutine GetSetIndexes(nitems, setarray, set, indexes) Arguments Type Intent Optional Attributes Name integer, intent(in) :: nitems integer, intent(in) :: setarray (:) integer, intent(in) :: set integer, intent(inout), allocatable :: indexes (:) Source Code GetSetIndexes Source Code subroutine GetSetIndexes ( nitems , setarray , set , indexes ) integer , intent ( in ) :: nitems integer , intent ( in ) :: setarray (:) integer , intent ( in ) :: set integer , allocatable , intent ( inout ) :: indexes (:) integer :: n , i n = 0 do i = 1 , nitems if ( iand ( setarray ( i ), set ) /= 0 ) n = n + 1 enddo if ( allocated ( indexes )) deallocate ( indexes ) allocate ( indexes ( n )) n = 0 do i = 1 , nitems if ( iand ( setarray ( i ), set ) /= 0 ) then n = n + 1 indexes ( n ) = i end if enddo end subroutine GetSetIndexes","tags":"","loc":"proc/getsetindexes.html","title":"GetSetIndexes – libPSML"},{"text":"private subroutine check_index(i, n, str) Arguments Type Intent Optional Attributes Name integer, intent(in) :: i integer, intent(in) :: n character(len=*), intent(in) :: str Source Code check_index Source Code subroutine check_index ( i , n , str ) integer , intent ( in ) :: i , n character ( len =* ), intent ( in ) :: str call assert ( ( i <= n ), \"Index overflow in \" // trim ( str )) call assert ( ( i > 0 ), \"Non-positive index in \" // trim ( str )) end subroutine check_index","tags":"","loc":"proc/check_index.html","title":"check_index – libPSML"},{"text":"private subroutine get_raw_radfunc(f, raw_r, raw_data) Arguments Type Intent Optional Attributes Name type( radfunc_t ), intent(in) :: f real(kind=dp), intent(out), allocatable :: raw_r (:) real(kind=dp), intent(out), allocatable :: raw_data (:) Source Code get_raw_radfunc Source Code subroutine get_raw_radfunc ( f , raw_r , raw_data ) ! type ( radfunc_t ), intent ( in ) :: f real ( dp ), intent ( out ), allocatable :: raw_r (:) real ( dp ), intent ( out ), allocatable :: raw_data (:) integer npts real ( dp ), pointer :: a (:) npts = sizeGrid ( f % grid ) allocate ( raw_r ( npts ), raw_data ( npts )) a => valGrid ( f % grid ) raw_r (:) = a (:) raw_data (:) = f % data (:) end subroutine get_raw_radfunc","tags":"","loc":"proc/get_raw_radfunc.html","title":"get_raw_radfunc – libPSML"},{"text":"private subroutine assert(cond, message) Arguments Type Intent Optional Attributes Name logical, intent(in) :: cond character(len=*) :: message Source Code assert Source Code subroutine assert ( cond , message ) logical , intent ( in ) :: cond character ( len =* ) message if (. not . cond ) call die ( message ) end subroutine assert","tags":"","loc":"proc/assert.html","title":"assert – libPSML"},{"text":"public function setcode_of_string(str) result(code) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: str Return Value integer Source Code setcode_of_string Source Code function setcode_of_string ( str ) result ( code ) character ( len =* ), intent ( in ) :: str integer :: code select case ( trim ( str )) case ( \"non_relativistic\" ) code = SET_NONREL case ( \"scalar_relativistic\" ) code = SET_SREL case ( \"spin_orbit\" ) code = SET_SO case ( \"lj\" ) code = SET_LJ case ( \"spin_up\" ) code = SET_UP case ( \"spin_down\" ) code = SET_DOWN case ( \"spin_average\" ) code = SET_SPINAVE case ( \"spin_difference\" ) code = SET_SPINDIFF case ( \"user_extension1\" ) code = SET_USER1 case ( \"user_extension2\" ) code = SET_USER2 case ( \"all\" , \"any\" ) code = SET_ALL case ( \"invalid\" , \"INVALID\" ) code = SET_NULL case default call die ( \"Wrong set string: \" // trim ( str )) end select end function setcode_of_string","tags":"","loc":"proc/setcode_of_string.html","title":"setcode_of_string – libPSML"},{"text":"public function str_of_set(code) result(str) Arguments Type Intent Optional Attributes Name integer, intent(in) :: code Return Value character(len=20) Source Code str_of_set Source Code function str_of_set ( code ) result ( str ) integer , intent ( in ) :: code character ( len = 20 ) :: str character ( len = 100 ) :: msg select case ( code ) case ( SET_NONREL ) str = \"non_relativistic\" case ( SET_SREL ) str = \"scalar_relativistic\" case ( SET_SO ) str = \"spin_orbit\" case ( SET_LJ ) str = \"lj\" case ( SET_UP ) str = \"spin_up\" case ( SET_DOWN ) str = \"spin_down\" case ( SET_SPINAVE ) str = \"spin_average\" case ( SET_SPINDIFF ) str = \"spin_difference\" case ( SET_USER1 ) str = \"user_extension1\" case ( SET_USER2 ) str = \"user_extension2\" case ( SET_ALL ) str = \"all\" case ( SET_NULL ) str = \"invalid\" case default write ( msg , \"(a,i4)\" ) \"Wrong set code: \" , code call die ( msg ) end select end function str_of_set","tags":"","loc":"proc/str_of_set.html","title":"str_of_set – libPSML"},{"text":"public subroutine ps_destroy(ps) Arguments Type Intent Optional Attributes Name type( ps_t ), intent(inout) :: ps Source Code ps_destroy Source Code subroutine ps_destroy ( ps ) !! Cleans the ps object type ( ps_t ), intent ( inout ) :: ps integer :: i call ps_clean_annotation ( ps % annotation ) call destroy_provenance ( ps % provenance ) call ps_clean_annotation ( ps % config_val % annotation ) call destroy_xc ( ps % xc_info ) ! ! Note that freshly declared objects must have ! npots = 0 and npswfs = 0 ! ! call destroy_semilocal ( ps % semilocal ) call destroy_nonlocal ( ps % nonlocal ) ! call destroy_local ( ps % local ) ! do i = 1 , ps % pswfs % npswfs call destroy_radfunc ( ps % pswfs % Phi ( i )) enddo call delete ( ps % pswfs % grid ) call ps_clean_annotation ( ps % pswfs % annotation ) ! call destroy_radfunc ( ps % valence_charge % rho_val ) call ps_clean_annotation ( ps % valence_charge % annotation ) ! call destroy_radfunc ( ps % core_charge % rho_core ) call ps_clean_annotation ( ps % core_charge % annotation ) ! call delete ( ps % global_grid ) end subroutine ps_destroy","tags":"","loc":"proc/ps_destroy.html","title":"ps_destroy – libPSML"},{"text":"private subroutine destroy_provenance(p) Arguments Type Intent Optional Attributes Name type( provenance_t ), pointer :: p Source Code destroy_provenance Source Code subroutine destroy_provenance ( p ) type ( provenance_t ), pointer :: p type ( provenance_t ), pointer :: q do while ( associated ( p )) call ps_clean_annotation ( p % annotation ) ! clean buffers for input files? q => p % next deallocate ( p ) p => q enddo end subroutine destroy_provenance","tags":"","loc":"proc/destroy_provenance.html","title":"destroy_provenance – libPSML"},{"text":"private subroutine destroy_semilocal(p) Arguments Type Intent Optional Attributes Name type( semilocal_t ), pointer :: p Source Code destroy_semilocal Source Code subroutine destroy_semilocal ( p ) type ( semilocal_t ), pointer :: p type ( semilocal_t ), pointer :: q do while ( associated ( p )) call ps_clean_annotation ( p % annotation ) call destroy_slps ( p % pot ) call delete ( p % grid ) q => p % next deallocate ( p ) p => q enddo end subroutine destroy_semilocal","tags":"","loc":"proc/destroy_semilocal.html","title":"destroy_semilocal – libPSML"},{"text":"private subroutine destroy_slps(p) Arguments Type Intent Optional Attributes Name type( slps_t ), pointer :: p Source Code destroy_slps Source Code subroutine destroy_slps ( p ) type ( slps_t ), pointer :: p type ( slps_t ), pointer :: q do while ( associated ( p )) call destroy_radfunc ( p % V ) q => p % next deallocate ( p ) p => q enddo end subroutine destroy_slps","tags":"","loc":"proc/destroy_slps.html","title":"destroy_slps – libPSML"},{"text":"public subroutine destroy_local(p) Arguments Type Intent Optional Attributes Name type( local_t ) :: p Source Code destroy_local Source Code subroutine destroy_local ( p ) type ( local_t ) :: p call ps_clean_annotation ( p % annotation ) call delete ( p % grid ) call destroy_radfunc ( p % vlocal ) call destroy_radfunc ( p % chlocal ) end subroutine destroy_local","tags":"","loc":"proc/destroy_local.html","title":"destroy_local – libPSML"},{"text":"public subroutine destroy_nonlocal(p) Arguments Type Intent Optional Attributes Name type( nonlocal_t ), pointer :: p Source Code destroy_nonlocal Source Code subroutine destroy_nonlocal ( p ) type ( nonlocal_t ), pointer :: p type ( nonlocal_t ), pointer :: q do while ( associated ( p )) call ps_clean_annotation ( p % annotation ) call destroy_nlpj ( p % proj ) call delete ( p % grid ) q => p % next deallocate ( p ) p => q enddo end subroutine destroy_nonlocal","tags":"","loc":"proc/destroy_nonlocal.html","title":"destroy_nonlocal – libPSML"},{"text":"private subroutine destroy_nlpj(p) Arguments Type Intent Optional Attributes Name type( nlpj_t ), pointer :: p Source Code destroy_nlpj Source Code subroutine destroy_nlpj ( p ) type ( nlpj_t ), pointer :: p type ( nlpj_t ), pointer :: q do while ( associated ( p )) call destroy_radfunc ( p % proj ) q => p % next deallocate ( p ) p => q enddo end subroutine destroy_nlpj","tags":"","loc":"proc/destroy_nlpj.html","title":"destroy_nlpj – libPSML"},{"text":"private subroutine destroy_radfunc(rp) Arguments Type Intent Optional Attributes Name type( radfunc_t ) :: rp Source Code destroy_radfunc Source Code subroutine destroy_radfunc ( rp ) type ( radfunc_t ) :: rp call delete ( rp % grid ) if ( associated ( rp % data )) then deallocate ( rp % data ) rp % data => null () endif end subroutine destroy_radfunc","tags":"","loc":"proc/destroy_radfunc.html","title":"destroy_radfunc – libPSML"},{"text":"private subroutine destroy_xc(xp) Arguments Type Intent Optional Attributes Name type( xc_t ), intent(inout) :: xp Source Code destroy_xc Source Code subroutine destroy_xc ( xp ) type ( xc_t ), intent ( inout ) :: xp if ( allocated ( xp % libxc_name )) deallocate ( xp % libxc_name ) if ( allocated ( xp % libxc_type )) deallocate ( xp % libxc_type ) if ( allocated ( xp % libxc_id )) deallocate ( xp % libxc_id ) if ( allocated ( xp % libxc_weight )) deallocate ( xp % libxc_weight ) call ps_clean_annotation ( xp % annotation ) end subroutine destroy_xc","tags":"","loc":"proc/destroy_xc.html","title":"destroy_xc – libPSML"},{"text":"public subroutine ps_DumpToPSMLFile(ps, fname, indent) Uses: xmlf90_wxml Arguments Type Intent Optional Attributes Name type( ps_t ), intent(in) :: ps character(len=*), intent(in) :: fname logical, intent(in), optional :: indent Source Code ps_DumpToPSMLFile Source Code subroutine ps_DumpToPSMLFile ( ps , fname , indent ) use xmlf90_wxml type ( ps_t ), intent ( in ) :: ps character ( len =* ), intent ( in ) :: fname logical , intent ( in ), optional :: indent type ( xmlf_t ) :: xf call xml_OpenFile ( trim ( fname ), xf , indent ) call xml_AddXMLDeclaration ( xf , \"UTF-8\" ) call xml_NewElement ( xf , \"psml\" ) call my_add_attribute ( xf , \"version\" , trim ( ps % version )) call my_add_attribute ( xf , \"energy_unit\" , trim ( ps % energy_unit )) call my_add_attribute ( xf , \"length_unit\" , trim ( ps % length_unit )) call my_add_attribute ( xf , \"uuid\" , ps % uuid ) call dump_annotation ( xf , ps % annotation ) call dump_provenance ( xf , ps % provenance ) call dump_header ( xf , ps ) if ( initialized ( ps % global_grid )) then call dump_grid ( xf , ps % global_grid ) endif call dump_semilocal_potentials ( xf , ps ) call dump_valence_charge ( xf , ps % valence_charge , ps % global_grid ) call dump_local_potential ( xf , ps ) call dump_nonlocal_projectors ( xf , ps ) call dump_pseudo_wavefunctions ( xf , ps ) if ( trim ( ps % header % core_corrections ) == \"yes\" ) then call dump_core_charge ( xf , ps % core_charge , ps % global_grid ) endif call xml_EndElement ( xf , \"psml\" ) call xml_Close ( xf ) end subroutine ps_DumpToPSMLFile","tags":"","loc":"proc/ps_dumptopsmlfile.html","title":"ps_DumpToPSMLFile – libPSML"},{"text":"private subroutine dump_provenance(xf, p) Uses: xmlf90_wxml iso_varying_string Arguments Type Intent Optional Attributes Name type(xmlf_t), intent(inout) :: xf type( provenance_t ), pointer :: p Source Code dump_provenance Source Code subroutine dump_provenance ( xf , p ) use xmlf90_wxml use iso_varying_string , only : put , len , char type ( xmlf_t ), intent ( inout ) :: xf type ( provenance_t ), pointer :: p do while ( associated ( p )) call xml_NewElement ( xf , \"provenance\" ) call my_add_attribute ( xf , \"creator\" , trim ( p % creator )) call my_add_attribute ( xf , \"date\" , trim ( p % date )) if ( len ( p % input_file % buffer ) > 0 ) then call xml_NewElement ( xf , \"input-file\" ) call my_add_attribute ( xf , \"name\" , trim ( p % input_file % name )) call xml_AddCDataSection ( xf , char ( p % input_file % buffer ), & line_feed = . true .) call xml_EndElement ( xf , \"input-file\" ) endif call dump_annotation ( xf , p % annotation ) call xml_EndElement ( xf , \"provenance\" ) p => p % next end do end subroutine dump_provenance","tags":"","loc":"proc/dump_provenance.html","title":"dump_provenance – libPSML"},{"text":"private subroutine dump_xc_info(xf, p) Uses: xmlf90_wxml Arguments Type Intent Optional Attributes Name type(xmlf_t), intent(inout) :: xf type( xc_t ), intent(in) :: p Source Code dump_xc_info Source Code subroutine dump_xc_info ( xf , p ) use xmlf90_wxml type ( xmlf_t ), intent ( inout ) :: xf type ( xc_t ), intent ( in ) :: p integer :: i call xml_NewElement ( xf , \"exchange-correlation\" ) call dump_annotation ( xf , p % annotation ) call xml_NewElement ( xf , \"libxc-info\" ) call my_add_attribute ( xf , \"number-of-functionals\" , str ( p % n_functs_libxc )) do i = 1 , p % n_functs_libxc call xml_NewElement ( xf , \"functional\" ) call my_add_attribute ( xf , \"name\" , trim ( p % libxc_name ( i ))) if ( trim ( p % libxc_type ( i )) /= \"UNKNOWN\" ) then call my_add_attribute ( xf , \"type\" , trim ( p % libxc_type ( i ))) endif call my_add_attribute ( xf , \"id\" , str ( p % libxc_id ( i ))) if ( p % libxc_weight ( i ) /= 1.0_dp ) then call my_add_attribute ( xf , \"weight\" , str ( p % libxc_weight ( i ))) endif call xml_EndElement ( xf , \"functional\" ) enddo call xml_EndElement ( xf , \"libxc-info\" ) call xml_EndElement ( xf , \"exchange-correlation\" ) end subroutine dump_xc_info","tags":"","loc":"proc/dump_xc_info.html","title":"dump_xc_info – libPSML"},{"text":"private subroutine dump_config_val(xf, p) Uses: xmlf90_wxml Arguments Type Intent Optional Attributes Name type(xmlf_t), intent(inout) :: xf type( config_val_t ), intent(in) :: p Source Code dump_config_val Source Code subroutine dump_config_val ( xf , p ) use xmlf90_wxml type ( xmlf_t ), intent ( inout ) :: xf type ( config_val_t ), intent ( in ) :: p integer :: i call xml_NewElement ( xf , \"valence-configuration\" ) call my_add_attribute ( xf , \"total-valence-charge\" , str ( p % total_charge )) do i = 1 , p % nshells call xml_NewElement ( xf , \"shell\" ) call my_add_attribute ( xf , \"n\" , str ( p % n ( i ))) call my_add_attribute ( xf , \"l\" , p % l ( i )) call my_add_attribute ( xf , \"occupation\" , str ( p % occ ( i ))) if (( p % occ_up ( i ) + p % occ_down ( i )) /= 0.0_dp ) then call my_add_attribute ( xf , \"occupation-down\" , str ( p % occ_down ( i ))) call my_add_attribute ( xf , \"occupation-up\" , str ( p % occ_up ( i ))) endif call xml_EndElement ( xf , \"shell\" ) enddo call dump_annotation ( xf , p % annotation ) call xml_EndElement ( xf , \"valence-configuration\" ) end subroutine dump_config_val","tags":"","loc":"proc/dump_config_val.html","title":"dump_config_val – libPSML"},{"text":"private subroutine dump_header(xf, ps) Uses: xmlf90_wxml Arguments Type Intent Optional Attributes Name type(xmlf_t), intent(inout) :: xf type( ps_t ), intent(in), target :: ps Source Code dump_header Source Code subroutine dump_header ( xf , ps ) use xmlf90_wxml type ( xmlf_t ), intent ( inout ) :: xf type ( ps_t ), intent ( in ), target :: ps type ( header_t ), pointer :: h h => ps % header call xml_NewElement ( xf , \"header\" ) call my_add_attribute ( xf , \"atomic-label\" , trim ( h % atomic_label )) call my_add_attribute ( xf , \"z-pseudo\" , str ( h % zpseudo )) call my_add_attribute ( xf , \"atomic-number\" , str ( h % z )) call my_add_attribute ( xf , \"flavor\" , trim ( h % flavor )) call my_add_attribute ( xf , \"relativity\" , trim ( h % relativity )) if ( h % polarized ) then call my_add_attribute ( xf , \"polarized\" , \"yes\" ) else call my_add_attribute ( xf , \"polarized\" , \"no\" ) endif call my_add_attribute ( xf , \"core-corrections\" , trim ( h % core_corrections )) call dump_xc_info ( xf , ps % xc_info ) call dump_config_val ( xf , ps % config_val ) call xml_EndElement ( xf , \"header\" ) end subroutine dump_header","tags":"","loc":"proc/dump_header.html","title":"dump_header – libPSML"},{"text":"private subroutine dump_radfunc(xf, rf, parent_grid) Uses: xmlf90_wxml Arguments Type Intent Optional Attributes Name type(xmlf_t), intent(inout) :: xf type( radfunc_t ), intent(in) :: rf type(Grid_t) :: parent_grid Source Code dump_radfunc Source Code subroutine dump_radfunc ( xf , rf , parent_grid ) use xmlf90_wxml type ( xmlf_t ), intent ( inout ) :: xf type ( radfunc_t ), intent ( in ) :: rf type ( Grid_t ) :: parent_grid ! Only one level for now if (. not . initialized ( rf % grid )) return call xml_NewElement ( xf , \"radfunc\" ) if ( same ( rf % grid , parent_grid )) then ! do nothing else call dump_grid ( xf , rf % grid ) endif call xml_NewElement ( xf , \"data\" ) call xml_AddArray ( xf , rf % data (:)) call xml_EndElement ( xf , \"data\" ) call xml_EndElement ( xf , \"radfunc\" ) end subroutine dump_radfunc","tags":"","loc":"proc/dump_radfunc.html","title":"dump_radfunc – libPSML"},{"text":"private subroutine dump_valence_charge(xf, val, parent_grid) Uses: xmlf90_wxml Arguments Type Intent Optional Attributes Name type(xmlf_t), intent(inout) :: xf type( valence_charge_t ), intent(in) :: val type(Grid_t) :: parent_grid Source Code dump_valence_charge Source Code subroutine dump_valence_charge ( xf , val , parent_grid ) use xmlf90_wxml type ( xmlf_t ), intent ( inout ) :: xf type ( valence_charge_t ), intent ( in ) :: val type ( Grid_t ) :: parent_grid call xml_NewElement ( xf , \"valence-charge\" ) call my_add_attribute ( xf , \"total-charge\" , str ( val % total_charge )) call dump_annotation ( xf , val % annotation ) call dump_radfunc ( xf , val % rho_val , parent_grid ) call xml_EndElement ( xf , \"valence-charge\" ) end subroutine dump_valence_charge","tags":"","loc":"proc/dump_valence_charge.html","title":"dump_valence_charge – libPSML"},{"text":"private subroutine dump_core_charge(xf, core, parent_grid) Uses: xmlf90_wxml Arguments Type Intent Optional Attributes Name type(xmlf_t), intent(inout) :: xf type( core_charge_t ), intent(in) :: core type(Grid_t) :: parent_grid Source Code dump_core_charge Source Code subroutine dump_core_charge ( xf , core , parent_grid ) use xmlf90_wxml type ( xmlf_t ), intent ( inout ) :: xf type ( core_charge_t ), intent ( in ) :: core type ( Grid_t ) :: parent_grid call xml_NewElement ( xf , \"pseudocore-charge\" ) call my_add_attribute ( xf , \"matching-radius\" , str ( core % rcore )) call my_add_attribute ( xf , \"number-of-continuous-derivatives\" , str ( core % n_cont_derivs )) call dump_annotation ( xf , core % annotation ) call dump_radfunc ( xf , core % rho_core , parent_grid ) call xml_EndElement ( xf , \"pseudocore-charge\" ) end subroutine dump_core_charge","tags":"","loc":"proc/dump_core_charge.html","title":"dump_core_charge – libPSML"},{"text":"private subroutine dump_semilocal_potentials(xf, ps) Uses: xmlf90_wxml Arguments Type Intent Optional Attributes Name type(xmlf_t), intent(inout) :: xf type( ps_t ), intent(in), target :: ps Source Code dump_semilocal_potentials Source Code subroutine dump_semilocal_potentials ( xf , ps ) use xmlf90_wxml type ( xmlf_t ), intent ( inout ) :: xf type ( ps_t ), intent ( in ), target :: ps type ( semilocal_t ), pointer :: slp type ( slps_t ), pointer :: slvp type ( Grid_t ) :: parent_grid integer :: i , j , set slp => ps % semilocal do while ( associated ( slp )) set = slp % set call xml_NewElement ( xf , \"semilocal-potentials\" ) if ( set /= SET_NULL ) then ! Group set was specified call my_add_attribute ( xf , \"set\" , str_of_set ( set )) endif call dump_annotation ( xf , slp % annotation ) if ( initialized ( slp % grid )) then parent_grid = slp % grid call dump_grid ( xf , slp % grid ) else parent_grid = ps % global_grid endif slvp => slp % pot do while ( associated ( slvp )) call xml_NewElement ( xf , \"slps\" ) call my_add_attribute ( xf , \"n\" , str ( slvp % n )) call my_add_attribute ( xf , \"l\" , slvp % l ) call my_add_attribute ( xf , \"rc\" , str ( slvp % rc )) call my_add_attribute ( xf , \"flavor\" , slvp % flavor ) if ( set == SET_LJ ) then call my_add_attribute ( xf , \"j\" , str ( slvp % j )) endif ! Group set was not specified if ( set == SET_NULL ) then call my_add_attribute ( xf , \"set\" , str_of_set ( slvp % set )) endif call dump_radfunc ( xf , slvp % V , parent_grid ) call xml_EndElement ( xf , \"slps\" ) slvp => slvp % next enddo call xml_EndElement ( xf , \"semilocal-potentials\" ) slp => slp % next enddo call delete ( parent_grid ) end subroutine dump_semilocal_potentials","tags":"","loc":"proc/dump_semilocal_potentials.html","title":"dump_semilocal_potentials – libPSML"},{"text":"private subroutine dump_local_potential(xf, ps) Uses: xmlf90_wxml Arguments Type Intent Optional Attributes Name type(xmlf_t), intent(inout) :: xf type( ps_t ), intent(in), target :: ps Source Code dump_local_potential Source Code subroutine dump_local_potential ( xf , ps ) use xmlf90_wxml type ( xmlf_t ), intent ( inout ) :: xf type ( ps_t ), intent ( in ), target :: ps type ( local_t ), pointer :: lop logical :: has_vlocal lop => ps % local has_vlocal = associated ( lop % Vlocal % data ) if ( has_vlocal ) then call xml_NewElement ( xf , \"local-potential\" ) call my_add_attribute ( xf , \"type\" , lop % vlocal_type ) ! No processing of grids here call dump_radfunc ( xf , lop % Vlocal , ps % global_grid ) call dump_radfunc ( xf , lop % chlocal , ps % global_grid ) call xml_EndElement ( xf , \"local-potential\" ) endif end subroutine dump_local_potential","tags":"","loc":"proc/dump_local_potential.html","title":"dump_local_potential – libPSML"},{"text":"private subroutine dump_nonlocal_projectors(xf, ps) Uses: xmlf90_wxml Arguments Type Intent Optional Attributes Name type(xmlf_t), intent(inout) :: xf type( ps_t ), intent(in), target :: ps Source Code dump_nonlocal_projectors Source Code subroutine dump_nonlocal_projectors ( xf , ps ) use xmlf90_wxml type ( xmlf_t ), intent ( inout ) :: xf type ( ps_t ), intent ( in ), target :: ps type ( nonlocal_t ), pointer :: nlp type ( nlpj_t ), pointer :: nlpp type ( Grid_t ) :: parent_grid integer :: set nlp => ps % nonlocal do while ( associated ( nlp )) set = nlp % set call xml_NewElement ( xf , \"nonlocal-projectors\" ) if ( set /= SET_NULL ) then ! Group set was specified call my_add_attribute ( xf , \"set\" , str_of_set ( set )) endif call dump_annotation ( xf , nlp % annotation ) if ( initialized ( nlp % grid )) then parent_grid = nlp % grid call dump_grid ( xf , nlp % grid ) else parent_grid = ps % global_grid endif nlpp => nlp % proj do while ( associated ( nlpp )) call xml_NewElement ( xf , \"proj\" ) call my_add_attribute ( xf , \"l\" , nlpp % l ) if ( set == SET_LJ ) then call my_add_attribute ( xf , \"j\" , str ( nlpp % j )) endif call my_add_attribute ( xf , \"seq\" , str ( nlpp % seq )) call my_add_attribute ( xf , \"ekb\" , str ( nlpp % ekb )) call my_add_attribute ( xf , \"type\" , nlpp % type ) ! Group set was not specified if ( set == SET_NULL ) then call my_add_attribute ( xf , \"set\" , str_of_set ( nlpp % set )) endif call dump_radfunc ( xf , nlpp % proj , parent_grid ) call xml_EndElement ( xf , \"proj\" ) nlpp => nlpp % next enddo call xml_EndElement ( xf , \"nonlocal-projectors\" ) nlp => nlp % next enddo call delete ( parent_grid ) end subroutine dump_nonlocal_projectors","tags":"","loc":"proc/dump_nonlocal_projectors.html","title":"dump_nonlocal_projectors – libPSML"},{"text":"private subroutine dump_pseudo_wavefunctions(xf, ps) Uses: xmlf90_wxml sets_m Arguments Type Intent Optional Attributes Name type(xmlf_t), intent(inout) :: xf type( ps_t ), intent(in), target :: ps Source Code dump_pseudo_wavefunctions Source Code subroutine dump_pseudo_wavefunctions ( xf , ps ) use xmlf90_wxml use sets_m type ( xmlf_t ), intent ( inout ) :: xf type ( ps_t ), intent ( in ), target :: ps type ( pswfs_t ), pointer :: wfp type ( Grid_t ) :: parent_grid type ( set_info_t ) :: set_info integer :: i , j , set , n_grid integer , allocatable :: idx (:) wfp => ps % pswfs call sort_sets ( wfp % npswfs , wfp % set , set_info ) do j = 1 , nsets ( set_info ) call set_indexes ( set_info , j , idx ) set = set_id ( set_info , j ) call xml_NewElement ( xf , \"pseudo-wave-functions\" ) call my_add_attribute ( xf , \"set\" , str_of_set ( set )) ! ! Check grids and decide whether to include a <grid> element ! First, check whether any wfn is not using the global grid. ! If all the wfns are in that case, assume that a mid-level grid was ! specified, dump a grid in a new <grid> element, and pass it ! to the radfunc dumper. In the worst case scenario, we will ! have chosen a truly \"radfunc-private\" grid and there would be ! some replication of data. To avoid this, one would need to ! classify the grids. Maybe in a new version. ! parent_grid = ps % global_grid n_grid = 0 do i = 1 , size ( idx ) if (. not . same ( wfp % Phi ( idx ( i ))% grid , ps % global_grid )) then n_grid = n_grid + 1 endif enddo if ( n_grid == size ( idx )) then call dump_grid ( xf , wfp % Phi ( idx ( 1 ))% grid ) parent_grid = wfp % Phi ( idx ( 1 ))% grid endif do i = 1 , size ( idx ) call xml_NewElement ( xf , \"pswf\" ) call my_add_attribute ( xf , \"n\" , str ( wfp % n ( idx ( i )))) call my_add_attribute ( xf , \"l\" , wfp % l ( idx ( i ))) if ( set == SET_LJ ) then call my_add_attribute ( xf , \"j\" , str ( wfp % j ( idx ( i )))) endif call dump_radfunc ( xf , wfp % Phi ( idx ( i )), parent_grid ) call xml_EndElement ( xf , \"pswf\" ) enddo call xml_EndElement ( xf , \"pseudo-wave-functions\" ) enddo call delete ( parent_grid ) end subroutine dump_pseudo_wavefunctions","tags":"","loc":"proc/dump_pseudo_wavefunctions.html","title":"dump_pseudo_wavefunctions – libPSML"},{"text":"private subroutine dump_grid(xf, agrid) Uses: xmlf90_wxml Arguments Type Intent Optional Attributes Name type(xmlf_t), intent(inout) :: xf type(Grid_t), intent(in) :: agrid Source Code dump_grid Source Code subroutine dump_grid ( xf , agrid ) use xmlf90_wxml type ( xmlf_t ), intent ( inout ) :: xf type ( Grid_t ), intent ( in ) :: agrid if (. not . initialized ( agrid )) return call xml_NewElement ( xf , \"grid\" ) call my_add_attribute ( xf , \"npts\" , str ( sizeGrid ( agrid ))) call dump_annotation ( xf , annotationGrid ( agrid )) call xml_NewElement ( xf , \"grid-data\" ) call xml_AddArray ( xf , valGrid ( agrid )) call xml_EndElement ( xf , \"grid-data\" ) call xml_EndElement ( xf , \"grid\" ) end subroutine dump_grid","tags":"","loc":"proc/dump_grid.html","title":"dump_grid – libPSML"},{"text":"private subroutine dump_annotation(xf, annotation) Uses: xmlf90_wxml assoc_list assoc_list assoc_list assoc_list Arguments Type Intent Optional Attributes Name type(xmlf_t), intent(inout) :: xf type(ps_annotation_t), intent(in) :: annotation Source Code dump_annotation Source Code subroutine dump_annotation ( xf , annotation ) use xmlf90_wxml use assoc_list , only : ps_annotation_t => assoc_list_t use assoc_list , only : nitems_annotation => assoc_list_nitems use assoc_list , only : get_annotation_key => assoc_list_get_key use assoc_list , only : get_annotation_value => assoc_list_get_value type ( xmlf_t ), intent ( inout ) :: xf type ( ps_annotation_t ), intent ( in ) :: annotation integer :: n_items , i , stat character ( len = 256 ) :: key , val n_items = nitems_annotation ( annotation ) if ( n_items > 0 ) then call xml_NewElement ( xf , \"annotation\" ) do i = 1 , n_items call get_annotation_key ( annotation , i , key , stat ) call get_annotation_value ( annotation , i , val , stat ) call my_add_attribute ( xf , trim ( key ), trim ( val )) enddo call xml_EndElement ( xf , \"annotation\" ) endif end subroutine dump_annotation","tags":"","loc":"proc/dump_annotation.html","title":"dump_annotation – libPSML"},{"text":"private subroutine my_add_attribute(xf, name, value) Uses: xmlf90_wxml Arguments Type Intent Optional Attributes Name type(xmlf_t), intent(inout) :: xf character(len=*), intent(in) :: name character(len=*), intent(in) :: value Source Code my_add_attribute Source Code subroutine my_add_attribute ( xf , name , value ) use xmlf90_wxml type ( xmlf_t ), intent ( inout ) :: xf character ( len =* ), intent ( in ) :: name character ( len =* ), intent ( in ) :: value call xml_AddAttribute ( xf , name , trim ( value )) end subroutine my_add_attribute","tags":"","loc":"proc/my_add_attribute.html","title":"my_add_attribute – libPSML"},{"text":"public subroutine begin_element(name, attributes) Uses: xmlf90_sax Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: name type(dictionary_t), intent(in) :: attributes Source Code begin_element Source Code subroutine begin_element ( name , attributes ) use xmlf90_sax , only : dictionary_t , get_value #else subroutine begin_element ( namespaceURI , localName , name , attributes ) use Fox_sax , only : dictionary_t use fox_extra , only : get_value => get_value_by_key character ( len =* ), intent ( in ) :: namespaceURI character ( len =* ), intent ( in ) :: localName #endif character ( len =* ), intent ( in ) :: name type ( dictionary_t ), intent ( in ) :: attributes character ( len = 100 ) :: value , msg real :: version_number integer :: status integer :: i , npts if ( debug_parsing ) print * , \"Element: \" , trim ( name ) select case ( name ) case ( \"psml\" ) in_psml = . true . ! Make sure that pseudo is pointing to something if (. not . associated ( pseudo )) then call die ( \"ps_t object not initialized by client\" ) endif call get_value ( attributes , \"version\" , value , status ) if ( status /= 0 ) call die ( \"No psml version\" ) read ( value , fmt =* ) version_number if ( ( version_number < PSML_TARGET_VERSION_LO ) . or . & ( version_number > PSML_TARGET_VERSION_HI )) then write ( msg , \"('[',f4.2,',',f4.2,']')\" ) & PSML_TARGET_VERSION_LO , & PSML_TARGET_VERSION_HI call die ( \"This version of the library can \" // & \"process PSML files with version in \" // trim ( msg )) endif pseudo % version = value call get_value ( attributes , \"energy_unit\" , pseudo % energy_unit , status ) if ( status /= 0 ) call die ( \"No energy unit\" ) call get_value ( attributes , \"length_unit\" , pseudo % length_unit , status ) if ( status /= 0 ) call die ( \"No length unit\" ) call get_value ( attributes , \"uuid\" , pseudo % uuid , status ) if ( status /= 0 ) pseudo % uuid = \"no-uuid-specified\" ! Initialize counters pseudo % pswfs % npswfs = 0 case ( \"provenance\" ) in_provenance = . true . ! This will gather all element provenances at the top level allocate ( pp ) if ( associated ( pseudo % provenance )) then qp => pseudo % provenance do while ( associated ( qp % next )) qp => qp % next enddo qp % next => pp else pseudo % provenance => pp endif call get_value ( attributes , \"creator\" , pp % creator , status ) if ( status /= 0 ) pp % creator = \"unknown\" call get_value ( attributes , \"date\" , pp % date , status ) if ( status /= 0 ) pp % date = \"unknown\" case ( \"input-file\" ) if (. not . in_provenance ) call die ( \"<input-file> outside <provenance>\" ) in_input_file = . true . ifp => pp % input_file call get_value ( attributes , \"name\" , ifp % name , status ) if ( status /= 0 ) ifp % name = \"unknown\" case ( \"header\" ) in_header = . true . hp => pseudo % header call get_value ( attributes , \"atomic-label\" , hp % atomic_label , status ) if ( status /= 0 ) call die ( \"Cannot determine atomic-label\" ) call get_value ( attributes , \"z-pseudo\" , value , status ) if ( status /= 0 ) call die ( \"Cannot determine z-pseudo\" ) read ( unit = value , fmt =* ) hp % zpseudo call get_value ( attributes , \"atomic-number\" , value , status ) if ( status /= 0 ) call die ( \"Cannot determine atomic number\" ) read ( unit = value , fmt =* ) hp % z call get_value ( attributes , \"flavor\" , hp % flavor , status ) if ( status /= 0 ) hp % flavor = \"not-unique\" call get_value ( attributes , \"relativity\" , hp % relativity , status ) if ( status /= 0 ) call die ( \"Cannot determine relativity scheme\" ) call get_value ( attributes , \"polarized\" , value , status ) if ( status /= 0 ) value = \"no\" hp % polarized = ( value == \"yes\" ) if ( hp % polarized . and . trim ( hp % relativity ) == \"dirac\" ) then call die ( \"Cannot be polarized and fully relativistic at the same time\" ) endif call get_value ( attributes , \"core-corrections\" , & hp % core_corrections , status ) if ( status /= 0 ) hp % core_corrections = \"no\" case ( \"exchange-correlation\" ) in_xc = . true . xp => pseudo % xc_info case ( \"libxc-info\" ) if (. not . in_xc ) call die ( \"Orphan <libxc-info>\" ) in_libxc_info = . true . call get_value ( attributes , \"number-of-functionals\" , & value , status ) if ( status /= 0 ) call die ( \"Error reading number of libxc functs\" ) read ( unit = value , fmt =* ) xp % n_functs_libxc n_funct = xp % n_functs_libxc allocate ( xp % libxc_name ( n_funct ), xp % libxc_id ( n_funct )) allocate ( xp % libxc_weight ( n_funct ), xp % libxc_type ( n_funct )) xp % libxc_weight ( 1 : n_funct ) = 1.0_dp xp % libxc_type ( 1 : n_funct ) = \"UNKNOWN\" n_funct = 0 ! for checking the counting on the fly case ( \"functional\" ) if (. not . in_libxc_info ) call die ( \"Orphan <functional>\" ) n_funct = n_funct + 1 if ( n_funct > xp % n_functs_libxc ) & call die ( \"Too many <functional> elements in <libxc-info>\" ) call get_value ( attributes , \"name\" , & xp % libxc_name ( n_funct ), status ) if ( status /= 0 ) call die ( \"Error reading libxc name\" ) call get_value ( attributes , \"id\" , value , status ) if ( status /= 0 ) call die ( \"Error reading libxc id\" ) read ( unit = value , fmt =* ) xp % libxc_id ( n_funct ) ! optional attribute(s) call get_value ( attributes , \"weight\" , value , status ) if ( status == 0 ) then read ( unit = value , fmt =* ) xp % libxc_weight ( n_funct ) endif call get_value ( attributes , \"type\" , value , status ) if ( status == 0 ) then xp % libxc_type ( n_funct ) = trim ( value ) endif case ( \"valence-configuration\" ) in_valence_config = . true . pseudo % config_val % nshells = 0 pseudo % config_val % occ_up (:) = 0.0_dp pseudo % config_val % occ_down (:) = 0.0_dp pseudo % config_val % occ (:) = 0.0_dp call get_value ( attributes , \"total-valence-charge\" , value , status ) if ( status /= 0 ) call die ( \"Cannot determine total-valence-charge\" ) read ( unit = value , fmt =* ) pseudo % config_val % total_charge case ( \"shell\" ) if ( in_valence_config ) then cp => pseudo % config_val !         else if (in_core_config) then !            cp => pseudo%config_core else call die ( \"Orphan <shell> element\" ) endif cp % nshells = cp % nshells + 1 call get_value ( attributes , \"l\" , cp % l ( cp % nshells ), status ) if ( status /= 0 ) call die ( \"Cannot determine l for shell\" ) call get_value ( attributes , \"n\" , value , status ) if ( status /= 0 ) call die ( \"Cannot determine n for shell\" ) read ( unit = value , fmt =* ) cp % n ( cp % nshells ) call get_value ( attributes , \"occupation\" , value , status ) if ( status /= 0 ) call die ( \"Cannot determine occupation for shell\" ) read ( unit = value , fmt =* ) cp % occ ( cp % nshells ) call get_value ( attributes , \"occupation-up\" , value , status ) if ( status == 0 ) then read ( unit = value , fmt =* ) cp % occ_up ( cp % nshells ) endif call get_value ( attributes , \"occupation-down\" , value , status ) if ( status == 0 ) then read ( unit = value , fmt =* ) cp % occ_down ( cp % nshells ) endif case ( \"slps\" ) in_slps = . true . if (. not . in_semilocal ) call die ( \"Orphan <slps> element\" ) allocate ( slvp ) ! Append to end of list  !! call append(slp%pot,slvp) if ( associated ( slp % pot )) then qslvp => slp % pot do while ( associated ( qslvp % next )) qslvp => qslvp % next enddo qslvp % next => slvp else !First link slp % pot => slvp endif rp => slvp % V slvp % parent_group => slp ! current semilocal-potentials element call get_value ( attributes , \"set\" , value , status ) if ( status /= 0 ) then value = current_sl_set endif slvp % set = setcode_of_string ( value ) call get_value ( attributes , \"l\" , slvp % l , status ) if ( status /= 0 ) call die ( \"Cannot determine l for SL potential\" ) call get_value ( attributes , \"n\" , value , status ) if ( status /= 0 ) call die ( \"Cannot determine n for SL potential\" ) read ( unit = value , fmt =* ) slvp % n call get_value ( attributes , \"rc\" , value , status ) if ( status /= 0 ) call die ( \"Cannot determine rc for SL potential\" ) read ( unit = value , fmt =* ) slvp % rc call get_value ( attributes , \"j\" , value , status ) if ( status /= 0 ) then if ( slvp % set == SET_LJ ) & call die ( \"Cannot determine j for SLPS in set \" // str_of_set ( SET_LJ )) else read ( unit = value , fmt =* ) slvp % j endif call get_value ( attributes , \"flavor\" , slvp % flavor , status ) if ( status /= 0 ) then slvp % flavor = top_flavor endif case ( \"proj\" ) in_proj = . true . if (. not . in_nonlocal ) call die ( \"Orphan <proj> element\" ) allocate ( nlpp ) ! Append to end of list  !! call append(nlp%proj,nlpp) if ( associated ( nlp % proj )) then qnlpp => nlp % proj do while ( associated ( qnlpp % next )) qnlpp => qnlpp % next enddo qnlpp % next => nlpp else !First link nlp % proj => nlpp endif rp => nlpp % proj nlpp % parent_group => nlp ! current nonlocal-projectors element call get_value ( attributes , \"set\" , value , status ) if ( status /= 0 ) then value = current_proj_set endif nlpp % set = setcode_of_string ( value ) call get_value ( attributes , \"l\" , nlpp % l , status ) if ( status /= 0 ) call die ( \"Cannot determine l for proj\" ) call get_value ( attributes , \"seq\" , value , status ) if ( status /= 0 ) call die ( \"Cannot determine seq number for proj\" ) read ( unit = value , fmt =* ) nlpp % seq call get_value ( attributes , \"ekb\" , value , status ) if ( status /= 0 ) call die ( \"Cannot determine Ekb for proj\" ) read ( unit = value , fmt =* ) nlpp % ekb call get_value ( attributes , \"j\" , value , status ) if ( status /= 0 ) then if ( nlpp % set == SET_LJ ) & call die ( \"Cannot determine j for Proj in set \" // str_of_set ( SET_LJ )) else read ( unit = value , fmt =* ) nlpp % j endif call get_value ( attributes , \"type\" , nlpp % type , status ) if ( status /= 0 ) call die ( \"Cannot determine type of proj\" ) case ( \"pswf\" ) if (. not . in_pseudowavefun ) call die ( \"Orphan <pswf> element\" ) in_pswf = . true . wfp => pseudo % pswfs wfp % npswfs = wfp % npswfs + 1 i = wfp % npswfs rp => wfp % Phi ( i ) call get_value ( attributes , \"set\" , value , status ) if ( status /= 0 ) then value = current_wf_set endif wfp % set ( i ) = setcode_of_string ( value ) call get_value ( attributes , \"l\" , wfp % l ( i ), status ) if ( status /= 0 ) call die ( \"Cannot determine l for PSwf\" ) call get_value ( attributes , \"n\" , value , status ) if ( status /= 0 ) call die ( \"Cannot determine n for PSwf\" ) read ( unit = value , fmt =* ) wfp % n ( i ) call get_value ( attributes , \"j\" , value , status ) if ( status /= 0 ) then if ( wfp % set ( i ) == SET_LJ ) & call die ( \"Cannot determine j for PSwf in set \" // str_of_set ( SET_LJ )) else read ( unit = value , fmt =* ) wfp % j ( i ) endif case ( \"grid\" ) in_grid = . true . got_explicit_grid_data = . false . ! This attribute is mandatory call get_value ( attributes , \"npts\" , value , status ) if ( status /= 0 ) call die ( \"Cannot determine grid npts\" ) read ( unit = value , fmt =* ) npts if ( npts == 0 ) call die ( \"Grid size not specified correctly\" ) ! Create working object and associate inner sections ! while the parsing is active call newGrid ( tmp_grid , npts ) gdata => valGrid ( tmp_grid ) gannot => annotationGrid ( tmp_grid ) ! ! In this way we allow for a private grid for each radfunc, ! or for a global grid specification ! if ( in_radfunc ) then if ( debug_parsing ) print * , \"Found grid in radfunc\" if ( initialized ( rp % grid )) then call die ( \"psml: Two grids specified for a radfunc\" ) endif rp % grid = tmp_grid ! We check whether we are at the top level, ! or at an intermediate grouping level that allows a grid else if ( in_nonlocal ) then if ( initialized ( nlp % grid )) then call die ( \"psml: Two grids in same nonlocal block\" ) endif if ( debug_parsing ) print * , \"Found nonlocal grid\" nlp % grid = tmp_grid else if ( in_local_potential ) then if ( initialized ( lop % grid )) then call die ( \"psml: Two grids in same local block\" ) endif if ( debug_parsing ) print * , \"Found local grid\" lop % grid = tmp_grid else if ( in_semilocal ) then if ( initialized ( slp % grid )) then call die ( \"psml: Two grids in same semilocal block\" ) endif if ( debug_parsing ) print * , \"Found semilocal grid\" slp % grid = tmp_grid else if ( in_pseudowavefun ) then if ( initialized ( wfp % grid )) then !call die(\"psml: Two pseudo-wavefunction grids specified\") endif if ( debug_parsing ) print * , \"Found pseudo-wavefunction grid\" wfp % grid = tmp_grid else ! We are at the top level if ( debug_parsing ) print * , \"Found grid at the top level\" if ( initialized ( pseudo % global_grid )) then ! Maybe allow this in the future call die ( \"psml: Two global grids specified\" ) endif pseudo % global_grid = tmp_grid endif case ( \"data\" ) if (. not . in_radfunc ) then call die ( \"<data> element outside <rad_func> element\" ) endif in_data = . true . ! The following blocks are a bit more verbose than needed since ! the Intel compiler seems to be trying to evaluate all the ! clauses joined by an .and. operator, instead of stopping if ! the first clause is .false. if (. not . initialized ( rp % grid )) then ! Try regional grids first if ( in_nonlocal ) then if ( initialized ( nlp % grid )) then rp % grid = nlp % grid if ( debug_parsing ) print * , \"Associated proj grid with nl parent grid\" endif else if ( in_local_potential ) then if ( initialized ( lop % grid )) then rp % grid = lop % grid if ( debug_parsing ) print * , \"Associated grid with vlocal parent grid\" endif else if ( in_semilocal ) then if ( initialized ( slp % grid )) then rp % grid = slp % grid if ( debug_parsing ) print * , \"Associated slps grid with sl parent grid\" endif else if ( in_pseudowavefun ) then if ( initialized ( wfp % grid )) then rp % grid = wfp % grid endif endif endif ! If the parent block does not include a grid, try the global grid if (. not . initialized ( rp % grid )) then if ( initialized ( pseudo % global_grid )) then rp % grid = pseudo % global_grid if ( debug_parsing ) print * , \"Associated grid with global grid\" endif endif ! Now give up if (. not . initialized ( rp % grid )) call die ( \"Cannot find grid data for radfunc\" ) allocate ( rp % data ( sizeGrid ( rp % grid ))) ndata = 0 ! To start the build up case ( \"grid-data\" ) if (. not . in_grid ) call die ( \"Grid_data element outside grid element\" ) in_grid_data = . true . got_explicit_grid_data = . true . if ( size ( gdata ) == 0 ) call die ( \"Grid npts attribute faulty\" ) ndata_grid = 0 ! To start the build up case ( \"radfunc\" ) ! We need to make sure that a radfunc is allowed at this level ! ! For example, if an old-style file with <vps> is used, the finding ! of a <vps> element will not increase npots, and there will be a ! segmentation fault when trying to store the data in the rp pointer, ! which would be non-associated if the vps section is the first ! case of radfuncs in the file ! ! Actually, it gets worse: if there is a <core-charge> element ! before the old-style <vps> section, the rp pointer used for ! core-charge will be reused and assigned the data for the first ! and subsequent vps elements. ! if ( in_slps . or . in_coreCharge . or . in_valenceCharge & . or . in_pswf . or . in_proj . or . in_local_potential & . or . in_chlocal ) then in_radfunc = . true . else call die ( \"<radfunc> element found under unallowed <\" // & trim ( parent_element ) // \">\" ) endif case ( \"pseudocore-charge\" ) in_coreCharge = . true . corep => pseudo % core_charge rp => corep % rho_core call get_value ( attributes , \"matching-radius\" , value , status ) if ( status == 0 ) then read ( unit = value , fmt =* ) corep % rcore else corep % rcore = - 1.0_dp endif call get_value ( attributes , \"number-of-continuous-derivatives\" , & value , status ) if ( status == 0 ) then read ( unit = value , fmt =* ) corep % n_cont_derivs else corep % n_cont_derivs = - 1 endif case ( \"valence-charge\" ) in_valenceCharge = . true . valp => pseudo % valence_charge rp => valp % rho_val call get_value ( attributes , \"total-charge\" , value , status ) if ( status /= 0 ) call die ( \"Cannot determine total valence charge\" ) read ( unit = value , fmt =* ) valp % total_charge case ( \"semilocal-potentials\" ) in_semilocal = . true . allocate ( slp ) if ( associated ( pseudo % semilocal )) then qslp => pseudo % semilocal do while ( associated ( qslp % next )) qslp => qslp % next enddo qslp % next => slp else pseudo % semilocal => slp endif current_sl_set = \"invalid\" slp % set = SET_NULL call get_value ( attributes , \"set\" , value , status ) if ( status == 0 ) then current_sl_set = value slp % set = setcode_of_string ( value ) endif if ( debug_parsing ) print * , \"Found semilocal-potentials set: \" , trim ( current_sl_set ) top_flavor = pseudo % header % flavor call get_value ( attributes , \"flavor\" , value , status ) if ( status == 0 ) then top_flavor = value endif case ( \"nonlocal-projectors\" ) in_nonlocal = . true . ! Allocate new node and add to the end of the linked list allocate ( nlp ) if ( associated ( pseudo % nonlocal )) then qnlp => pseudo % nonlocal do while ( associated ( qnlp % next )) qnlp => qnlp % next enddo qnlp % next => nlp else pseudo % nonlocal => nlp endif current_proj_set = \"invalid\" nlp % set = SET_NULL call get_value ( attributes , \"set\" , value , status ) if ( status == 0 ) then current_proj_set = value nlp % set = setcode_of_string ( value ) endif if ( debug_parsing ) print * , \"Found nonlocal-projectors set: \" , trim ( current_proj_set ) nlp % set = setcode_of_string ( value ) case ( \"local-potential\" ) in_local_potential = . true . lop => pseudo % local rp => lop % vlocal call get_value ( attributes , \"type\" , lop % vlocal_type , status ) if ( status /= 0 ) call die ( \"Cannot determine type of local potential\" ) case ( \"local-charge\" ) if (. not . in_local_potential ) call die ( \"<local-charge> outside <local-potential>\" ) in_chlocal = . true . lop => pseudo % local rp => lop % chlocal ! Future expansion: chlocal attributes case ( \"pseudo-wave-functions\" ) in_pseudowavefun = . true . wfp => pseudo % pswfs current_wf_set = \"invalid\" wfp % set = SET_NULL call get_value ( attributes , \"set\" , value , status ) if ( status == 0 ) then current_wf_set = value wfp % set = setcode_of_string ( value ) endif if ( debug_parsing ) print * , \"Found pseudo-wavefunction set: \" , trim ( current_wf_set ) case ( \"annotation\" ) if ( in_provenance ) then call save_annotation ( attributes , pp % annotation ) else if ( in_grid ) then call save_annotation ( attributes , gannot ) else if ( in_xc ) then call save_annotation ( attributes , xp % annotation ) else if ( in_valence_config ) then call save_annotation ( attributes , cp % annotation ) else if ( in_semilocal ) then call save_annotation ( attributes , slp % annotation ) else if ( in_nonlocal ) then call save_annotation ( attributes , nlp % annotation ) else if ( in_local_potential ) then call save_annotation ( attributes , lop % annotation ) else if ( in_pseudowavefun ) then call save_annotation ( attributes , wfp % annotation ) else if ( in_valenceCharge ) then call save_annotation ( attributes , valp % annotation ) else if ( in_coreCharge ) then call save_annotation ( attributes , corep % annotation ) else if ( in_psml ) then ! It must be at the top level call save_annotation ( attributes , pseudo % annotation ) else ! Do nothing instead of dying ! call die(\"Misplaced <annotation> element\") endif end select parent_element = name end subroutine begin_element","tags":"","loc":"proc/begin_element.html","title":"begin_element – libPSML"},{"text":"public subroutine end_element(name) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: name Source Code end_element Source Code subroutine end_element ( name ) #else subroutine end_element ( namespaceURI , localName , name ) character ( len =* ), intent ( in ) :: namespaceURI character ( len =* ), intent ( in ) :: localName #endif character ( len =* ), intent ( in ) :: name integer :: i if ( debug_parsing ) print * , \"-- end Element: \" , trim ( name ) select case ( name ) case ( \"radfunc\" ) in_radfunc = . false . if (. not . associated ( rp % data )) then call die ( \"No data for radfunc!\" ) endif case ( \"grid\" ) in_grid = . false . ! if (. not . got_explicit_grid_data ) then call die ( \"Need explicit grid data!\" ) endif call delete ( tmp_grid ) case ( \"data\" ) ! ! We are done filling up the radfunc data ! Check that we got the advertised number of items ! in_data = . false . if ( ndata /= size ( rp % data )) then call die ( \"npts mismatch in radfunc data\" ) endif case ( \"grid-data\" ) ! ! We are done filling up the grid data ! Check that we got the advertised number of items ! in_grid_data = . false . if ( ndata_grid /= size ( gdata )) then call die ( \"npts mismatch in grid\" ) endif if ( debug_parsing ) print * , \"Got grid data: \" , got_explicit_grid_data case ( \"pseudocore-charge\" ) in_coreCharge = . false . case ( \"valence-charge\" ) in_valenceCharge = . false . case ( \"semilocal-potentials\" ) in_semilocal = . false . slp => null () case ( \"nonlocal-projectors\" ) in_nonlocal = . false . nlp => null () case ( \"slps\" ) in_slps = . false . case ( \"proj\" ) in_proj = . false . case ( \"local-potential\" ) in_local_potential = . false . lop => null () case ( \"local-charge\" ) in_chlocal = . false . case ( \"pseudo-wave-functions\" ) in_pseudowavefun = . false . case ( \"pswf\" ) in_pswf = . false . case ( \"valence-configuration\" ) in_valence_config = . false . case ( \"exchange-correlation\" ) in_xc = . false . case ( \"libxc-info\" ) in_libxc_info = . false . if ( n_funct /= xp % n_functs_libxc ) & call die ( \"Too few <functional> elements in <libxc-info>\" ) case ( \"provenance\" ) in_provenance = . false . case ( \"input-file\" ) in_input_file = . false . case ( \"header\" ) in_header = . false . case ( \"psml\" ) in_psml = . false . !         call dump_pseudo(pseudo) end select end subroutine end_element","tags":"","loc":"proc/end_element.html","title":"end_element – libPSML"},{"text":"public subroutine pcdata_chunk(chunk) Uses: xmlf90_sax iso_varying_string Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: chunk Source Code pcdata_chunk Source Code subroutine pcdata_chunk ( chunk ) #ifdef PSML_USE_FOX use fox_extra , only : build_data_array #else use xmlf90_sax , only : build_data_array #endif use iso_varying_string , only : operator ( // ) character ( len =* ), intent ( in ) :: chunk if ( len_trim ( chunk ) == 0 ) RETURN ! skip empty chunk if ( in_data ) then ! ! Note that we know where we need to put it through the pointer rp... ! call build_data_array ( chunk , rp % data , ndata ) else if ( in_grid_data ) then ! !     Fill the explicit grid data pointer call build_data_array ( chunk , gdata , ndata_grid ) else if ( in_input_file ) then ifp % buffer = ifp % buffer // chunk else if ( in_header ) then ! ! There should not be any pcdata in header in this version... !      print *, \"Header data:\" !      print *, trim(chunk) endif end subroutine pcdata_chunk","tags":"","loc":"proc/pcdata_chunk.html","title":"pcdata_chunk – libPSML"},{"text":"public subroutine cdata_section_chunk(chunk) Uses: iso_varying_string Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: chunk Source Code cdata_section_chunk Source Code subroutine cdata_section_chunk ( chunk ) use iso_varying_string , only : operator ( // ) character ( len =* ), intent ( in ) :: chunk if ( len_trim ( chunk ) == 0 ) RETURN ! skip empty chunk if ( in_input_file ) then ifp % buffer = ifp % buffer // chunk endif end subroutine cdata_section_chunk","tags":"","loc":"proc/cdata_section_chunk.html","title":"cdata_section_chunk – libPSML"},{"text":"private subroutine save_annotation(atts, annotation) Uses: assoc_list xmlf90_sax Arguments Type Intent Optional Attributes Name type(dictionary_t), intent(in) :: atts type(ps_annotation_t), intent(out) :: annotation Source Code save_annotation Source Code subroutine save_annotation ( atts , annotation ) use assoc_list , ps_annotation_t => assoc_list_t #ifdef PSML_USE_FOX use Fox_common , only : dictionary_t , len => getLength use fox_extra , only : get_value => get_value_by_index , get_key #else use xmlf90_sax , only : dictionary_t , get_value , get_key , len #endif type ( dictionary_t ), intent ( in ) :: atts type ( ps_annotation_t ), intent ( out ) :: annotation integer :: n , i , status character ( len = 300 ) :: key , value n = len ( atts ) call assoc_list_init ( annotation , n , status ) if ( status /= 0 ) call die ( \"Failed to init annotation object\" ) do i = 1 , n call get_key ( atts , i , key , status ) if ( status /= 0 ) call die ( \"cannot get key in atts dict\" ) call get_value ( atts , i , value , status ) if ( status /= 0 ) call die ( \"cannot get value in atts dict\" ) call assoc_list_insert ( annotation , key , value , status ) if ( status /= 0 ) call die ( \"Failed to insert annotation pair\" ) enddo end subroutine save_annotation","tags":"","loc":"proc/save_annotation.html","title":"save_annotation – libPSML"},{"text":"public subroutine ps_SetPSMLVersion(ps, version) Arguments Type Intent Optional Attributes Name type( ps_t ), intent(inout) :: ps character(len=*), intent(in) :: version Source Code ps_SetPSMLVersion Source Code subroutine ps_SetPSMLVersion ( ps , version ) type ( ps_t ), intent ( inout ) :: ps character ( len =* ), intent ( in ) :: version ps % version = version end subroutine ps_SetPSMLVersion","tags":"","loc":"proc/ps_setpsmlversion.html","title":"ps_SetPSMLVersion – libPSML"},{"text":"public subroutine ps_SetUUID(ps, id) Arguments Type Intent Optional Attributes Name type( ps_t ), intent(inout) :: ps character(len=36), intent(in) :: id Source Code ps_SetUUID Source Code subroutine ps_SetUUID ( ps , id ) type ( ps_t ), intent ( inout ) :: ps character ( len = 36 ), intent ( in ) :: id ps % uuid = id end subroutine ps_SetUUID","tags":"","loc":"proc/ps_setuuid.html","title":"ps_SetUUID – libPSML"},{"text":"public subroutine ps_AddProvenanceRecord(ps, creator, date, annotation) Arguments Type Intent Optional Attributes Name type( ps_t ), intent(inout) :: ps character(len=*), intent(in) :: creator character(len=*), intent(in) :: date type(ps_annotation_t), intent(in), target :: annotation Source Code ps_AddProvenanceRecord Source Code subroutine ps_AddProvenanceRecord ( ps , creator , date , annotation ) type ( ps_t ), intent ( inout ) :: ps character ( len =* ), intent ( in ) :: creator character ( len =* ), intent ( in ) :: date type ( ps_annotation_t ), intent ( in ), target :: annotation type ( provenance_t ), pointer :: p type ( provenance_t ), pointer :: q allocate ( p ) q => ps % provenance if ( associated ( q )) then p % next => q q % prev => p endif ps % provenance => p p % creator = trim ( creator ) p % date = trim ( date ) p % annotation = annotation end subroutine ps_AddProvenanceRecord","tags":"","loc":"proc/ps_addprovenancerecord.html","title":"ps_AddProvenanceRecord – libPSML"},{"text":"public subroutine ps_Delete_NonlocalProjectors(ps) Arguments Type Intent Optional Attributes Name type( ps_t ), intent(inout) :: ps Source Code ps_Delete_NonlocalProjectors Source Code subroutine ps_Delete_NonlocalProjectors ( ps ) type ( ps_t ), intent ( inout ) :: ps call destroy_nonlocal ( ps % nonlocal ) end subroutine ps_Delete_NonlocalProjectors","tags":"","loc":"proc/ps_delete_nonlocalprojectors.html","title":"ps_Delete_NonlocalProjectors – libPSML"},{"text":"public subroutine ps_Delete_LocalPotential(ps) Arguments Type Intent Optional Attributes Name type( ps_t ), intent(inout) :: ps Source Code ps_Delete_LocalPotential Source Code subroutine ps_Delete_LocalPotential ( ps ) type ( ps_t ), intent ( inout ) :: ps call destroy_local ( ps % local ) end subroutine ps_Delete_LocalPotential","tags":"","loc":"proc/ps_delete_localpotential.html","title":"ps_Delete_LocalPotential – libPSML"},{"text":"public subroutine psml_reader(fname, ps, debug) Uses: m_psml_core m_psml_tables m_psml_parsing_helpers m_psml_parsing_helpers m_psml_parsing_helpers external_interfaces m_interp xmlf90_sax Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: fname type( ps_t ), intent(inout), target :: ps logical, intent(in), optional :: debug Source Code psml_reader Source Code subroutine psml_reader ( fname , ps , debug ) use m_psml_core , only : ps_t , ps_destroy use m_psml_tables , only : ps_GenerateTables use m_psml_parsing_helpers , only : begin_element , end_element , pcdata_chunk use m_psml_parsing_helpers , only : cdata_section_chunk use m_psml_parsing_helpers , only : pseudo , debug_parsing use external_interfaces , only : die => psml_die #ifndef __NO_PROC_POINTERS__ use m_interp , only : set_default_interpolator #endif #ifdef PSML_USE_FOX use FoX_sax , only : xml_t , open_xml_file , close_xml_t , parse #else use xmlf90_sax , only : xml_t , open_xmlfile , xml_parse , close_xmlfile #endif implicit none character ( len =* ), intent ( in ) :: fname type ( ps_t ), intent ( inout ), target :: ps logical , intent ( in ), optional :: debug type ( xml_t ) :: fxml integer :: iostat ! Clean the object's internal data ! Note that the inout intent allow us ! to do this, and avoid having ps being ! reset by the compiler call ps_destroy ( ps ) ! Associate module pointer, so that the parsed data ! is written to ps pseudo => ps if ( present ( debug )) then debug_parsing = debug else debug_parsing = . false . endif ! Allocate internal structures here... #ifdef PSML_USE_FOX call open_xml_file ( fxml , fname , iostat ) if ( iostat /= 0 ) call die ( \"Cannot open XML file\" ) !! ** CDATA handler missing call parse ( fxml , startElement_handler = begin_element , & endElement_handler = end_element , & characters_handler = pcdata_chunk ) call close_xml_t ( fxml ) #else call open_xmlfile ( fname , fxml , iostat ) if ( iostat /= 0 ) call die ( \"Cannot open PSML file: \" // trim ( fname )) call xml_parse ( fxml , begin_element , end_element , pcdata_chunk , & cdata_section_handler = cdata_section_chunk , verbose = . false .) call close_xmlfile ( fxml ) #endif ! Clean up association of module pointer pseudo => null () call ps_GenerateTables ( ps ) #ifndef __NO_PROC_POINTERS__ ! ! Set default interpolator ! call set_default_interpolator () #endif end subroutine psml_reader","tags":"","loc":"proc/psml_reader.html","title":"psml_reader – libPSML"},{"text":"private subroutine generate_table_sl(ps) Arguments Type Intent Optional Attributes Name type( ps_t ), intent(inout), target :: ps Source Code generate_table_sl Source Code subroutine generate_table_sl ( ps ) type ( ps_t ), intent ( inout ), target :: ps type ( semilocal_t ), pointer :: slp type ( slps_t ), pointer :: slvp integer :: npots if ( allocated ( ps % sl_table )) then deallocate ( ps % sl_table ) endif npots = 0 slp => ps % semilocal do while ( associated ( slp )) slvp => slp % pot do while ( associated ( slvp )) npots = npots + 1 slvp => slvp % next enddo slp => slp % next enddo allocate ( ps % sl_table ( npots )) npots = 0 slp => ps % semilocal do while ( associated ( slp )) slvp => slp % pot do while ( associated ( slvp )) npots = npots + 1 ps % sl_table ( npots )% p => slvp slvp => slvp % next enddo slp => slp % next enddo end subroutine generate_table_sl","tags":"","loc":"proc/generate_table_sl.html","title":"generate_table_sl – libPSML"},{"text":"private subroutine generate_table_nl(ps) Arguments Type Intent Optional Attributes Name type( ps_t ), intent(inout), target :: ps Source Code generate_table_nl Source Code subroutine generate_table_nl ( ps ) type ( ps_t ), intent ( inout ), target :: ps type ( nonlocal_t ), pointer :: nlp type ( nlpj_t ), pointer :: nlpp integer :: nprojs if ( allocated ( ps % nl_table )) then deallocate ( ps % nl_table ) endif nprojs = 0 nlp => ps % nonlocal do while ( associated ( nlp )) nlpp => nlp % proj do while ( associated ( nlpp )) nprojs = nprojs + 1 nlpp => nlpp % next enddo nlp => nlp % next enddo allocate ( ps % nl_table ( nprojs )) nprojs = 0 nlp => ps % nonlocal do while ( associated ( nlp )) nlpp => nlp % proj do while ( associated ( nlpp )) nprojs = nprojs + 1 ps % nl_table ( nprojs )% p => nlpp nlpp => nlpp % next enddo nlp => nlp % next enddo end subroutine generate_table_nl","tags":"","loc":"proc/generate_table_nl.html","title":"generate_table_nl – libPSML"},{"text":"public subroutine ps_GenerateTables(ps) Arguments Type Intent Optional Attributes Name type( ps_t ), intent(inout), target :: ps Source Code ps_GenerateTables Source Code subroutine ps_GenerateTables ( ps ) type ( ps_t ), intent ( inout ), target :: ps call generate_table_sl ( ps ) call generate_table_nl ( ps ) end subroutine ps_GenerateTables","tags":"","loc":"proc/ps_generatetables.html","title":"ps_GenerateTables – libPSML"},{"text":"public function nsets(set_info) result(n) Arguments Type Intent Optional Attributes Name type( set_info_t ), intent(in) :: set_info Return Value integer Source Code nsets Source Code function nsets ( set_info ) result ( n ) type ( set_info_t ), intent ( in ) :: set_info integer :: n n = set_info % nsets end function nsets","tags":"","loc":"proc/nsets.html","title":"nsets – libPSML"},{"text":"public function set_id(set_info, j) Arguments Type Intent Optional Attributes Name type( set_info_t ), intent(in) :: set_info integer, intent(in) :: j Return Value integer Source Code set_id Source Code function set_id ( set_info , j ) type ( set_info_t ), intent ( in ) :: set_info integer , intent ( in ) :: j integer :: set_id if ( j > set_info % nsets ) then set_id = 0 else set_id = set_info % set ( j ) endif end function set_id","tags":"","loc":"proc/set_id.html","title":"set_id – libPSML"},{"text":"private subroutine clear(set_info) Arguments Type Intent Optional Attributes Name type( set_info_t ), intent(inout) :: set_info Source Code clear Source Code subroutine clear ( set_info ) type ( set_info_t ), intent ( inout ) :: set_info integer :: j set_info % set (:) = 0 set_info % nels (:) = 0 do j = 1 , MAX_NSETS if ( allocated ( set_info % indexes ( j )% ind )) then deallocate ( set_info % indexes ( j )% ind ) endif enddo set_info % nsets = 0 end subroutine clear","tags":"","loc":"proc/clear.html","title":"clear – libPSML"},{"text":"public subroutine display(set_info) Arguments Type Intent Optional Attributes Name type( set_info_t ), intent(in) :: set_info Source Code display Source Code subroutine display ( set_info ) type ( set_info_t ), intent ( in ) :: set_info integer :: j , i do j = 1 , set_info % nsets print * , \"Set: \" , set_info % set ( j ) do i = 1 , size ( set_info % indexes ( j )% ind ) print * , \"index: \" , set_info % indexes ( j )% ind ( i ) enddo enddo end subroutine display","tags":"","loc":"proc/display.html","title":"display – libPSML"},{"text":"public subroutine sort_sets(n, a, set_info) Arguments Type Intent Optional Attributes Name integer, intent(in) :: n integer, intent(in) :: a (:) type( set_info_t ), intent(inout) :: set_info Source Code sort_sets Source Code subroutine sort_sets ( n , a , set_info ) integer , intent ( in ) :: n integer , intent ( in ) :: a (:) type ( set_info_t ), intent ( inout ) :: set_info integer :: i , j , dim , nsets , current_set , set call clear ( set_info ) ! First pass. Assumes bunched sets current_set = 0 nsets = 0 do i = 1 , n set = a ( i ) if ( set /= current_set ) then nsets = nsets + 1 set_info % set ( nsets ) = set set_info % nels ( nsets ) = 1 current_set = set else set_info % nels ( nsets ) = set_info % nels ( nsets ) + 1 endif enddo set_info % nsets = nsets ! Allocate do j = 1 , nsets dim = set_info % nels ( j ) allocate ( set_info % indexes ( j )% ind ( dim )) enddo ! Second pass. current_set = 0 nsets = 0 do i = 1 , n set = a ( i ) if ( set /= current_set ) then nsets = nsets + 1 if ( nsets > MAX_NSETS ) stop \"set overflow\" set_info % nels ( nsets ) = 1 set_info % indexes ( nsets )% ind ( 1 ) = i current_set = set else set_info % nels ( nsets ) = set_info % nels ( nsets ) + 1 set_info % indexes ( nsets )% ind ( set_info % nels ( nsets )) = i endif enddo end subroutine sort_sets","tags":"","loc":"proc/sort_sets.html","title":"sort_sets – libPSML"},{"text":"public subroutine set_indexes(set_info, j, idx) Arguments Type Intent Optional Attributes Name type( set_info_t ), intent(in) :: set_info integer, intent(in) :: j integer, intent(inout), allocatable :: idx (:) Source Code set_indexes Source Code subroutine set_indexes ( set_info , j , idx ) type ( set_info_t ), intent ( in ) :: set_info integer , intent ( in ) :: j integer , allocatable , intent ( inout ) :: idx (:) integer :: n if ( j > set_info % nsets ) then n = 0 else n = set_info % nels ( j ) endif if ( allocated ( idx )) deallocate ( idx ) allocate ( idx ( n )) idx (:) = set_info % indexes ( j )% ind (:) end subroutine set_indexes","tags":"","loc":"proc/set_indexes.html","title":"set_indexes – libPSML"},{"text":"Variables EMPTY_ASSOC_LIST Interfaces assoc_list_get_value Derived Types assoc_list_t Functions assoc_list_nitems Subroutines assoc_list_init assoc_list_reset assoc_list_insert assoc_list_get_key assoc_list_get_value_of_key assoc_list_get_value_by_index Variables Type Visibility Attributes Name Initial type( assoc_list_t ), public, save :: EMPTY_ASSOC_LIST Interfaces public interface assoc_list_get_value public subroutine assoc_list_get_value_by_index (a, i, value, stat) Arguments Type Intent Optional Attributes Name type( assoc_list_t ), intent(in) :: a integer, intent(in) :: i character(len=*), intent(out) :: value integer, intent(out) :: stat public subroutine assoc_list_get_value_of_key (a, key, value, stat) Arguments Type Intent Optional Attributes Name type( assoc_list_t ), intent(in) :: a character(len=*), intent(in) :: key character(len=*), intent(out) :: value integer, intent(out) :: stat Derived Types type, public :: assoc_list_t Components Type Visibility Attributes Name Initial integer, private :: nslots = 0 integer, private :: nitems = 0 character(len=50), private, allocatable :: key (:) character(len=120), private, allocatable :: value (:) Functions public function assoc_list_nitems (a) result(n) Arguments Type Intent Optional Attributes Name type( assoc_list_t ), intent(in) :: a Return Value integer Subroutines public subroutine assoc_list_init (a, n, stat) Arguments Type Intent Optional Attributes Name type( assoc_list_t ), intent(inout) :: a integer, intent(in) :: n integer, intent(out) :: stat public subroutine assoc_list_reset (a) Arguments Type Intent Optional Attributes Name type( assoc_list_t ), intent(inout) :: a public subroutine assoc_list_insert (a, key, value, stat) Arguments Type Intent Optional Attributes Name type( assoc_list_t ), intent(inout) :: a character(len=*), intent(in) :: key character(len=*), intent(in) :: value integer, intent(out) :: stat public subroutine assoc_list_get_key (a, i, key, stat) Arguments Type Intent Optional Attributes Name type( assoc_list_t ), intent(in) :: a integer, intent(in) :: i character(len=*), intent(out) :: key integer, intent(out) :: stat public subroutine assoc_list_get_value_of_key (a, key, value, stat) Arguments Type Intent Optional Attributes Name type( assoc_list_t ), intent(in) :: a character(len=*), intent(in) :: key character(len=*), intent(out) :: value integer, intent(out) :: stat public subroutine assoc_list_get_value_by_index (a, i, value, stat) Arguments Type Intent Optional Attributes Name type( assoc_list_t ), intent(in) :: a integer, intent(in) :: i character(len=*), intent(out) :: value integer, intent(out) :: stat","tags":"","loc":"module/assoc_list.html","title":"assoc_list – libPSML"},{"text":"Uses: assoc_list assoc_list Variables mod_name dp Interfaces print_type assignment(=) init delete refcount id name initialized same psml_die Derived Types Grid_ Grid Functions initialized_ same_ refcount_ id_ name_ valGrid annotationGrid sizeGrid Subroutines init_ delete_ assign_ tag_new_object delete_Data newGrid printGrid Variables Type Visibility Attributes Name Initial character(len=*), public, parameter :: mod_name = \"Grid\" integer, public, parameter :: dp = selected_real_kind(10, 100) Interfaces public interface print_type private subroutine printGrid (this) Arguments Type Intent Optional Attributes Name type( Grid ), intent(in) :: this public interface assignment(=) private subroutine assign_ (this, other) Arguments Type Intent Optional Attributes Name type( Grid ), intent(inout) :: this type( Grid ), intent(in) :: other public interface init private subroutine init_ (this) Arguments Type Intent Optional Attributes Name type( Grid ), intent(inout) :: this public interface delete private subroutine delete_ (this) Arguments Type Intent Optional Attributes Name type( Grid ), intent(inout) :: this public interface refcount private function refcount_ (this) result(count) Arguments Type Intent Optional Attributes Name type( Grid ), intent(in) :: this Return Value integer public interface id private function id_ (this) result(str) Arguments Type Intent Optional Attributes Name type( Grid ), intent(in) :: this Return Value character(len=36) public interface name private function name_ (this) result(str) Arguments Type Intent Optional Attributes Name type( Grid ), intent(in) :: this Return Value character(len=len_trim(this%data%name)) public interface initialized private pure function initialized_ (this) result(init) Arguments Type Intent Optional Attributes Name type( Grid ), intent(in) :: this Return Value logical public interface same private pure function same_ (this1, this2) result(same) Arguments Type Intent Optional Attributes Name type( Grid ), intent(in) :: this1 type( Grid ), intent(in) :: this2 Return Value logical interface private subroutine psml_die (str) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: str Derived Types type, public :: Grid_ Components Type Visibility Attributes Name Initial integer, public :: refCount = 0 character(len=36), public :: id = \"null_id\" character(len=256), public :: name = \"null Grid\" integer, public :: npts = 0 real(kind=dp), public, pointer :: grid_data (:) => null() type(ps_annotation_t), public :: annotation type, public :: Grid Components Type Visibility Attributes Name Initial type( Grid_ ), public, pointer :: data => null() Functions private pure function initialized_ (this) result(init) Arguments Type Intent Optional Attributes Name type( Grid ), intent(in) :: this Return Value logical private pure function same_ (this1, this2) result(same) Arguments Type Intent Optional Attributes Name type( Grid ), intent(in) :: this1 type( Grid ), intent(in) :: this2 Return Value logical private function refcount_ (this) result(count) Arguments Type Intent Optional Attributes Name type( Grid ), intent(in) :: this Return Value integer private function id_ (this) result(str) Arguments Type Intent Optional Attributes Name type( Grid ), intent(in) :: this Return Value character(len=36) private function name_ (this) result(str) Arguments Type Intent Optional Attributes Name type( Grid ), intent(in) :: this Return Value character(len=len_trim(this%data%name)) public function valGrid (this) result(p) Arguments Type Intent Optional Attributes Name type( Grid ), intent(in) :: this Return Value real(kind=dp),\n  pointer, (:) public function annotationGrid (this) result(p) Arguments Type Intent Optional Attributes Name type( Grid ), intent(in) :: this Return Value type(ps_annotation_t),\n  pointer public function sizeGrid (this) result(n) Arguments Type Intent Optional Attributes Name type( Grid ), intent(in) :: this Return Value integer Subroutines private subroutine init_ (this) Arguments Type Intent Optional Attributes Name type( Grid ), intent(inout) :: this private subroutine delete_ (this) Arguments Type Intent Optional Attributes Name type( Grid ), intent(inout) :: this private subroutine assign_ (this, other) Arguments Type Intent Optional Attributes Name type( Grid ), intent(inout) :: this type( Grid ), intent(in) :: other private subroutine tag_new_object (this) Arguments Type Intent Optional Attributes Name type( Grid ), intent(inout) :: this private subroutine delete_Data (gd) Arguments Type Intent Optional Attributes Name type( Grid_ ) :: gd public subroutine newGrid (this, n, name) Arguments Type Intent Optional Attributes Name type( Grid ), intent(inout) :: this integer, intent(in) :: n character(len=*), intent(in), optional :: name private subroutine printGrid (this) Arguments Type Intent Optional Attributes Name type( Grid ), intent(in) :: this","tags":"","loc":"module/class_grid.html","title":"class_Grid – libPSML"},{"text":"Interfaces psml_die Interfaces interface public subroutine psml_die (str) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: str","tags":"","loc":"module/external_interfaces.html","title":"external_interfaces – libPSML"},{"text":"Variables nq interpolator Interfaces interpolate Subroutines set_interpolator set_default_interpolator dpnint1 Variables Type Visibility Attributes Name Initial integer, public, save :: nq = 7 procedure( interpolate ), public, pointer :: interpolator => null() Interfaces interface public subroutine interpolate (nquality, x, y, npts, r, val, debug) Arguments Type Intent Optional Attributes Name integer, intent(in) :: nquality real(kind=dp), intent(in) :: x (*) real(kind=dp), intent(in) :: y (*) integer, intent(in) :: npts real(kind=dp), intent(in) :: r real(kind=dp), intent(out) :: val logical, intent(in) :: debug Subroutines public subroutine set_interpolator (func, nquality) Arguments Type Intent Optional Attributes Name public subroutine func(nquality, x, y, npts, r, val, debug) Arguments Type Intent Optional Attributes Name integer, intent(in) :: nquality real(kind=dp), intent(in) :: x (*) real(kind=dp), intent(in) :: y (*) integer, intent(in) :: npts real(kind=dp), intent(in) :: r real(kind=dp), intent(out) :: val logical, intent(in) :: debug integer, intent(in) :: nquality public subroutine set_default_interpolator () Arguments None private subroutine dpnint1 (npoly, xx, yy, nn, r, val, debug) Arguments Type Intent Optional Attributes Name integer, intent(in) :: npoly real(kind=dp), intent(in) :: xx (*) real(kind=dp), intent(in) :: yy (*) integer, intent(in) :: nn real(kind=dp), intent(in) :: r real(kind=dp), intent(out) :: val logical, intent(in) :: debug","tags":"","loc":"module/m_interp.html","title":"m_interp – libPSML"},{"text":"Uses: m_psml_reader m_psml_core m_psml_core m_psml_core m_psml_api m_psml_dump m_psml_ps_edit assoc_list assoc_list assoc_list assoc_list assoc_list assoc_list assoc_list","tags":"","loc":"module/m_psml.html","title":"m_psml – libPSML"},{"text":"Uses: m_psml_core assoc_list assoc_list external_interfaces class_Grid Procedures to handle the PSML pseudopotential format. Variables dp global_debug sym Functions ps_GetLibPSMLVersion ps_NValenceShells ps_ValenceShellL ps_ValenceShellN ps_ValenceShellOccupation ps_ValenceCharge_Value ps_CoreCharge_Value ps_CoreCharge_MatchingRadius ps_CoreCharge_NumberOfKeptDerivatives ps_AtomicSymbol ps_AtomicLabel ps_AtomicNumber ps_GetPSMLVersion ps_GetUUID ps_Creator ps_Date ps_PseudoFlavor ps_ZPseudo ps_GenerationZval ps_NLibxcFunctionals ps_LibxcName ps_LibxcId ps_LibxcWeight ps_LibxcIdArray ps_ValidLibxc ps_GetAnnotation ps_XCAnnotation ps_Relativity ps_IsSpinPolarized ps_HasCoreCorrections ps_Number_Of_Potentials ps_Number_Of_Projectors ps_Number_Of_PseudoWfs ps_Potential_Set ps_Potential_L ps_Potential_J ps_Potential_Rc ps_Potential_N ps_Potential_Value ps_PseudoWf_L ps_PseudoWf_J ps_PseudoWf_N ps_PseudoWf_Set ps_PseudoWf_Value ps_HasProjectors ps_HasLocalPotential ps_HasLocalCharge ps_HasPSOperator ps_HasSemilocalPotentials ps_LocalPotential_Value ps_LocalCharge_Value ps_LocalPotential_Type ps_Projector_L ps_Projector_J ps_Projector_Ekb ps_Projector_Seq ps_Projector_Set ps_Projector_Type ps_Projector_Value l_of_sym max_range eval_radfunc atomic_number Subroutines ps_SetDebug ps_SetInterpolator ps_SetInterpolatorQuality ps_ValenceCharge_GetRawData ps_CoreCharge_GetRawData ps_Get_Potential_Indexes ps_Get_Projector_Indexes ps_Get_PseudoWf_Indexes ps_Potential_GetRawData ps_PseudoWf_GetRawData ps_LocalPotential_GetRawData ps_Projector_GetRawData ps_Get_Projector_Indexes_byL GetSetIndexes check_index get_raw_radfunc assert Variables Type Visibility Attributes Name Initial integer, public, parameter :: dp = selected_real_kind(14) logical, public :: global_debug = .false. character(len=1), public, dimension(0:4) :: sym = (/\"s\", \"p\", \"d\", \"f\", \"g\"/) Functions public function ps_GetLibPSMLVersion () result(v) Returns the library version in integer format Arguments None Return Value integer public function ps_NValenceShells (ps) result(nshells) Returns the number of non-empty valence shells\n in the ps generation configuration\n @param ps is a handle to the psml information Arguments Type Intent Optional Attributes Name type( ps_t ), intent(in) :: ps Return Value integer public function ps_ValenceShellL (ps, i) result(l) Returns the angular momentum of the i'th valence shell\n in the ps generation configuration\n @param ps is a handle to the psml information\n @param i is the index of the shell Arguments Type Intent Optional Attributes Name type( ps_t ), intent(in) :: ps integer, intent(in) :: i Return Value integer public function ps_ValenceShellN (ps, i) result(n) Returns the principal quantum number of the i'th valence shell\n in the ps generation configuration\n @author Alberto Garcia\n @date 2014\n @param ps is a handle to the psml information\n @param i is the index of the shell Arguments Type Intent Optional Attributes Name type( ps_t ), intent(in) :: ps integer, intent(in) :: i Return Value integer public function ps_ValenceShellOccupation (ps, i, channel) result(occ) Returns the occupation of the i'th valence shell\n in the ps generation configuration\n @author Alberto Garcia\n @date 2014\n @param ps is a handle to the psml information\n @param i is the index of the shell\n @param channel is an optional parameter for spin-polarized \n calculations (\"u\" or \"d\"). Arguments Type Intent Optional Attributes Name type( ps_t ), intent(in) :: ps integer, intent(in) :: i character(len=1), intent(in), optional :: channel Return Value real(kind=dp) public function ps_ValenceCharge_Value (ps, r) result(val) Computes the value of the valence charge at r\n @param ps is a handle to the psml information\n @param r is the radius\n It returns the valence charge density integrated over\n solid angle, so that Q_val = int{ val r r } Arguments Type Intent Optional Attributes Name type( ps_t ), intent(in) :: ps real(kind=dp), intent(in) :: r Return Value real(kind=dp) public function ps_CoreCharge_Value (ps, r) result(val) Computes the value of the pseudo-core charge at r\n @param ps is a handle to the psml information\n @param r is the radius\n It returns the pseudo-core charge density integrated over\n solid angle, so that Q_core = int{ val r r } Arguments Type Intent Optional Attributes Name type( ps_t ), intent(in) :: ps real(kind=dp), intent(in) :: r Return Value real(kind=dp) public function ps_CoreCharge_MatchingRadius (ps) result(rmatch) Returns the matching radius used in the fit of the\n  pseudo-core charge\n @param ps is a handle to the psml information\n It returns -1.0 if the information is not provided in the file Arguments Type Intent Optional Attributes Name type( ps_t ), intent(in) :: ps Return Value real(kind=dp) public function ps_CoreCharge_NumberOfKeptDerivatives (ps) result(n) Returns the number of derivatives kept in the fit of the\n  pseudo-core charge\n @param ps is a handle to the psml information\n It returns -1 if the information is not provided in the file Arguments Type Intent Optional Attributes Name type( ps_t ), intent(in) :: ps Return Value integer public function ps_AtomicSymbol (ps) result(name) Returns the atomic symbol\n @param ps is a handle to the psml information Arguments Type Intent Optional Attributes Name type( ps_t ), intent(in) :: ps Return Value character(len=2) public function ps_AtomicLabel (ps) result(name) Returns the atomic label\n @param ps is a handle to the psml information\n The label is more general than the atomic symbol Arguments Type Intent Optional Attributes Name type( ps_t ), intent(in) :: ps Return Value character(len=len_trim(ps%header%atomic_label)) public function ps_AtomicNumber (ps) result(z) Returns the atomic number\n @param ps is a handle to the psml information Arguments Type Intent Optional Attributes Name type( ps_t ), intent(in) :: ps Return Value real(kind=dp) public function ps_GetPSMLVersion (ps) result(version) Returns the PSML version used in the file Arguments Type Intent Optional Attributes Name type( ps_t ), intent(in) :: ps Return Value character(len=10) public function ps_GetUUID (ps) result(name) Returns the unique uuid of the PSML file Arguments Type Intent Optional Attributes Name type( ps_t ), intent(in) :: ps Return Value character(len=36) public function ps_Creator (ps) result(name) Returns the creator of the PSML file, as\n written in the provenance element.\n @param ps is a handle to the psml information\n The format is arbitrary Arguments Type Intent Optional Attributes Name type( ps_t ), intent(in) :: ps Return Value character(len=len_trim(ps%provenance%creator)) public function ps_Date (ps) result(str) Returns the date appearing in the provenance element.\n @param ps is a handle to the psml information\n The format is arbitrary Arguments Type Intent Optional Attributes Name type( ps_t ), intent(in) :: ps Return Value character(len=len_trim(ps%provenance%date)) public function ps_PseudoFlavor (ps) result(str) category: needs_work\n  Returns the pseudization flavor appearing in the header element. Arguments Type Intent Optional Attributes Name type( ps_t ), intent(in) :: ps Handle for PSML information Return Value character(len=len_trim(ps%header%flavor)) public function ps_ZPseudo (ps) result(zpseudo) Returns the effective valence of the pseudo-atom,\n i.e., the atomic number minus the number of \"core\" electrons. Arguments Type Intent Optional Attributes Name type( ps_t ), intent(in) :: ps Handle for PSML information Return Value real(kind=dp) public function ps_GenerationZval (ps) result(zval) Returns the total valence charge density in the\n atomic configuration used to generate the pseudopotential.\n !> @param ps is a handle to the psml information Arguments Type Intent Optional Attributes Name type( ps_t ), intent(in) :: ps Return Value real(kind=dp) public function ps_NLibxcFunctionals (ps) result(xc_n) Returns the number of libxc functionals that\n would correspond to the exchange-correlation scheme\n used in the generation code.\n @param ps is a handle to the psml information Arguments Type Intent Optional Attributes Name type( ps_t ), intent(in) :: ps Return Value integer public function ps_LibxcName (ps, i) result(xc_name) Arguments Type Intent Optional Attributes Name type( ps_t ), intent(in) :: ps integer, intent(in) :: i Return Value character(len=50) public function ps_LibxcId (ps, i) result(xc_id) Arguments Type Intent Optional Attributes Name type( ps_t ), intent(in) :: ps integer, intent(in) :: i Return Value integer public function ps_LibxcWeight (ps, i) result(xc_weight) Arguments Type Intent Optional Attributes Name type( ps_t ), intent(in) :: ps integer, intent(in) :: i Return Value real(kind=dp) private function ps_LibxcIdArray (ps) result(xc_id_array) Arguments Type Intent Optional Attributes Name type( ps_t ), intent(in) :: ps Return Value integer\n  (2) public function ps_ValidLibxc (ps) result(libxc_ok) Arguments Type Intent Optional Attributes Name type( ps_t ), intent(in), target :: ps Return Value logical public function ps_GetAnnotation (ps, name) result(annotation) Returns the annotation associated to a\n given element. For grids, if a radial function\n handle is given, the annotation for that \n radial function's grid is returned. Otherwise,\n the return value is the annotation for the global grid.\n If there is no appropriate annotation, an empty\n structure is returned. Arguments Type Intent Optional Attributes Name type( ps_t ), intent(in) :: ps character(len=*), intent(in) :: name Return Value type(ps_annotation_t) public function ps_XCAnnotation (ps) result(xc_annotation) Arguments Type Intent Optional Attributes Name type( ps_t ), intent(in) :: ps Return Value type(ps_annotation_t) public function ps_Relativity (ps) result(rel) Arguments Type Intent Optional Attributes Name type( ps_t ), intent(in) :: ps Return Value character(len=6) public function ps_IsSpinPolarized (ps) result(pol) Arguments Type Intent Optional Attributes Name type( ps_t ), intent(in) :: ps Return Value logical public function ps_HasCoreCorrections (ps) result(cc) Arguments Type Intent Optional Attributes Name type( ps_t ), intent(in) :: ps Return Value logical public function ps_Number_Of_Potentials (ps, set) result(n) Arguments Type Intent Optional Attributes Name type( ps_t ), intent(in) :: ps integer, intent(in) :: set Return Value integer public function ps_Number_Of_Projectors (ps, set) result(n) Arguments Type Intent Optional Attributes Name type( ps_t ), intent(in) :: ps integer, intent(in) :: set Return Value integer public function ps_Number_Of_PseudoWfs (ps, set) result(n) Arguments Type Intent Optional Attributes Name type( ps_t ), intent(in) :: ps integer, intent(in) :: set Return Value integer public function ps_Potential_Set (ps, i) result(set) Arguments Type Intent Optional Attributes Name type( ps_t ), intent(in) :: ps integer, intent(in) :: i Return Value integer public function ps_Potential_L (ps, i) result(l) Arguments Type Intent Optional Attributes Name type( ps_t ), intent(in) :: ps integer, intent(in) :: i Return Value integer public function ps_Potential_J (ps, i) result(j) Arguments Type Intent Optional Attributes Name type( ps_t ), intent(in) :: ps integer, intent(in) :: i Return Value real(kind=dp) public function ps_Potential_Rc (ps, i) result(rc) Arguments Type Intent Optional Attributes Name type( ps_t ), intent(in) :: ps integer, intent(in) :: i Return Value real(kind=dp) public function ps_Potential_N (ps, i) result(n) Arguments Type Intent Optional Attributes Name type( ps_t ), intent(in) :: ps integer, intent(in) :: i Return Value integer public function ps_Potential_Value (ps, i, r) result(val) Evaluator by storage index Arguments Type Intent Optional Attributes Name type( ps_t ), intent(in) :: ps integer, intent(in) :: i real(kind=dp), intent(in) :: r Return Value real(kind=dp) public function ps_PseudoWf_L (ps, i) result(l) Arguments Type Intent Optional Attributes Name type( ps_t ), intent(in) :: ps integer, intent(in) :: i Return Value integer public function ps_PseudoWf_J (ps, i) result(j) Arguments Type Intent Optional Attributes Name type( ps_t ), intent(in) :: ps integer, intent(in) :: i Return Value real(kind=dp) public function ps_PseudoWf_N (ps, i) result(n) Arguments Type Intent Optional Attributes Name type( ps_t ), intent(in) :: ps integer, intent(in) :: i Return Value integer public function ps_PseudoWf_Set (ps, i) result(set) Arguments Type Intent Optional Attributes Name type( ps_t ), intent(in) :: ps integer, intent(in) :: i Return Value integer public function ps_PseudoWf_Value (ps, i, r) result(val) Arguments Type Intent Optional Attributes Name type( ps_t ), intent(in) :: ps integer, intent(in) :: i real(kind=dp), intent(in) :: r Return Value real(kind=dp) public function ps_HasProjectors (ps) result(p) Arguments Type Intent Optional Attributes Name type( ps_t ), intent(in) :: ps Return Value logical public function ps_HasLocalPotential (ps) result(p) Arguments Type Intent Optional Attributes Name type( ps_t ), intent(in) :: ps Return Value logical public function ps_HasLocalCharge (ps) result(p) Arguments Type Intent Optional Attributes Name type( ps_t ), intent(in) :: ps Return Value logical public function ps_HasPSOperator (ps) result(psop) Arguments Type Intent Optional Attributes Name type( ps_t ), intent(in) :: ps Return Value logical public function ps_HasSemilocalPotentials (ps) result(p) Arguments Type Intent Optional Attributes Name type( ps_t ), intent(in) :: ps Return Value logical public function ps_LocalPotential_Value (ps, r) result(val) Arguments Type Intent Optional Attributes Name type( ps_t ), intent(in) :: ps real(kind=dp), intent(in) :: r Return Value real(kind=dp) public function ps_LocalCharge_Value (ps, r) result(val) Arguments Type Intent Optional Attributes Name type( ps_t ), intent(in) :: ps real(kind=dp), intent(in) :: r Return Value real(kind=dp) public function ps_LocalPotential_Type (ps) result(type) Arguments Type Intent Optional Attributes Name type( ps_t ), intent(in) :: ps Return Value character(len=40) public function ps_Projector_L (ps, i) result(l) Arguments Type Intent Optional Attributes Name type( ps_t ), intent(in) :: ps integer, intent(in) :: i Return Value integer public function ps_Projector_J (ps, i) result(j) Arguments Type Intent Optional Attributes Name type( ps_t ), intent(in) :: ps integer, intent(in) :: i Return Value real(kind=dp) public function ps_Projector_Ekb (ps, i) result(ekb) Arguments Type Intent Optional Attributes Name type( ps_t ), intent(in) :: ps integer, intent(in) :: i Return Value real(kind=dp) public function ps_Projector_Seq (ps, i) result(seq) Arguments Type Intent Optional Attributes Name type( ps_t ), intent(in) :: ps integer, intent(in) :: i Return Value integer public function ps_Projector_Set (ps, i) result(set) Arguments Type Intent Optional Attributes Name type( ps_t ), intent(in) :: ps integer, intent(in) :: i Return Value integer public function ps_Projector_Type (ps, i) result(type) Arguments Type Intent Optional Attributes Name type( ps_t ), intent(in) :: ps integer, intent(in) :: i Return Value character(len=40) public function ps_Projector_Value (ps, i, r) result(val) Arguments Type Intent Optional Attributes Name type( ps_t ), intent(in) :: ps integer, intent(in) :: i real(kind=dp), intent(in) :: r Return Value real(kind=dp) private function l_of_sym (str, name) result(l) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: str character(len=*), intent(in) :: name Return Value integer private function max_range (f) result(range) Returns the maximum radius in a radfunc's grid Arguments Type Intent Optional Attributes Name type( radfunc_t ), intent(in) :: f Return Value real(kind=dp) private function eval_radfunc (f, r, debug) result(val) Arguments Type Intent Optional Attributes Name type( radfunc_t ), intent(in) :: f real(kind=dp), intent(in) :: r logical, intent(in) :: debug Return Value real(kind=dp) private function atomic_number (SYMBOL) result(Z) Arguments Type Intent Optional Attributes Name character(len=2), intent(in) :: SYMBOL Return Value integer Subroutines public subroutine ps_SetDebug (debug) Sets the global debug flag\n @param debug:logical Arguments Type Intent Optional Attributes Name logical, intent(in) :: debug public subroutine ps_SetInterpolator (func, nquality) Sets the default interpolator and\n its quality parameter Arguments Type Intent Optional Attributes Name public subroutine func(nquality, x, y, npts, r, val, debug) Arguments Type Intent Optional Attributes Name integer, intent(in) :: nquality real(kind=dp), intent(in) :: x (*) real(kind=dp), intent(in) :: y (*) integer, intent(in) :: npts real(kind=dp), intent(in) :: r real(kind=dp), intent(out) :: val logical, intent(in) :: debug integer, intent(in) :: nquality public subroutine ps_SetInterpolatorQuality (nquality) Sets the quality parameter of the current\n default interpolator. Useful when we do\n not care about the type of evaluator, but\n want to compare different qualities Arguments Type Intent Optional Attributes Name integer, intent(in) :: nquality public subroutine ps_ValenceCharge_GetRawData (ps, raw_r, raw_data) Arguments Type Intent Optional Attributes Name type( ps_t ), intent(in) :: ps real(kind=dp), intent(out), allocatable :: raw_r (:) real(kind=dp), intent(out), allocatable :: raw_data (:) public subroutine ps_CoreCharge_GetRawData (ps, raw_r, raw_data) Arguments Type Intent Optional Attributes Name type( ps_t ), intent(in) :: ps real(kind=dp), intent(out), allocatable :: raw_r (:) real(kind=dp), intent(out), allocatable :: raw_data (:) public subroutine ps_Get_Potential_Indexes (ps, set, indexes) Arguments Type Intent Optional Attributes Name type( ps_t ), intent(in) :: ps integer, intent(in) :: set integer, intent(inout), allocatable :: indexes (:) public subroutine ps_Get_Projector_Indexes (ps, set, indexes) Arguments Type Intent Optional Attributes Name type( ps_t ), intent(in) :: ps integer, intent(in) :: set integer, intent(inout), allocatable :: indexes (:) public subroutine ps_Get_PseudoWf_Indexes (ps, set, indexes) Arguments Type Intent Optional Attributes Name type( ps_t ), intent(in) :: ps integer, intent(in) :: set integer, intent(inout), allocatable :: indexes (:) public subroutine ps_Potential_GetRawData (ps, i, raw_r, raw_data) Arguments Type Intent Optional Attributes Name type( ps_t ), intent(in) :: ps integer, intent(in) :: i real(kind=dp), intent(out), allocatable :: raw_r (:) real(kind=dp), intent(out), allocatable :: raw_data (:) public subroutine ps_PseudoWf_GetRawData (ps, i, raw_r, raw_data) Arguments Type Intent Optional Attributes Name type( ps_t ), intent(in) :: ps integer, intent(in) :: i real(kind=dp), intent(out), allocatable :: raw_r (:) real(kind=dp), intent(out), allocatable :: raw_data (:) public subroutine ps_LocalPotential_GetRawData (ps, raw_r, raw_data) Arguments Type Intent Optional Attributes Name type( ps_t ), intent(in) :: ps real(kind=dp), intent(out), allocatable :: raw_r (:) real(kind=dp), intent(out), allocatable :: raw_data (:) public subroutine ps_Projector_GetRawData (ps, i, raw_r, raw_data) Deprecated Arguments Type Intent Optional Attributes Name type( ps_t ), intent(in) :: ps integer, intent(in) :: i real(kind=dp), intent(out), allocatable :: raw_r (:) real(kind=dp), intent(out), allocatable :: raw_data (:) public subroutine ps_Get_Projector_Indexes_byL (ps, l, idxset, idxl) Subset of projectors with given l\n Note that this function takes an array of indexes\n and returns another array of indexes\n There is currently no way to check that the idxset\n really corresponds to projectors... Arguments Type Intent Optional Attributes Name type( ps_t ), intent(in) :: ps integer, intent(in) :: l integer, intent(in) :: idxset (:) integer, intent(inout), allocatable :: idxl (:) private subroutine GetSetIndexes (nitems, setarray, set, indexes) Arguments Type Intent Optional Attributes Name integer, intent(in) :: nitems integer, intent(in) :: setarray (:) integer, intent(in) :: set integer, intent(inout), allocatable :: indexes (:) private subroutine check_index (i, n, str) Arguments Type Intent Optional Attributes Name integer, intent(in) :: i integer, intent(in) :: n character(len=*), intent(in) :: str private subroutine get_raw_radfunc (f, raw_r, raw_data) Arguments Type Intent Optional Attributes Name type( radfunc_t ), intent(in) :: f real(kind=dp), intent(out), allocatable :: raw_r (:) real(kind=dp), intent(out), allocatable :: raw_data (:) private subroutine assert (cond, message) Arguments Type Intent Optional Attributes Name logical, intent(in) :: cond character(len=*) :: message","tags":"","loc":"module/m_psml_api.html","title":"m_psml_api – libPSML"},{"text":"Uses: iso_varying_string assoc_list assoc_list class_Grid external_interfaces Variables PATCH_LEVEL PSML_LIBRARY_VERSION PSML_TARGET_VERSION_LO PSML_TARGET_VERSION_HI MAXN_SHELLS MAXN_WFNS dp SET_NULL SET_SREL SET_NONREL SET_SO SET_LJ SET_UP SET_DOWN SET_SPINAVE SET_SPINDIFF SET_USER1 SET_USER2 SET_ALL Derived Types input_file_t provenance_t header_t config_val_t xc_t radfunc_t slps_t sl_table_t semilocal_t local_t nlpj_t nl_table_t nonlocal_t pswfs_t valence_charge_t core_charge_t ps_t Functions setcode_of_string str_of_set Subroutines ps_destroy destroy_provenance destroy_semilocal destroy_slps destroy_local destroy_nonlocal destroy_nlpj destroy_radfunc destroy_xc Variables Type Visibility Attributes Name Initial integer, private, parameter :: PATCH_LEVEL = 3 integer, public, parameter :: PSML_LIBRARY_VERSION = 1000+PATCH_LEVEL real, public, parameter :: PSML_TARGET_VERSION_LO = 1.00 real, public, parameter :: PSML_TARGET_VERSION_HI = 1.01 integer, private, parameter :: MAXN_SHELLS = 20 integer, private, parameter :: MAXN_WFNS = 20 integer, private, parameter :: dp = selected_real_kind(14) integer, public, parameter :: SET_NULL = 0 integer, public, parameter :: SET_SREL = 1 integer, public, parameter :: SET_NONREL = 2 integer, public, parameter :: SET_SO = 4 integer, public, parameter :: SET_LJ = 8 integer, public, parameter :: SET_UP = 16 integer, public, parameter :: SET_DOWN = 32 integer, public, parameter :: SET_SPINAVE = 64 integer, public, parameter :: SET_SPINDIFF = 128 integer, public, parameter :: SET_USER1 = 256 integer, public, parameter :: SET_USER2 = 512 integer, public, parameter :: SET_ALL = 2**10-1 Derived Types type, public :: input_file_t Components Type Visibility Attributes Name Initial character(len=40), public :: name = \"-----\" type(varying_string), public :: buffer type, public :: provenance_t Components Type Visibility Attributes Name Initial type( provenance_t ), public, pointer :: prev => null() character(len=40), public :: creator = \"-----\" character(len=30), public :: date = \"-----\" type( input_file_t ), public :: input_file type(ps_annotation_t), public :: annotation type( provenance_t ), public, pointer :: next => null() type, public :: header_t Components Type Visibility Attributes Name Initial character(len=30), public :: atomic_label real(kind=dp), public :: z real(kind=dp), public :: zpseudo character(len=50), public :: flavor character(len=6), public :: relativity logical, public :: polarized character(len=3), public :: core_corrections type, public :: config_val_t Components Type Visibility Attributes Name Initial integer, public :: nshells real(kind=dp), public :: total_charge integer, public, dimension(MAXN_SHELLS) :: n character(len=1), public, dimension(MAXN_SHELLS) :: l real(kind=dp), public, dimension(MAXN_SHELLS) :: occ real(kind=dp), public, dimension(MAXN_SHELLS) :: occ_up real(kind=dp), public, dimension(MAXN_SHELLS) :: occ_down type(ps_annotation_t), public :: annotation type, public :: xc_t Components Type Visibility Attributes Name Initial integer, public :: n_functs_libxc = 0 character(len=50), public, allocatable :: libxc_name (:) character(len=50), public, allocatable :: libxc_type (:) integer, public, allocatable :: libxc_id (:) real(kind=dp), public, allocatable :: libxc_weight (:) type(ps_annotation_t), public :: annotation type, public :: radfunc_t Components Type Visibility Attributes Name Initial type(Grid), public :: grid real(kind=dp), public, dimension(:), pointer :: data => null() type, public :: slps_t Components Type Visibility Attributes Name Initial integer, public :: n character(len=1), public :: l real(kind=dp), public :: j integer, public :: set character(len=40), public :: flavor real(kind=dp), public :: rc type( radfunc_t ), public :: V type( semilocal_t ), public, pointer :: parent_group => null() type( slps_t ), public, pointer :: next => null() type, public :: sl_table_t Components Type Visibility Attributes Name Initial type( slps_t ), public, pointer :: p => null() type, public :: semilocal_t Components Type Visibility Attributes Name Initial type( slps_t ), public, pointer :: pot => null() integer, public :: set type(Grid), public :: grid type(ps_annotation_t), public :: annotation type( semilocal_t ), public, pointer :: next => null() type, public :: local_t Components Type Visibility Attributes Name Initial type(ps_annotation_t), public :: annotation type(Grid), public :: grid type( radfunc_t ), public :: Vlocal character(len=40), public :: vlocal_type type( radfunc_t ), public :: Chlocal type, public :: nlpj_t Components Type Visibility Attributes Name Initial integer, public :: seq character(len=1), public :: l real(kind=dp), public :: j integer, public :: set character(len=40), public :: type real(kind=dp), public :: ekb type( radfunc_t ), public :: proj type( nonlocal_t ), public, pointer :: parent_group => null() type( nlpj_t ), public, pointer :: next => null() type, public :: nl_table_t Components Type Visibility Attributes Name Initial type( nlpj_t ), public, pointer :: p => null() type, public :: nonlocal_t Components Type Visibility Attributes Name Initial type( nlpj_t ), public, pointer :: proj => null() integer, public :: set type(Grid), public :: grid type(ps_annotation_t), public :: annotation type( nonlocal_t ), public, pointer :: next => null() type, public :: pswfs_t Components Type Visibility Attributes Name Initial integer, public :: npswfs = 0 integer, public, dimension(MAXN_WFNS) :: n character(len=1), public, dimension(MAXN_WFNS) :: l real(kind=dp), public, dimension(MAXN_WFNS) :: j integer, public, dimension(MAXN_WFNS) :: set type( radfunc_t ), public, dimension(MAXN_WFNS) :: Phi type(Grid), public :: grid type(ps_annotation_t), public :: annotation type, public :: valence_charge_t Components Type Visibility Attributes Name Initial real(kind=dp), public :: total_charge type( radfunc_t ), public :: rho_val type(ps_annotation_t), public :: annotation type, public :: core_charge_t Components Type Visibility Attributes Name Initial integer, public :: n_cont_derivs real(kind=dp), public :: rcore type( radfunc_t ), public :: rho_core type(ps_annotation_t), public :: annotation type, public :: ps_t Components Type Visibility Attributes Name Initial character(len=10), public :: version = \"\" character(len=10), public :: energy_unit = \"\" character(len=10), public :: length_unit = \"\" character(len=36), public :: uuid = \"\" type(ps_annotation_t), public :: annotation type( provenance_t ), public, pointer :: provenance => null() type( header_t ), public :: header type( config_val_t ), public :: config_val type( xc_t ), public :: xc_info type(Grid), public :: global_grid type( local_t ), public :: local type( semilocal_t ), public, pointer :: semilocal => null() type( nonlocal_t ), public, pointer :: nonlocal => null() type( pswfs_t ), public :: pswfs type( valence_charge_t ), public :: valence_charge type( core_charge_t ), public :: core_charge type( sl_table_t ), public, allocatable :: sl_table (:) type( nl_table_t ), public, allocatable :: nl_table (:) Functions public function setcode_of_string (str) result(code) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: str Return Value integer public function str_of_set (code) result(str) Arguments Type Intent Optional Attributes Name integer, intent(in) :: code Return Value character(len=20) Subroutines public subroutine ps_destroy (ps) Arguments Type Intent Optional Attributes Name type( ps_t ), intent(inout) :: ps private subroutine destroy_provenance (p) Arguments Type Intent Optional Attributes Name type( provenance_t ), pointer :: p private subroutine destroy_semilocal (p) Arguments Type Intent Optional Attributes Name type( semilocal_t ), pointer :: p private subroutine destroy_slps (p) Arguments Type Intent Optional Attributes Name type( slps_t ), pointer :: p public subroutine destroy_local (p) Arguments Type Intent Optional Attributes Name type( local_t ) :: p public subroutine destroy_nonlocal (p) Arguments Type Intent Optional Attributes Name type( nonlocal_t ), pointer :: p private subroutine destroy_nlpj (p) Arguments Type Intent Optional Attributes Name type( nlpj_t ), pointer :: p private subroutine destroy_radfunc (rp) Arguments Type Intent Optional Attributes Name type( radfunc_t ) :: rp private subroutine destroy_xc (xp) Arguments Type Intent Optional Attributes Name type( xc_t ), intent(inout) :: xp","tags":"","loc":"module/m_psml_core.html","title":"m_psml_core – libPSML"},{"text":"Uses: m_psml_core assoc_list class_Grid external_interfaces Functions to handle PSML pseudopotential format structures\n @author Alberto Garcia Variables dp global_debug sym Subroutines ps_DumpToPSMLFile dump_provenance dump_xc_info dump_config_val dump_header dump_radfunc dump_valence_charge dump_core_charge dump_semilocal_potentials dump_local_potential dump_nonlocal_projectors dump_pseudo_wavefunctions dump_grid dump_annotation my_add_attribute Variables Type Visibility Attributes Name Initial integer, public, parameter :: dp = selected_real_kind(14) logical, public :: global_debug = .false. character(len=1), public, dimension(0:4) :: sym = (/\"s\", \"p\", \"d\", \"f\", \"g\"/) Subroutines public subroutine ps_DumpToPSMLFile (ps, fname, indent) Arguments Type Intent Optional Attributes Name type( ps_t ), intent(in) :: ps character(len=*), intent(in) :: fname logical, intent(in), optional :: indent private subroutine dump_provenance (xf, p) Arguments Type Intent Optional Attributes Name type(xmlf_t), intent(inout) :: xf type( provenance_t ), pointer :: p private subroutine dump_xc_info (xf, p) Arguments Type Intent Optional Attributes Name type(xmlf_t), intent(inout) :: xf type( xc_t ), intent(in) :: p private subroutine dump_config_val (xf, p) Arguments Type Intent Optional Attributes Name type(xmlf_t), intent(inout) :: xf type( config_val_t ), intent(in) :: p private subroutine dump_header (xf, ps) Arguments Type Intent Optional Attributes Name type(xmlf_t), intent(inout) :: xf type( ps_t ), intent(in), target :: ps private subroutine dump_radfunc (xf, rf, parent_grid) Arguments Type Intent Optional Attributes Name type(xmlf_t), intent(inout) :: xf type( radfunc_t ), intent(in) :: rf type(Grid_t) :: parent_grid private subroutine dump_valence_charge (xf, val, parent_grid) Arguments Type Intent Optional Attributes Name type(xmlf_t), intent(inout) :: xf type( valence_charge_t ), intent(in) :: val type(Grid_t) :: parent_grid private subroutine dump_core_charge (xf, core, parent_grid) Arguments Type Intent Optional Attributes Name type(xmlf_t), intent(inout) :: xf type( core_charge_t ), intent(in) :: core type(Grid_t) :: parent_grid private subroutine dump_semilocal_potentials (xf, ps) Arguments Type Intent Optional Attributes Name type(xmlf_t), intent(inout) :: xf type( ps_t ), intent(in), target :: ps private subroutine dump_local_potential (xf, ps) Arguments Type Intent Optional Attributes Name type(xmlf_t), intent(inout) :: xf type( ps_t ), intent(in), target :: ps private subroutine dump_nonlocal_projectors (xf, ps) Arguments Type Intent Optional Attributes Name type(xmlf_t), intent(inout) :: xf type( ps_t ), intent(in), target :: ps private subroutine dump_pseudo_wavefunctions (xf, ps) Arguments Type Intent Optional Attributes Name type(xmlf_t), intent(inout) :: xf type( ps_t ), intent(in), target :: ps private subroutine dump_grid (xf, agrid) Arguments Type Intent Optional Attributes Name type(xmlf_t), intent(inout) :: xf type(Grid_t), intent(in) :: agrid private subroutine dump_annotation (xf, annotation) Arguments Type Intent Optional Attributes Name type(xmlf_t), intent(inout) :: xf type(ps_annotation_t), intent(in) :: annotation private subroutine my_add_attribute (xf, name, value) Arguments Type Intent Optional Attributes Name type(xmlf_t), intent(inout) :: xf character(len=*), intent(in) :: name character(len=*), intent(in) :: value","tags":"","loc":"module/m_psml_dump.html","title":"m_psml_dump – libPSML"},{"text":"Uses: m_psml_core external_interfaces class_Grid assoc_list Variables pseudo debug_parsing in_psml in_slps in_radfunc in_semilocal in_header in_coreCharge in_data in_grid_data in_grid in_valenceCharge in_provenance in_input_file in_valence_config in_xc in_libxc_info in_pseudowavefun in_pswf in_chlocal in_nonlocal in_proj in_local_potential got_explicit_grid_data ndata ndata_grid n_funct current_wf_set current_sl_set current_proj_set top_flavor dp zval_generation tmp_grid gdata gannot pp qp ifp hp cp xp wfp slp qslp slvp qslvp lop nlp qnlp nlpp qnlpp valp corep rp parent_element Subroutines begin_element end_element pcdata_chunk cdata_section_chunk save_annotation Variables Type Visibility Attributes Name Initial type( ps_t ), public, pointer, save :: pseudo => null() logical, public, save :: debug_parsing = .false. logical, private, save :: in_psml = .false. logical, private, save :: in_slps = .false. logical, private, save :: in_radfunc = .false. logical, private, save :: in_semilocal = .false. logical, private, save :: in_header = .false. logical, private, save :: in_coreCharge = .false. logical, private, save :: in_data = .false. logical, private, save :: in_grid_data = .false. logical, private, save :: in_grid = .false. logical, private, save :: in_valenceCharge = .false. logical, private, save :: in_provenance = .false. logical, private, save :: in_input_file = .false. logical, private, save :: in_valence_config = .false. logical, private, save :: in_xc = .false. logical, private, save :: in_libxc_info = .false. logical, private, save :: in_pseudowavefun = .false. logical, private, save :: in_pswf = .false. logical, private, save :: in_chlocal = .false. logical, private, save :: in_nonlocal = .false. logical, private, save :: in_proj = .false. logical, private, save :: in_local_potential = .false. logical, private, save :: got_explicit_grid_data integer, private, save :: ndata integer, private, save :: ndata_grid integer, private, save :: n_funct character(len=20), private, save :: current_wf_set character(len=20), private, save :: current_sl_set character(len=20), private, save :: current_proj_set character(len=40), private, save :: top_flavor integer, private, parameter :: dp = selected_real_kind(14) real(kind=dp), private, save :: zval_generation type(Grid), private, save :: tmp_grid real(kind=dp), private, save, pointer :: gdata (:) => null() type(ps_annotation_t), private, save, pointer :: gannot => null() type( provenance_t ), private, pointer :: pp => null() type( provenance_t ), private, pointer :: qp => null() type( input_file_t ), private, pointer :: ifp => null() type( header_t ), private, pointer :: hp => null() type( config_val_t ), private, pointer :: cp => null() type( xc_t ), private, pointer :: xp => null() type( pswfs_t ), private, pointer :: wfp => null() type( semilocal_t ), private, pointer :: slp => null() type( semilocal_t ), private, pointer :: qslp => null() type( slps_t ), private, pointer :: slvp => null() type( slps_t ), private, pointer :: qslvp => null() type( local_t ), private, pointer :: lop => null() type( nonlocal_t ), private, pointer :: nlp => null() type( nonlocal_t ), private, pointer :: qnlp => null() type( nlpj_t ), private, pointer :: nlpp => null() type( nlpj_t ), private, pointer :: qnlpp => null() type( valence_charge_t ), private, pointer :: valp => null() type( core_charge_t ), private, pointer :: corep => null() type( radfunc_t ), private, pointer :: rp => null() character(len=100), private, save :: parent_element = \"\" Subroutines public subroutine begin_element (name, attributes) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: name type(dictionary_t), intent(in) :: attributes public subroutine end_element (name) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: name public subroutine pcdata_chunk (chunk) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: chunk public subroutine cdata_section_chunk (chunk) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: chunk private subroutine save_annotation (atts, annotation) Arguments Type Intent Optional Attributes Name type(dictionary_t), intent(in) :: atts type(ps_annotation_t), intent(out) :: annotation","tags":"","loc":"module/m_psml_parsing_helpers.html","title":"m_psml_parsing_helpers – libPSML"},{"text":"Uses: m_psml_core external_interfaces assoc_list Functions to edit the PSML ps_t structure\n @author Alberto Garcia Subroutines ps_SetPSMLVersion ps_SetUUID ps_AddProvenanceRecord ps_Delete_NonlocalProjectors ps_Delete_LocalPotential Subroutines public subroutine ps_SetPSMLVersion (ps, version) Arguments Type Intent Optional Attributes Name type( ps_t ), intent(inout) :: ps character(len=*), intent(in) :: version public subroutine ps_SetUUID (ps, id) Arguments Type Intent Optional Attributes Name type( ps_t ), intent(inout) :: ps character(len=36), intent(in) :: id public subroutine ps_AddProvenanceRecord (ps, creator, date, annotation) Arguments Type Intent Optional Attributes Name type( ps_t ), intent(inout) :: ps character(len=*), intent(in) :: creator character(len=*), intent(in) :: date type(ps_annotation_t), intent(in), target :: annotation public subroutine ps_Delete_NonlocalProjectors (ps) Arguments Type Intent Optional Attributes Name type( ps_t ), intent(inout) :: ps public subroutine ps_Delete_LocalPotential (ps) Arguments Type Intent Optional Attributes Name type( ps_t ), intent(inout) :: ps","tags":"","loc":"module/m_psml_ps_edit.html","title":"m_psml_ps_edit – libPSML"},{"text":"Subroutines psml_reader Subroutines public subroutine psml_reader (fname, ps, debug) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: fname type( ps_t ), intent(inout), target :: ps logical, intent(in), optional :: debug","tags":"","loc":"module/m_psml_reader.html","title":"m_psml_reader – libPSML"},{"text":"Uses: m_psml_core Functions to handle PSML pseudopotential format structures\n @author Alberto Garcia Subroutines generate_table_sl generate_table_nl ps_GenerateTables Subroutines private subroutine generate_table_sl (ps) Arguments Type Intent Optional Attributes Name type( ps_t ), intent(inout), target :: ps private subroutine generate_table_nl (ps) Arguments Type Intent Optional Attributes Name type( ps_t ), intent(inout), target :: ps public subroutine ps_GenerateTables (ps) Arguments Type Intent Optional Attributes Name type( ps_t ), intent(inout), target :: ps","tags":"","loc":"module/m_psml_tables.html","title":"m_psml_tables – libPSML"},{"text":"Variables MAX_NSETS Derived Types alloc_t set_info_t Functions nsets set_id Subroutines clear display sort_sets set_indexes Variables Type Visibility Attributes Name Initial integer, private, parameter :: MAX_NSETS = 10 Derived Types type, private :: alloc_t Components Type Visibility Attributes Name Initial integer, public, allocatable :: ind (:) type, public :: set_info_t Components Type Visibility Attributes Name Initial integer, private :: nsets integer, private :: set (MAX_NSETS) integer, private :: nels (MAX_NSETS) type( alloc_t ), private :: indexes (MAX_NSETS) Functions public function nsets (set_info) result(n) Arguments Type Intent Optional Attributes Name type( set_info_t ), intent(in) :: set_info Return Value integer public function set_id (set_info, j) Arguments Type Intent Optional Attributes Name type( set_info_t ), intent(in) :: set_info integer, intent(in) :: j Return Value integer Subroutines private subroutine clear (set_info) Arguments Type Intent Optional Attributes Name type( set_info_t ), intent(inout) :: set_info public subroutine display (set_info) Arguments Type Intent Optional Attributes Name type( set_info_t ), intent(in) :: set_info public subroutine sort_sets (n, a, set_info) Arguments Type Intent Optional Attributes Name integer, intent(in) :: n integer, intent(in) :: a (:) type( set_info_t ), intent(inout) :: set_info public subroutine set_indexes (set_info, j, idx) Arguments Type Intent Optional Attributes Name type( set_info_t ), intent(in) :: set_info integer, intent(in) :: j integer, intent(inout), allocatable :: idx (:)","tags":"","loc":"module/sets_m.html","title":"sets_m – libPSML"},{"text":"Several well-known programs generate pseudopotentials in a variety of\nformats, tailored to the needs of electronic-structure codes. While\nsome generators are now able to output data in different bespoke\nformats, and some simulation codes are now able to read different\npseudopotential formats, the common historical pattern in the design\nof those formats has been that a generator produced data for a single\nparticular simulation code, most likely maintained by the same\ngroup. This implied that a number of implicit assumptions, shared by\ngenerator and user, have gone into the formats and fossilized there. One can say that there has been a projection of the domain's ontology\nonto the implementation level specific to the pair of programs. Other\ngenerators and users aiming at producing or reading the same format\nmust juggle both their own projections and the target one. In some\ncases, some information cannot be replicated. This leads to practical problems, not only of programming, but of\ninteroperability and reproducibility, which depend on spelling out\nquite a number of details which are not well represented for all codes\nin existing formats. The solution to the abstract problem is to design a data format that\nfaithfully maps the relevant concepts of the domain's ontology. In the\ncontext of norm-conserving pseudopotentials, the basic ontology is\ncomposed of radial functions (semilocal pseudopotentials, charge\ndensities, projectors, local potentials) plus some metadata that\nrepresents provenance and documents the type of pseudopotential. The PSML file format for norm-conserving pseudopotential data is\ndesigned to encapsulate as much as possible the abstract concepts in\nthe domain's ontology. For example, the format, together with its\nsupporting processing library libPSML, offers a very good approximation to an\nabstract mathematical function (an object which produces a value from\nits input). The format also provides a rich set of metadata to\ndocument the provenance (i.e., the generation history) and the\ngeneration conditions and flavor of the pseudopotential. PSML is based on XML, and it is by nature extensible, offering a basic\nset of elements and a number of extra features that can be exploited\nfor sophisticated uses or future improvements.","tags":"","loc":"page//index.html","title":"Overview – libPSML"},{"text":"Introduction PSML is a file format for norm-conserving\npseudopotential data which is designed to encapsulate as much as\npossible the concepts in the domain’s ontology. For example,\nthe format, together with its supporting processing library, offers a\nvery good approximation to an abstract mathematical function (an object\nwhich produces a value from its input). PSML also provides a rich\nset of metadata to document the provenance (i.e., the generation\nhistory) and the generation conditions and flavor of the\npseudopotential. The format is based on XML, and it is by\nnature extensible, offering a basic set of elements and a number of\nextra features that can be exploited for sophisticated uses or future\nimprovements. Schema for PSML # # Schema for PSML format # RELAX-NG compact form. See: http://www.relaxng.org/compact-tutorial-20030326.htm # # This form can be processed by the jing/trang set of tools, available from #   https://github.com/relaxng/jing-trang # # The 'jing' validator can work directly with this .rnc file (RELAX-NG compact form), # and this is the preferred option. # # The 'trang' converter can be used to generate other schema forms, such as: # #     .rng (RELAX-NG xml form), .xsd (XML Schema) # # But note that some features of RELAX-NG cannot be completely represented by XML Schema # schema files: # #  - The optional attribute group '(occupation-up, occupation-down)' below. #    In this case both attributes are considered to be independently optional in xsd. #  - The 'arbitrary attribute' form is not completely supported. # start = PSML PSML = element psml { # First section. In any order (& operator): ( psml . atts # Global attributes & annotation ? # Optional annotation & Provenance + # One or more provenance elements & Header # Just one header element & TopGrid ? ) # Optional top-level grid , # ',' is the ordered concatenation operator # Second section. In any order: ( SemiLocal * # Zero or more semilocal groups & Local ? # Optional local potential & WaveFunctions * # Zero or more wf groups & NonLocal * # Zero or more fully nonlocal groups & ValenceCharge # Valence charge density & CoreCharge ? ) # Optional pseudo-core charge } # # Definitions of the above grammar symbols follow # # Global Attributes # psml . atts = attribute energy_unit { \"hartree\" } & attribute length_unit { \"bohr\" } & attribute uuid { text } & attribute version { xsd : decimal } # # Provenance: Optional annotation; zero or more input files # Provenance = element provenance { attribute creator { text } & attribute date { xsd : string } & annotation ? & element input - file { attribute name { xsd : string }, text } * } Header = element header { header . atts , ( XC & ValenceConf ) } header . atts = attribute atomic - label { xsd : string }, attribute atomic - number { xsd : integer }, attribute core - corrections { \"yes\" | \"no\" }, attribute flavor { text }, attribute polarized { \"yes\" | \"no\" }, attribute relativity { \"no\" | \"scalar\" | \"dirac\" }, attribute z - pseudo { xsd : integer } XC = element exchange - correlation { annotation ? & element libxc - info { attribute number - of - functionals { xsd : integer }, element functional { attribute id { xsd : integer }, attribute name { text }, # allow canonical names and libxc-style symbols attribute type { \"exchange\" | \"correlation\" | \"exchange-correlation\" | \"XC_EXCHANGE\" | \"XC_CORRELATION\" | \"XC_EXCHANGE_CORRELATION\" } ? , attribute weight { xsd : double } ? } + } } ValenceConf = element valence - configuration { attribute total - valence - charge { xsd : double }, annotation ? , element shell { attribute_l , attribute n { xsd : integer }, attribute occupation { xsd : double }, ( attribute occupation - up { xsd : double }, attribute occupation - down { xsd : double }) ? } + } TopGrid = grid SemiLocal = element semilocal - potentials { attribute_set , annotation ? , element slps { attribute flavor { text }, attribute_l , attribute_j ? , attribute n { xsd : integer }, attribute rc { xsd : double }, radfunc } + } ValenceCharge = element valence - charge { attribute total - charge { xsd : integer }, annotation ? , radfunc } CoreCharge = element pseudocore - charge { attribute matching - radius { xsd : double }, attribute number - of - continuous - derivatives { xsd : integer }, annotation ? , radfunc } WaveFunctions = element pseudo - wave - functions { attribute_set , annotation ? , element pswf { attribute_l , attribute_j ? , attribute n { xsd : integer }, radfunc } + } Local = element local - potential { attribute type { xsd : string }, annotation ? , grid ? , radfunc , element local - charge { radfunc } ? # Optional local-charge element } NonLocal = element nonlocal - projectors { attribute_set , annotation ? , grid ? , element proj { attribute ekb { xsd : double }, attribute_l , attribute_j ? , attribute seq { xsd : integer }, attribute type { xsd : string }, radfunc } + } grid = element grid { attribute npts { xsd : integer }, annotation ? , element grid - data { # One or more floating point numbers list { xsd : double + } } } radfunc = element radfunc { grid ? , # Optional grid element element data { # Data is one or more floating point numbers list { xsd : double + } } } # # This is the way to leave the annotations # as collections of one or more arbitrary attributes # any_attribute = attribute * { text } annotation = element annotation { any_attribute + } # # Convenience enumeration definitions # attribute_l = attribute l { \"s\" | \"p\" | \"d\" | \"f\" | \"g\" } attribute_j = attribute j { \"0.0\" | \"0.5\" | \"1.5\" | \"2.5\" | \"3.5\" | \"4.5\" } attribute_set = attribute set { \"non_relativistic\" | \"scalar_relativistic\" | \"spin_orbit\" | \"lj\" | \"up\" | \"down\" | \"spin_average\" | \"spin_difference\" | \"user_extension1\" | \"user_extension2\" }","tags":"","loc":"page/01_the_psml_format/index.html","title":"PSML description – libPSML"},{"text":"As a proof of concept of the PSML vision, we have modified two\ndifferent atomic pseudopotential generation codes to generate PSML\nfiles, and interfaced libPSML to two electronic-structure programs. ONCVPSP The first generator is the open-source ONCVPSP code implemented by D. Hamann to\ngenerate optimized multiple-projector norm-conserving\npseudopotentials. The projectors are directly stored in the PSML\nformat together with a choice for the local potential. In addition, a\nset of semi-local potentials, a by-product of the ONCVPSP algorithm,\nis also included in the PSML file. The patches needed to produce PSML\noutput in ONCVPSP are available in Launchpad . To ease the production\nof XML, a special library (wxml, part of the xmlf90\nproject maintained by one of the\nauthors (A.G.)) is used. ATOM The second generator enabled for PSML output is the ATOM code,\noriginally developed by S. Froyen, later modified by N. Troullier and\nJ. L. Martins, and currently maintained by one of us (A. G.)  within\nthe SIESTA project.  ATOM, freely\ndistributed to the academic community, generates norm-conserving\npseudopotentials in the semilocal form. In addition, we have developed a post-processing tool (PSOP, currently\navailable in a branch of SIESTA development) which takes as input the semilocal components\nand computes the local part of the pseudopotential and the KB\nprojector functions in the same way as it is done within the SIESTA\ncode. These new elements, together with a new provenance record, are\nincorporated in a new PSML file, which describes a well-defined,\nclient-code independent and unique operator. We have thus already two different generators of PSML files, their\nspecific idiosyncrasies being describable by a common standard. Our\nplans are to enable PSML output in other pseudopotential-generation\ncodes.","tags":"","loc":"page/01_the_psml_format/01_generators/index.html","title":"Pseudopotential generators supporting PSML – libPSML"},{"text":"On the client side, we have incorporated the libPSML library in SIESTA\n( branch to be merged soon) and ABINIT (version 8.2 and higher). PSML files can\nthen be directly read and digested by these codes, achieving\npseudopotential interoperability.","tags":"","loc":"page/01_the_psml_format/02_clients/index.html","title":"First-principles codes able to read PSML files – libPSML"},{"text":"The basic modus operandi is to parse a PSML file, storing the information\nin an abstract handle ps_t , and then to query the handle to\nextract the relevant data. use m_psml type ( psml_t ) :: ps call psml_reader ( \"input.psml\" , ps , debug = . false .) print * , ps_GetPSMLVersion ( ps ) ... call ps_destroy ( ps ) Library version identification Parsing and handle processing Basic metadata Predicate routines for contents Header data extraction Exchange-correlation information Electronic configuration Semilocal potentials Vlocal Local Charge Projectors Pseudo-wave-functions Valence charge Pseudo-core charge Library version identification ps_GetLibPSMLVersion Parsing and handle processing psml_reader ps_destroy Basic metadata ps_GetUUID ps_GetPSMLVersion ps_Creator ps_Date Predicate routines for contents ps_HasSemilocalPotentials ps_HasPSOperator ps_HasLocalPotential ps_HasLocalCharge ps_HasProjectors ps_HasCoreCorrections Header data extraction ps_AtomicSymbol ps_AtomicLabel ps_AtomicNumber ps_ZPseudo ps_GenerationZval ps_PseudoFlavor ps_Relativity ps_IsSpinPolarized ps_HasCoreCorrections Exchange-correlation information ps_NLibxcFunctionals ps_LibxcName ps_LibxcId ps_LibxcWeight ps_ValidLibxc ps_XCAnnotation Electronic configuration ps_NValenceShells ps_ValenceShellL ps_ValenceShellN ps_ValenceShellOccupation Semilocal potentials ps_HasSemilocalPotentials ps_Get_Potential_Indexes ps_Number_Of_Potentials ps_Potential_L ps_Potential_J ps_Potential_N ps_Potential_Rc ps_Potential_Set ps_Potential_Value ps_Potential_GetRawData Vlocal ps_HasLocalPotential ps_LocalPotential_Value ps_LocalPotential_Type ps_LocalPotential_GetRawData Local Charge ps_HasLocalCharge ps_LocalCharge_Value Projectors ps_HasProjectors ps_Number_Of_Projectors ps_Get_Projector_Indexes ps_Get_Projector_Indexes_byL ps_Projector_L ps_Projector_J ps_Projector_Seq ps_Projector_Ekb ps_Projector_Type ps_Projector_Set ps_Projector_Value ps_Projector_GetRawData Pseudo-wave-functions ps_Number_Of_PseudoWfs ps_Get_PseudoWf_Indexes ps_PseudoWf_L ps_PseudoWf_J ps_PseudoWf_N ps_PseudoWf_Set ps_PseudoWf_Value ps_PseudoWf_GetRawData Valence charge ps_ValenceCharge_Value ps_ValenceCharge_GetRawData Pseudo-core charge ps_CoreCharge_Value ps_CoreCharge_GetRawData ps_CoreCharge_MatchingRadius ps_CoreCharge_NumberOfKeptDerivatives","tags":"","loc":"page/02_library_user_guide/index.html","title":"libPSML User Guide – libPSML"},{"text":"Just a stub, but let me write a reference: The type is defined here ps_t .","tags":"","loc":"page/03_library_developer_notes/index.html","title":"Developer Notes – libPSML"}]}